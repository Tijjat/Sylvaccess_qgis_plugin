"""
/***************************************************************************
 cables
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QCoreApplication
from .console import console_warning, console_info 
import numpy as np
import os, gc, datetime, sys
from osgeo import gdal, ogr, osr
from .gis import  load_float_raster_simple, ArrayToGtiff, get_source_src, get_proj_from_road_network, save_raster_info, shapefile_obs_to_np_array, shapefile_to_np_array, load_float_raster, check_field, loadrasterinfo_from_file
from .general import heures, save_integer_ascii, raster_get_info, read_info, read_raster, clear_big_nparray, from_az_to_arr
from .console import console_warning, console_info
from .function_np import  exposition, OptPyl_Up, OptPyl_Down, OptPyl_Down_NoH, OptPyl_Up_NoH, get_line_carac_vol, get_line_carac_simple, OptPyl_Down_init, OptPyl_Down_init_NoH, Tabmesh, get_npix, Check_line2, Check_line3, get_prop, focal_stat_max
from scipy.interpolate import InterpolatedUnivariateSpline
from scipy import spatial
from .skidder import pente


####################################################
#  ______     ___      .______    __       _______ #
# /      |   /   \     |   _  \  |  |     |   ____|#
#|  ,----'  /  ^  \    |  |_)  | |  |     |  |__   #
#|  |      /  /_\  \   |   _  <  |  |     |   __|  #
#|  `----./  _____  \  |  |_)  | |  `----.|  |____ #
# \______/__/     \__\ |______/  |_______||_______|#
####################################################
 
                                                  
# Fonctions qui gère les calculs liés au cable
def Cable(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,file_Htree,file_Vol_AM,file_Vol_ha,Pente_max_bucheron,
          Cable_type,sup_max,Htower,Lmax,Lmin,Carriage_type,Pchar,slope_grav,slope_Wliner_up,slope_Wliner_down,d,masse_li,
          rupt_res,E,Hintsup,Hend,Hline_min,Hline_max,Lhor_max,Load_max,safe_fact,test_cable_optimise,precision,prelevement,
          lim_list,w_list):

    masse_li2 = 0.5
    masse_li3 = 0.5
    LminSpan = 50
    Max_angle = 30
    coeff_frot = 0.15
    angle_transv = 60
    slope_trans = 30
    Lslope = 75
    PropSlope = 0.15
    VariaH = 0

    Hdebut = datetime.datetime.now()
    Dir_temp = Wspace+"Temp/"  
    ### Check if temporary files have been generated and have the same extent
    try:
        _,values,proj,Extent = raster_get_info(file_MNT)
        Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    except:
        txt = QCoreApplication.translate("MainWindow", "Error: please define a projection for DTM raster")
        console_warning(txt)
        return ""
    try: 
        _,v1=read_info(Dir_temp+'info_extent.txt')
        for i,item in enumerate(values):
            if v1[i]!=round(item,2):
                prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable)
            if i+1>4:break
    except:
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable)
    
    # Inputs
    try:
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))                
        MNT= np.load(Dir_temp+"MNT.npy") 
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy") 
        try:
            Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        except:
            Aspect = np.uint16(exposition(MNT,Csize,-9999))    
        try:
            CoordRoute= np.load(Dir_temp+"CoordRoute.npy") 
        except:
            TableX,TableY=create_coord_pixel_center_raster(values,nrows,ncols,Csize,Dir_temp)
            CoordRoute = np.zeros((Lien_RF.shape[0],2),dtype=np.float32)
            for i,pixel in enumerate(Lien_RF):
                CoordRoute[i,0]=TableX[pixel[1]]
                CoordRoute[i,1]=TableY[pixel[0]] 
            np.save(Dir_temp+"CoordRoute.npy",CoordRoute) 
            del TableX,TableY
        try:
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
        except:
            Pente = np.uint16(prepa_obstacle_cable(Dir_Obs_cable,file_MNT,Dir_temp))
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
    except: 
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable)
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))
        Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))         
        MNT= np.load(Dir_temp+"MNT.npy") 
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy")  
        CoordRoute= np.load(Dir_temp+"CoordRoute.npy")
        Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)    

    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    
     
    ### Import optional files
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
        Vol_ha[Pente>Pente_max_bucheron]=0 
        test_vp = True
    else:test_vp = False
    if file_Vol_AM != "":
        Vol_AM = load_float_raster_simple(file_Vol_AM) 
        Vol_AM[Pente>Pente_max_bucheron]=0
        test_vam = True
    else:test_vam = False 
    if file_Htree != "":
        Hfor = load_float_raster_simple(file_Htree) 
        test_hfor = True
    else:
        Hfor=0
        test_hfor = False
    if test_vp or test_vam:
        if not test_vp:
            Vol_ha = np.zeros_like(MNT)
        if not test_vam:
            Vol_AM = np.zeros_like(MNT)


    Lmax2 = round(Lmax-(np.sqrt(2)*(max(np.max(Hfor)*0.6666,Hend)+5)),0) #In order to take into account anchorage
    Row_line,Col_line,D_line,Nbpix_line, Row_ext,Col_ext,D_ext,Dir_list=create_buffer(Csize,Lmax2,Lhor_max)    
    road_network_proj=get_proj_from_road_network(file_shp_Cable_dep)
    Skid_direction = 0
    Rspace_c,_,slope_min_up,slope_max_up,slope_min_down,slope_max_down=get_cable_configs(Rspace,Cable_type,Carriage_type,slope_Wliner_up,slope_Wliner_down,slope_grav,Skid_direction) 
    try:os.mkdir(Rspace_c)
    except:pass
    Rspace_c+="/"
    Rspace_sel = Rspace_c+"FilesForOptimisation"
    try:os.mkdir(Rspace_sel)
    except:pass
    Rspace_sel+="/"
    save_raster_info(values,Rspace_sel)
    ### Calculation of useful variables
    g = 9.80665     # m.s-2
    angle_intsup = np.radians(Max_angle) 
    Fo =  g*(Load_max+Pchar)
    Lsans_foret = min(Lmax*0.1,Lmin)          # Longueur max contigue sans foret
    Ao = 0.25*np.pi*(d**2) 
    Tmax = float(rupt_res)*g/float(safe_fact)
    EAo = E*Ao
    idLinemin = np.max([1,int(LminSpan/Csize+1.5),int(10/Csize+0.5)])
    
    # D H diag slope fact indmin indmax LoL ThL TvL TupL TdownL LoUg ThUg TvUg ind_fin_span free xmidL zmidL 
    # 0 1 2    3     4    5      6      7   8   9   10   11     12   13   14   15           16   17    18  
    Span = np.zeros((sup_max+1,16),dtype=np.float32)
    rastLosup,rastTh,rastTv= check_tabconv(Dir_temp,d,E,Tmax,Lmax2,Fo,masse_li,masse_li2,masse_li3,Csize)    
    
    ### Preparation of forest roads
    nbconfig = 5       
    if precision > 1:Dir_list = range(0,360,2)
    if precision == 3:
        step_route = 2
        nbconfig = 1       
    else:
        step_route = 1
    nb_pixel_route = int((Lien_RF.shape[0]-1)/float(step_route))    
    
    Fin_ligne_forcee = np.int8(np.greater(Aerian_obs+(MNT<0),0))
    
    txt = QCoreApplication.translate("MainWindow", "    -Initialization performed, start of processing...")
    console_info("\n" + txt)
    str_nb_pixel_route=  " / "+str(nb_pixel_route-1)+ " processed pixels"
    
    Tab = np.zeros((min(1000000,int(nb_pixel_route*(360)/step_route)),18+5*sup_max),dtype=np.int16)
    File_Tab = []
    Tab_nb=0
    
    testExist = False
    if np.sum(Lien_RF[:,2]==1)>0:
        testExist = True
    
    ##############################################################################################################################################
    ### 2. PROCESSING OF THE AREA: TEST ALL POSSIBLE LINES
    ##############################################################################################################################################
    
    # Loop on forest road pixels
    Route = range(1,Lien_RF.shape[0]-1,step_route)
    id_line = 0
    Rast_couv = np.zeros((nrows,ncols),dtype=np.int8)
    if testExist:
        Rast_couv2 = np.zeros((nrows,ncols),dtype=np.int8)
    test=0
    for idpix,pixel in enumerate(Route):  
        # console_info process
        sys.stdout.write("\r%d" % idpix + str_nb_pixel_route)
        sys.stdout.flush()
        #Get point coordinates
        coordY = Lien_RF[pixel,0]
        coordX = Lien_RF[pixel,1]
        direction = Lien_RF[pixel,4]
        if MNT[coordY,coordX]>-9999 and not Aerian_obs[coordY,coordX]:             
            RoadState = Lien_RF[pixel,2]
            posiY = CoordRoute[pixel,1]
            posiX = CoordRoute[pixel,0]   
            for az in Dir_list:                                          
                test,Lline,Line = get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax2,Lmin,Csize,
                                             Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
                                             Fo,Tmax,masse_li,masse_li2,masse_li3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope)   
                if test==1:           
                    Span*=0    
                    Falt = InterpolatedUnivariateSpline(Line[:,0],Line[:,1])
                    Alts = Falt(np.arange(0.,Lline,0.5))
                    ### Optimize line
                    if Line[0,1]+Htower>=np.max(Line[idLinemin:,1])+Hend:   
                        if direction==2:
                            continue
                        #console_info az,"up",Line[-1,0] 
                        if VariaH:
                            Span = OptPyl_Up(Line,Alts,Span,Htower,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,
                                                 Csize,angle_intsup,EAo,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                 LminSpan,slope_min_up,slope_max_up,test_hfor,nbconfig)
                        else:
                            Span = OptPyl_Up_NoH(Line,Alts,Span,Htower,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,
                                                     Csize,angle_intsup,EAo,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                     LminSpan,slope_min_up,slope_max_up,test_hfor,nbconfig)
                        config = 1
                    else:    
                        if direction==1:
                            continue
                        #console_info az,"down",Line[-1,0]
                        if VariaH:
                            Span = OptPyl_Down_init(Line,Alts,Span,Htower, Hend,masse_li,masse_li2,masse_li3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo, 
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,test_hfor)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = OptPyl_Down(Line2,Alts,Span*0,Htower,Hintsup,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,Csize,angle_intsup,
                                                   EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan, min(-slope_min_down,-slope_max_down),
                                                   max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                        else:
                            Span = OptPyl_Down_init_NoH(Line,Alts,Span,Htower, Hend,masse_li,masse_li2,masse_li3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo,
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,test_hfor,nbconfig)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = OptPyl_Down_NoH(Line2,Alts,Span*0,Htower,Hintsup,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,Csize,
                                                       angle_intsup,EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,min(-slope_min_down,-slope_max_down),
                                                       max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                    ind_max_Line = int(np.max(Span[:,15]))                    
                    if Span[0,0]==0 or np.sum(Span[:,2])<Lmin or Line[ind_max_Line,8]==0:
                        test=0
                        continue                    
                    nbintsup = np.sum(Span[:,0]>0)-1
                    ### Save Line carac
                    Line = Line[0:ind_max_Line+1]
                    Lline = Line[ind_max_Line,0]                    
                    if test_vp or test_vam:    
                        if RoadState==2:
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv = get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv,Vol_ha,Vol_AM)
                        else: 
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv2 = get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2,Vol_ha,Vol_AM)
                    else:
                        if RoadState==2:
                            Distance_moyenne,Surface,Rast_couv = get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv)
                        else:
                            Distance_moyenne,Surface,Rast_couv2 = get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2)
                    #pixel, direction
                    Tab[id_line,0],Tab[id_line,1] = pixel,az
                    #Xstart,Ystart,Zstart,Hcable_start
                    Tab[id_line,2],Tab[id_line,3],Tab[id_line,4],Tab[id_line,5]=Line[0,3],Line[0,4],Line[0,1],Htower
                    #Xend,Yend,Zend,Hcable_end
                    Tab[id_line,6],Tab[id_line,7],Tab[id_line,8],Tab[id_line,9] = Line[ind_max_Line,3],Line[ind_max_Line,4],Line[ind_max_Line,1],Span[nbintsup,14]
                    #Road existing or not,Ltot,Config
                    Tab[id_line,10],Tab[id_line,11],Tab[id_line,12] = int(RoadState),int(np.sum(Span[:,2])+0.5),config
                    #Surface foret Dmoy chariot
                    Tab[id_line,13],Tab[id_line,14]=Surface,Distance_moyenne
                    #Vtot IPC
                    if test_vp:
                        Tab[id_line,15]=Vtot
                    #VAM               
                    if test_vam:
                        Tab[id_line,16]=VAM*10
                    #Int sup info  
                    Tab[id_line,17]=nbintsup
                    for pyl in range(0,nbintsup):
                        Tab[id_line,18+5*pyl]=Line[int(Span[pyl,15]),3]#X
                        Tab[id_line,19+5*pyl]=Line[int(Span[pyl,15]),4]#Y
                        Tab[id_line,20+5*pyl]=Line[int(Span[pyl,15]),1]#Alts
                        Tab[id_line,21+5*pyl]=Span[pyl,14]#Hcable
                        Tab[id_line,22+5*pyl]=np.arctan(abs(Span[pyl,3]-Span[pyl+1,3]))*Span[pyl,10]+Fo#Press
                    id_line+=1
                    if id_line == 1000000:                        
                        np.save(Dir_temp+"Tab"+str(Tab_nb)+".npy",Tab[Tab[:,11]>0])
                        File_Tab.append(Dir_temp+"Tab"+str(Tab_nb)+".npy")
                        Tab_nb +=1
                        id_line=0
                        Tab = np.zeros((1000000,18+5*sup_max),dtype=np.int16)

    txt = QCoreApplication.translate("MainWindow", "    -Processing completed, start of results saving...")
    console_info("\n    - Saving of results")
   
    ### Save Forest,Vol_ha,VolAm,Pente
    np.save(Rspace_sel+"Forest.npy",Forest)
    if test_vp:
        np.save(Rspace_sel+"Vol_ha.npy",Vol_ha)
    if test_vam:
        np.save(Rspace_sel+"Vol_AM.npy",Vol_AM)
    np.save(Rspace_sel+"Pente.npy" ,Pente)
    np.save(Rspace_sel+"Lien_RF_c.npy",Lien_RF)
    ### Del useless    
    try:
        del Line2
    except:
        pass
    del rastLosup,rastTh,rastTv,Row_line,Col_line,D_line,Nbpix_line,CoordRoute,Aerian_obs,Lien_RF
    gc.collect()
    ### Save results
    Tab = Tab[Tab[:,11]>0]
    if Tab_nb>0:
        for files in File_Tab:
            Tabbis = np.load(files)
            Tab = np.concatenate((Tab,Tabbis))
    np.save(Rspace_sel+"Tab_all_lines.npy",Tab)    
    
    if testExist :        
        Rast_couv += 10*Rast_couv2
        Rast_couv[Rast_couv==11]=2
        Rast_couv[Rast_couv==1]=2
        Rast_couv[Rast_couv==10]=1
    
    if not test_vp:
        Vol_ha=np.zeros_like(MNT)    
    else:
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
    generate_info_cable_simu(Rspace_c,Tab,Rast_couv,Vol_ha,Csize,Forest,Pente,Pente_max_bucheron)
    
    ### Del useless   
    del Forest,Pente,Line,Alts,Span,MNT,Fin_ligne_forcee,Aspect,Falt
    try:
        del Vol_ha,Vol_AM,Rast_couv2 
    except:
        pass
    
    #Save Global res        
    header = QCoreApplication.translate("MainWindow",'ID_pixel Azimuth X_Start Y_Start Elevation_Start Hcable_Start X_End Y_End Elevation_End Hcable_End ',)
    header += QCoreApplication.translate("MainWindow",'Existing_road Cable_length Configuration ')
    header += QCoreApplication.translate("MainWindow",'Forest_area Carriage_average_distance Volume_total ATV NB_int_sup')
    for num in range(1, sup_max + 1):
        header += ' ' + QCoreApplication.translate("MainWindow",'Xcoord_intsup') + str(num) + ' ' + QCoreApplication.translate("MainWindow",'Ycoord_intsup') + str(num) + ' ' + QCoreApplication.translate("MainWindow",'Alt_intsup') + str(num)
        header += ' ' + QCoreApplication.translate("MainWindow",'Hcable_intsup') + str(num) + ' ' + QCoreApplication.translate("MainWindow",'Pression_intsup') + str(num)
    filename=Rspace_c+"Database_all_lines.gzip"
    shape_name = Rspace_c+"All_the_lines.shp"
    rast_name = Rspace_c+'Zone_accessible'
            
    
    ArrayToGtiff(Rast_couv,rast_name,Extent,nrows,ncols,road_network_proj,0,'UINT8')
    header+='\n'
    save_integer_ascii(filename,header,Tab)
    source_src=get_source_src(file_shp_Cable_dep) 
    Line_to_shapefile(Tab[0:2],Rspace_sel+"info_proj.shp",source_src,0)
    if Tab.shape[0]<1000000:         
        Line_to_shapefile(Tab,shape_name,source_src,prelevement)
    
    ##############################################################################################################################################
    ### 3. CREATE SIMULATION PARAMETER FILE
    ##############################################################################################################################################
    str_duree,str_fin,str_debut=heures(Hdebut)
    
    if Carriage_type == 1:
        carriage_name = QCoreApplication.translate("MainWindow",'self-propelled')
    else:
        carriage_name = QCoreApplication.translate("MainWindow",'Classic')
    if Cable_type < 3:
        cable_name = QCoreApplication.translate("MainWindow",'Cable mat')
    else:
        cable_name = QCoreApplication.translate("MainWindow",'Long/conventional cable')

    file_name = str(Rspace_c) + 'Parametre_simulation.txt'
    resume_texte = QCoreApplication.translate("MainWindow",'SYLVACCESS - CABLE\n\n\n')
    version = "1.0.0"
    date = "02/06/2024"
    resume_texte += QCoreApplication.translate("MainWindow","Plugin's version: ") + version + QCoreApplication.translate("MainWindow","from ") + date + "\n"
    resume_texte += QCoreApplication.translate("MainWindow",'Author: Sylvain DUPIRE. Irstea\n\n')
    resume_texte += QCoreApplication.translate("MainWindow",'Date and time when launching the script:                          ') + str_debut + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'Date and time at the end of the script execution                           ') + str_fin + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'Total execution time of the script:                                         ') + str_duree + '\n\n'
    resume_texte += QCoreApplication.translate("MainWindow",'PROPERTIES OF THE MATERIAL:\n')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Type of machine:                                                      ') + str(cable_name) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Height of mat or cable Forwarder at the depot place:    ') + str(Htower) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum number of intermediate support:                        ') + str(sup_max) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum length of the Forwarder cable:                                    ') + str(Lmax) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Minimum length of a line:                                        ') + str(Lmin) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Minimum length between two supports:                                ') + str(LminSpan) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Trolley type:                                                      ') + str(carriage_name) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Empty mass of the trolley:                                              ') + str(Pchar) + ' kg\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum mass of load:                                          ') + str(Load_max) + ' kg\n'
    if Carriage_type == 1:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Max slope of the Forwarder cable for uphill unloading:            ') + str(slope_Wliner_up) + ' %\n'
        resume_texte += QCoreApplication.translate("MainWindow",'   - Max slope of the Forwarder cable for downhill unloading:             ') + str(slope_Wliner_down) + ' %\n'
    else:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Min slope of the Forwarder cable for the trolley to climb down:  ') + str(slope_grav) + ' %\n'
    resume_texte += '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'PROPERTIES OF THE FORWARDER CABLE :\n')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Diameter of the Forwarder cable:                                            ') + str(d) + ' mm\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Line mass of the Forwarder cable:                                      ') + str(masse_li) + ' kg.m-1\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Young’s Module (Elasticity):                                         ') + str(E) + ' N.mm-2\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Breaking tension of the Forwarder cable                                   ') + str(rupt_res) + ' kgF\n\n'
    if Carriage_type != 1:
        resume_texte += QCoreApplication.translate("MainWindow",'TRACTOR AND RETURN CABLE PROPERTIES:\n')
        resume_texte += QCoreApplication.translate("MainWindow",'   - Line mass of the tractor cable:                                     ') + str(masse_li2) + ' kg.m-1\n'
        resume_texte += QCoreApplication.translate("MainWindow",'   - Line mass of the return cable:                                       ') + str(masse_li3) + ' kg.m-1\n'
        resume_texte += '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'MODELISATION PARAMETERS:\n')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Lateral distance of wood pitching:                                ') + str(Lhor_max) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Height of Forwarder cable at intermediate pylons:          ') + str(Hintsup) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Forwarder cable height at end of line:                             ') + str(Hend) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Minimum cable height at any point (load):                  ') + str(Hline_min) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum cable height at any point:                              ') + str(Hline_max) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum angle of the Forwarder cable at an intermediate pylon:   ') + str(Max_angle) + ' degres\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Security factor:                                                  ') + str(safe_fact) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Value of the friction angle:                                      ') + str(coeff_frot) + ' rad\n\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - DTM resolution:                                              ') + str(Csize) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Standing volume harvesting applied:                              ') + str(prelevement * 100) + ' %\n'
    try:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Projection:                                                           ') + str(proj.GetAttrValue("PROJCS", 0)) + '\n'
    except:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Projection:                                                           unknown\n')
    if Dir_Obs_cable == "":
        reponse = QCoreApplication.translate("MainWindow",'No')
    else:
        reponse = QCoreApplication.translate("MainWindow",'Yes')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Consideration of obstacle for the cable:                             ') + str(reponse) + '\n'
    if file_Vol_ha == "":
        reponse = QCoreApplication.translate("MainWindow",'No')
    else:
        reponse = QCoreApplication.translate("MainWindow",'Yes')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Information on the volume of wood provided as input:                  ') + str(reponse) + '\n'

    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()

    file_name = Rspace_sel + 'info_Lhormax.txt'
    fichier = open(file_name, "w")
    fichier.write(str(Lhor_max))
    fichier.close()

    console_info(QCoreApplication.translate("MainWindow",'\nAll possible lines have been tested.\n'))  
    ##############################################################################################################################################
    ### 4. SELECTION OF BEST LINE IF CHECKED
    ##############################################################################################################################################
    if test_cable_optimise:
        line_selection(Rspace_c,w_list,lim_list,0,file_shp_Foret,file_Vol_ha,file_Vol_AM,Lhor_max,prelevement,Pente_max_bucheron)


def prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize):
    rastLosup,rastTh,rastTv = Tabmesh(d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)
    np.save(Dir_temp+"rastLosup.npy",rastLosup)
    np.save(Dir_temp+"rastTh.npy",rastTh)
    np.save(Dir_temp+"rastTv.npy",rastTv)
    text  = "d    "+" "+str(round(d,2))+"\n"
    text += "E    "+" "+str(round(E,2))+"\n"
    text += "Tmax "+" "+str(round(Tmax,2))+"\n"
    text += "Lmax "+" "+str(round(Lmax,2))+"\n"
    text += "Fo   "+" "+str(round(Fo,2))+"\n"
    text += "Csize"+" "+str(round(Csize,2))+"\n"
    text += "masse_li   "+" "+str(round(masse_li,2))+"\n"
    text += "masse_li2   "+" "+str(round(masse_li2,2))+"\n"
    text += "masse_li3   "+" "+str(round(masse_li3,2))+"\n"
    f = open(Dir_temp+'info_config.txt',"w")
    f.write(text)
    f.close()
    return rastLosup,rastTh,rastTv


def check_tabconv(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize):
    try:
        _,v1=read_info(Dir_temp+"info_config.txt")
        if np.all(np.array([round(d,2),round(E,2),round(Tmax,2),round(Lmax,2),round(Fo,2),round(Csize,2),round(masse_li,2),round(masse_li2,2),round(masse_li3,2)])==v1):
            rastLosup = np.load(Dir_temp+"rastLosup.npy")
            rastTh = np.load(Dir_temp+"rastTh.npy")
            rastTv = np.load(Dir_temp+"rastTv.npy")
        else:
            rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)
    except:
        rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)        
    return rastLosup,rastTh,rastTv


def check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret):
    indmax = 0
    npix = Line.shape[0]
    test = 1
    i=0
    Dsansforet=0.
    for i in range(0,npix): 
        if Line[i,5]<0:break
        if Line[i,5]>=ncols:break
        if Line[i,6]<0:break
        if Line[i,6]>=nrows:break
        if Line[i,7]==1:break
        if np.sqrt(Line[i,0]*Line[i,0]+(Line[i,1]-Line[0,1])*(Line[i,1]-Line[0,1]))>Lmax:break        
        if (Line[i,8]+Line[i,9])>0:                 
            if Line[i,2]==1:
                indmax = i 
                Dsansforet=0
            else:
                if i>0: Dsansforet+=Line[i,0]-Line[i-1,0]
                if Dsansforet>=Lsans_foret:break
        else:        
            break
    Lline = Line[indmax,0]
    if Lline <= Lmin:
        test=0
    return test,indmax+1,Lline


def get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
              Fo,Tmax,masse_li,masse_li2,masse_li3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope):
                  
    npix = Nbpix_line[az]
    npix = get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,11),dtype=np.float32)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        ### Check pente en devers
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1 
        if test_hfor:
            Line[:,10]=np.round(np.minimum(np.maximum(-7.76961+0.71858*Hfor[inds],0),26))
        else:
            Line[:,10]=Hintsup
        ####Raccourci pour ne pas depasser Hline_max
        indmax=Line.shape[0]-1
        for i in range(indmax,1,-1):  
            test=1
            D = Line[i,0]
            H = abs(Line[0,1]+Htower-(Line[i,1]+Hend))    
            if Line[0,1]+Htower>=Line[i,1]+Hend:
                Xup,Zup =0,Line[0,1]+Htower
                fact = 1. 
            else:    
                Xup,Zup = Line[i,0],Line[i,1]+Hend
                fact = -1.             
            L=np.sqrt(H*H+D*D)
            F = 0.5*(0.5*L*masse_li2+0.5*L*masse_li3)*9.80665 + Fo  
            fleche = 1.1*(F*L/(4*Tmax)+masse_li*9.80665*L*L/(8*Tmax))
            for j in range(1,i-1):
                droite = -fact*H/D*(Line[j,0]-Xup)+Zup-Line[j,1]
                if droite-fleche > Hline_max:
                    test=0
                    break
            if test:
                break
        Line=Line[0:i+1]
        test,indmax,Lline=check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret,Lslope,PropSlope)
        Lline = 2 # A modifier    
        return test,Lline,Line[0:indmax, [0, 1, 2, 3, 4, 5, 6,10,9]]
    else:
        return 0,0,0 


def return_profile(Line):
    Line2 = np.zeros_like(Line)
    indmax = Line.shape[0]-1
    Dmax =Line[indmax,0]
    for i,j in enumerate(range(indmax,-1,-1)):
        Line2[i]=Line[j]
        Line2[i,0]=Dmax-Line[j,0]
    return Line2


def azimuth(X0,Y0,X1,Y1):
    dX=abs(X0-X1)
    dY=abs(Y0-Y1)
    #cas 1:cadran en haut a droite
    if (X1>X0) and (Y1>Y0):
        az=np.degrees(np.arctan(dX*1.0/dY))
    #cas 2:cadran en bas a droite
    elif (X1>X0) and (Y1<Y0):
        az=180-np.degrees(np.arctan(dX*1.0/dY))
    #cas 3:cadran en haut a gauche
    elif (X1<X0) and (Y1>Y0):
        az=360-np.degrees(np.arctan(dX*1.0/dY)) 
    #cas 4:cadran en bas a gauche
    elif (X1<X0) and (Y1<Y0):
        az=180+np.degrees(np.arctan(dX*1.0/dY)) 
    #cas 5:horizontal gauche
    elif (dY==0) and (X1>X0):
        az=90
    #cas 6:horizontal droite
    elif (dY==0) and (X1<X0):
        az=90*3
    #cas 7:vertical haut
    elif (Y1>=Y0) and (dX==0):
        az=0
    #cas 8:vertical bas
    elif (Y1<Y0) and (dX==0):
        az=180
    return az


def pt_emprise(X0,Y0,X1,Y1,Lhor_max):
    az=azimuth(X0,Y0,X1,Y1)
    #deb + 90
    X = [X0+np.sin(np.radians(az+90))*Lhor_max]
    Y = [Y0+np.cos(np.radians(az+90))*Lhor_max]
    #deb - 90
    X.append(X0+np.sin(np.radians(az-90))*Lhor_max)
    Y.append(Y0+np.cos(np.radians(az-90))*Lhor_max)
    #fin - 90
    X.append(X1+np.sin(np.radians(az-90))*Lhor_max)
    Y.append(Y1+np.cos(np.radians(az-90))*Lhor_max)
    #fin + 90
    X.append(X1+np.sin(np.radians(az+90))*Lhor_max)
    Y.append(Y1+np.cos(np.radians(az+90))*Lhor_max)
    return [X,Y] 


def point_line_to_line_ext(X0,Y0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize):
    ### Create mask_array
    X,Y = pt_emprise(X0,Y0,X1,Y1,Lhor_max)
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbPolygon)
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    # create polygon object:
    myRing = ogr.Geometry(ogr.wkbLinearRing)
    for i in range(0,len(X)):
        myRing.AddPoint(X[i],Y[i])
    myRing.AddPoint(X[0],Y[0])#close ring
    poly = ogr.Geometry(type=ogr.wkbPolygon)
    poly.AddGeometry(myRing)
    feature = ogr.Feature( layer.GetLayerDefn() )
    feature.SetGeometry(poly)
    feature.SetFID(1)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return mask_arr


def get_car_dist(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        _ ,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
    return mat


def get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        distance,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
        mat[i,3]=distance
    return mat


def ligh_line(mat,Dmin):
    mat[0,3]=1
    for i in range(1,mat.shape[0]):
        if (mat[i,2]-mat[i-1,2])>Dmin:
            mat[i,3]=1
    return mat[mat[:,3]>0]


def create_buffer(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float32)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float32)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = np.sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+1))
        mat[:,:-1] = inds
        mat = get_car_dist(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],Dir_list


def create_buffer2(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float32)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float32)*-1
    D_lat = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float32)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = np.sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+2))
        mat[:,:-2] = inds
        mat= get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))               
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        D_lat[az,0:nb_pix]=mat[ind,3]*Csize
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],D_lat[:,0:Nbpix_ext],Dir_list


def Line_to_shapefile(Tab,Cable_line_Path,source_src,prelevement,language):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    fieldvol = 'Volume_'+str(int(100*prelevement))
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xstart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ystart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Yend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Id_route', ogr.OFTInteger)
    layer.CreateField(new_field)
    if language=='FR':
        new_field = ogr.FieldDefn('Desserte', ogr.OFTString) 
        
    else:
        new_field = ogr.FieldDefn('Road', ogr.OFTString)                              
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AzimuthDeg', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Long', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Config', ogr.OFTString)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('NbIntSup', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Surface', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn(fieldvol, ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('IPC', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Dmoy', ogr.OFTInteger)
    layer.CreateField(new_field)
    cneg = "Skidding downhill"
    cpos = "Skidding uphill"
    proj = "In project"
    exis = "Existing"

    
    for ind,S in enumerate(Tab):
        line = ogr.Geometry(ogr.wkbLineString)
        line.AddPoint(float(S[2]),float(S[3]))
        line.AddPoint(float(S[6]),float(S[7]))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('IdLine',ind+1)
        feature.SetField('Xstart',float(S[2]))
        feature.SetField('Ystart',float(S[3]))
        feature.SetField('Xend',float(S[6]))
        feature.SetField('Yend',float(S[7]))
        if int(S[10])==2: 
            feature.SetField('Desserte',exis)
        else:
            feature.SetField('Desserte',proj)
        feature.SetField('Id_route',int(S[0]))
        feature.SetField('AzimuthDeg',int(S[1]))
        feature.SetField('Long',int(S[11]))
        if int(S[12])>0:
            feature.SetField('Config',cpos)
        else:
            feature.SetField('Config',cneg)
        feature.SetField('NbIntSup',int(S[17]))
        feature.SetField('Surface',S[13]/10000.)
        feature.SetField('Dmoy',int(S[14]))
        feature.SetField(fieldvol,int(S[15]*prelevement))
        feature.SetField('IPC',S[15]*prelevement/float(S[11]))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
    target_ds.Destroy()


def Pylone_in_shapefile(Tab,Cable_line_Path,source_src):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]    
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xpyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ypyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Altitude', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Hcable', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pression', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pyl_pos', ogr.OFTInteger)
    layer.CreateField(new_field)
    idi = 0
    for ind,S in enumerate(Tab):
        nb=1
        for pyl in range(int(S[17])):  
            point = ogr.Geometry(ogr.wkbPoint)
            point.SetPoint(0, float(S[18+5*pyl]),float(S[19+5*pyl]))         
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(point)
            feature.SetFID(idi)
            feature.SetField('IdLine',ind+1)
            feature.SetField('Xpyl',float(S[18+5*pyl]))
            feature.SetField('Ypyl',float(S[19+5*pyl]))
            feature.SetField('Altitude',float(S[20+5*pyl]))
            feature.SetField('Hcable',float(S[21+5*pyl]))
            feature.SetField('Pression',float(S[22+5*pyl]))
            feature.SetField('Pyl_pos',int(nb)             )    
            layer.CreateFeature(feature)
            point.Destroy()
            feature.Destroy()
            idi+=1
            nb+=1
    target_ds.Destroy()


def create_coord_pixel_center_raster(values,nline,ncol,Csize,Dir_temp):
    Xcoord = np.zeros((ncol),dtype=np.float32)
    Ycoord = np.zeros((nline),dtype=np.float32)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    np.save(Dir_temp+'TableX.npy',Xcoord)
    np.save(Dir_temp+'TableY.npy',Ycoord)
    return Xcoord,Ycoord


# Create raster of obstacles from directory containing shapefiles 
def prepa_obstacle_cable(Obstacles_directory,file_MNT,Dir_temp):
    ### Creation d'un repertoire temporaire       
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize= values[4]
    MNT = read_raster(file_MNT)
    MNT[MNT==values[5]]=-9999
    Pente = pente(np.float_(MNT),Csize,-9999)     
    if Obstacles_directory!="":
        liste_file = os.listdir(Obstacles_directory)
        liste_obs = [] 
        for files in liste_file:
            if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
        if len(liste_obs)>0:
            Obstacles_cable = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)
    else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)    
    Obstacles_cable[MNT==-9999]=1
    values[5]=-9999
    np.save(Dir_temp+'Obstacles_cables.npy',np.int8(Obstacles_cable))
    gc.collect()  
    return Pente


def get_cable_configs(Rspace,Cable_type,Carriage_type,slope_Wliner_up,slope_Wliner_down,slope_grav,Skid_direction):
    #Get folder
    dirs = [d for d in os.listdir(Rspace) if os.path.isdir(os.path.join(Rspace, d))]
    list_dir = []
    
    for dire in dirs:
        if dire[:5]=='Cable':
            list_dir.append(dire)

    optnum = len(list_dir)+1
    Rspace_c=Rspace+'Cable_'+str(optnum)        
    filename = Rspace_c+"/"
    filename += str(Cable_type)
    filename += "_"+str(Carriage_type)
    
    if Skid_direction ==0:
        filename += "_uphill&downhill"
        slope_min_up = -np.arctan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = np.arctan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1        
    
    elif Skid_direction ==1:
        filename += "_uphill"
        slope_min_up = -np.arctan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = 0
        slope_min_down = 0
    
    else:
        filename += "_downhill"
        slope_min_up = 0
        slope_max_up = 0
        slope_max_down = np.arctan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1 
    
    if Cable_type == "Long cable":
        if Skid_direction ==0:
            filename += "_uphill&downhill"
            slope_min_up = -1.4
            slope_max_up = -np.arctan(slope_grav*0.01)
            slope_max_down = 1.4
            slope_min_down = np.arctan(slope_grav*0.01) 
   
        elif Skid_direction ==1:
            filename += "_uphill"
            slope_min_up = -1.4
            slope_max_up = -np.arctan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0
 
        else:
            filename += "_downhill"
            slope_min_up = 0
            slope_max_up = 0
            slope_max_down = 1.4
            slope_min_down = np.arctan(slope_grav*0.01)             
    else: 
        
        if Skid_direction ==0:
            filename+= "_uphill&downhill"
            slope_min_up = -1.4
            slope_max_up = 0.1
            slope_min_down = -0.1
            slope_max_down = 1.4
        
        elif Skid_direction ==1:
            filename += "_uphill"
            slope_min_up = -1.4
            slope_max_up = -np.arctan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0 
        
        else:
            filename += "_downhill"
            slope_min_up = 0
            slope_max_up = 0
            slope_min_down = -0.1
            slope_max_down = 1.4             
    
    filename+=".txt"
    
    return Rspace_c,filename,slope_min_up,slope_max_up,slope_min_down,slope_max_down


def gen_sel_table(w_list,lim_list,sup_max):
    col =     np.array([13       ,17     ,12         ,11    ,15    ,18+5*sup_max,16          ,14          ,18+5*sup_max+1])
    sens =    np.array([1        ,-1     ,0          ,1     ,1     ,1           ,1           ,-1          ,-1])
    #sens : 1:maximize,-1 minimize,0 NA
    report =  np.array([10000.   ,1.     ,1.         ,1.    ,1.    ,100.        ,10.         ,1.          ,1.])
    name = np.array(['Surface','NBsup','SensDeb'  ,'Long','Vtot','IPC'       ,'VAM'       ,'Dchar'     ,'Cout'])
    #quant =   np.array[[99,      , 100   , 100       ,99    ,99    ,99          ,99          ,100          ,100]]
    Tab_crit=np.zeros((9,4))
    Tab_crit[:,0]=w_list
    Tab_crit[:,1]=lim_list*report    
    Tab_crit[:,2]=col
    Tab_crit[:,3]=sens
    Name = ""  
    for i,crit in enumerate(Tab_crit):
        if crit[0]>0:
            Name+= '_'+str(name[i])+'('+str(round(crit[0],1))+')'
        
    return Tab_crit[Tab_crit[:,0]>0],Name


def create_best_table(Tab2,w_list,lim_list,sup_max): 
    Tab_crit,name=gen_sel_table(w_list,lim_list,sup_max)
    #Trie en fonction des critere avec un poids et de la limite
    for crit in Tab_crit:
        if crit[3]>0:
            tp = (Tab2[:,int(crit[2])]-crit[1])>=0
        elif crit[3]<0:
            tp = (Tab2[:,int(crit[2])]-crit[1])<=0
        else:
            continue
        Tab2 = Tab2[tp]
        
    #identifier si le sens de debardage a ete choisi dans les criteres   
    liste =range(Tab_crit.shape[0])
    idsensdeb=np.argwhere(Tab_crit[:,2]==12)
    if idsensdeb.shape[0]>0:
        idsensdeb=idsensdeb[0,0]
        liste = [x for x in liste if x != idsensdeb]
    else:
        idsensdeb=-1
    #Transform variable to stick in the range [0-1+]
    nbcol = len(liste)+2    
    Tab = np.zeros((Tab2.shape[0],nbcol))    
    col=1   
    for crit in Tab_crit[liste]:
        if crit[3] < 1 : #all values contribute to transformation
            Tab[:,col]= (1-1.0*Tab2[:,int(crit[2])]/np.max(Tab2[:,int(crit[2])]))*crit[0]
        else:
            Tab[:,col]= (1.0*Tab2[:,int(crit[2])]/np.percentile(Tab2[:,int(crit[2])],98))*crit[0]
        col+=1
    
    for i in range(Tab2.shape[0]):
        Tab[i,0]=i                      #first col is idline of Tab2
        Tab[i,col]=np.sum(Tab[i,1:col]) #last col is the total weight
    #classify
    ordre = np.zeros((Tab2.shape[0],),dtype=np.int16)   
    if idsensdeb>0:
        #first the best direction
        tp = Tab2[:,12]==Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[tp][ind][0])
        ligne=i+1
        #then the othe direction
        tp = Tab2[:,12]==-Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i+ligne]=int(Tab[tp][ind][0])
    else:
        inds = np.lexsort((Tab[:,0],-Tab[:,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[ind,0])
    return Tab2[ordre],name


def select_best_lines(w_list,lim_list,Tab2,nrows,ncols,Csize,Row_ext,Col_ext,D_ext,D_lat,Lhor_max,sup_max):        
    # Reorder Tab to fit with criteria
    Tabbis,name=create_best_table(Tab2,w_list,lim_list,sup_max)
    nb_line,nb_cols = Tabbis.shape
    Rast_couv=np.zeros((nrows,ncols),dtype=np.int8)
    vals = range(0,nb_line)
    ### Parameter to validate a line
    recouv = min(0.6*Lhor_max,Lhor_max-Csize) #distance from the axis of the line where crossing is not allowed
    # Select best lines
    vals2 = []
    for id_tab in vals:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],np.sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        test_free,Rast_couv=Check_line2(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,D_lat,Rast_couv,recouv,0)
        if test_free:
            vals2.append(id_tab)
    # Check taht line contribute to total impacted surface
    Tab_result = np.zeros((len(vals2),2),dtype=np.int16)
    id_line = 0    
    for id_tab in vals2:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],np.sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        prop = get_prop(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Rast_couv)  
        Tab_result[id_line]=id_tab,prop*1000
        id_line+=1
    Tab_result=Tab_result[np.lexsort((Tab_result[:,0],Tab_result[:,1]))]  
    # Remove lines that does not contribute significantly to impacted surface
    nb_line = Tab_result.shape[0]
    Tab_result2 = np.zeros((nb_line,nb_cols-2),dtype=np.int16)
    id_line = 0    
    for id_tab in Tab_result[:,0]:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],np.sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2) 
        test_free,Rast_couv=Check_line3(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Rast_couv,0.6)         
        if test_free:
            Tab_result2[id_line]=Tabbis[id_tab,0:-2]
            id_line+=1    
    Tab_result2=Tab_result2[Tab_result2[:,11]>0]
    return Rast_couv,Tab_result2,name


def return_crit_text(w_list,lim_list,):    
    name = [QCoreApplication.translate("MainWindow","Forest area impacted [ha] (maximize)                 Minimum: "),
            QCoreApplication.translate("MainWindow","Number of intermediate supports (minimize)           Maximum: "),
            QCoreApplication.translate("MainWindow","Favour "),
            QCoreApplication.translate("MainWindow","Line length [m] (maximize)                           Minimum: "),
            QCoreApplication.translate("MainWindow","Total volume per line [m3] (maximize)                Minimum: "),
            QCoreApplication.translate("MainWindow","Volume per meter of line  [m3/ml] (maximize)         Minimum: "),
            QCoreApplication.translate("MainWindow","Average tree volume [m3] (maximize)                  Minimum: "),
            QCoreApplication.translate("MainWindow","Carriage average distance [m] (minimize)             Maximum: "),
            QCoreApplication.translate("MainWindow","Yarding cost [€/ml] (minimize)                       Maximum: ")]
    units = ["ha", "", "", "m", "m3", "m3/ml", "m3", "m", "€/m3"]
    namelist = name
    pname = QCoreApplication.translate("MainWindow","(Weight: ")           
    Tab = np.empty((np.sum(np.array(w_list)>0),2),dtype='|U73')
    j=-1
    for i,w in enumerate(w_list):
        if w!=0:
            j+=1
            if i!=2:
                if round(lim_list[i],0)==lim_list[i]:
                    lim=int(lim_list[i])
                else:
                    lim=round(lim_list[i],1)
                Tab[j]=namelist[i],str(lim)+" "+units[i]+" "+pname+str(w)+')' 
            else:
                if lim_list[i]==-1:
                    Tab[j]= name[i]+"l\'downhill",pname+str(w)+')' 
                elif lim_list[i]==1:
                    Tab[j]= name[i]+"l\'downhill",pname+str(w)+')'  
                else:
                    continue                    
    return Tab


def generate_info_ligne(Dir_result, w_list, lim_list, Tab, Rast_couv, Vol_ha, Vol_AM, Csize, prelevement, Lhor_max):
    filename = Dir_result + "Summary_selection.txt"
    pix_area = Csize * Csize / 10000.
    Proj = np.copy(Rast_couv)
    Proj[Rast_couv == 2] = 0
    Rast_couv[Rast_couv == 2] = 1
    Surface = round(np.sum(Rast_couv) * pix_area, 1)
    Surface_proj = round(np.sum(Proj) * pix_area, 1)
    if Surface_proj > 0:
        testProj = 1
    else:
        testProj = 0
    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:, 12] > 0))
    try:
        nb_moy_pyl = round(np.sum(Tab[:, 17]) / nb_ligne, 1)
        long_moy_ligne = int(np.sum(Tab[:, 11]) / nb_ligne)
    except:
        console_info("No cable line selected")
    Vol_ha[np.isnan(Vol_ha)] = 0
    Vol_AM[np.isnan(Vol_AM)] = 0
    tp = Vol_ha > 0
    if np.sum(tp) > 0:
        vtot = np.sum(Rast_couv[tp] * Vol_ha[tp]) * pix_area * prelevement
    else:
        vtot = 0
    tp = Vol_AM > 0
    if np.sum(tp) > 0:
        vam = round(np.mean(Rast_couv[tp] * Vol_AM[tp]), 1)
    else:
        vam = 0
    if np.sum(Tab[:, 11]) != 0:
        ipc_moy = round(float(vtot) / np.sum(Tab[:, 11]), 2)
    else:
        console_info("No cable line selected")
    vtot = int(vtot)
    lim_list[4] = lim_list[4] * prelevement

    Table = np.empty((19 + np.sum(np.array(w_list) > 0), 2 + testProj), dtype='|U73')

    Table[1, 0] = QCoreApplication.translate("MainWindow","SUMMARY OF THE LINE SELECTION")
    Table[3, 0] = "                                                         "
    Table[3, 1] = QCoreApplication.translate("MainWindow","From all cable starts\t\t")
    if testProj:
        Table[3, 2] = QCoreApplication.translate("MainWindow","Only from projects")
    Table[4, 0] = QCoreApplication.translate("MainWindow","   - Total forest area impacted [ha]:                    ")
    Table[5, 0] = QCoreApplication.translate("MainWindow","   - Total number of lines:                              ")
    Table[6, 0] = QCoreApplication.translate("MainWindow","         + With uphill yarding:                          ")
    Table[7, 0] = QCoreApplication.translate("MainWindow","         + With downhill yarding:                        ")
    Table[8, 0] = QCoreApplication.translate("MainWindow","   - Average number of intermediate support per line:    ")
    Table[9, 0] = QCoreApplication.translate("MainWindow","   - Average length of the line [m]:                     ")
    Table[10, 0] = QCoreApplication.translate("MainWindow","   - Total harvested volume (estimate) [m3]:             ")
    Table[11, 0] = QCoreApplication.translate("MainWindow","   - Average volume per meter of line (estimate) [m3/m]: ")
    Table[12, 0] = QCoreApplication.translate("MainWindow","   - Average tree volume (estimate) [m3]                 ")
    Table[18, 0] = QCoreApplication.translate("MainWindow","Criteria taken into account for the selection:           ")
    Table[17, 0] = QCoreApplication.translate("MainWindow","Lateral yarding distance                             ")
    Table[18, 0] = QCoreApplication.translate("MainWindow","Proportion of stand volume removed                   ")

    Table[4, 1] = str(Surface)
    Table[5, 1] = str(nb_ligne)
    Table[6, 1] = str(nb_ligne_amont)
    Table[7, 1] = str(nb_ligne - nb_ligne_amont)
    Table[8, 1] = str(nb_moy_pyl)
    Table[9, 1] = str(long_moy_ligne)
    Table[10, 1] = str(vtot)
    Table[11, 1] = str(ipc_moy)
    Table[12, 1] = str(vam)
    Table[17, 1] = str(int(Lhor_max)) + " m"
    Table[18, 1] = str(int(prelevement * 100)) + " %"

    Tabcrit = return_crit_text(w_list, lim_list)

    for i, crit in enumerate(Tabcrit):
        Table[19 + i, 0] = crit[0]
        Table[19 + i, 1] = crit[1]

    if testProj:
        Tab = Tab[Tab[:, 10] == 1]
        Rast_couv = Proj
        nb_ligne = Tab.shape[0]
        nb_ligne_amont = int(np.sum(Tab[:, 12] > 0))
        try:
            nb_moy_pyl = round(np.sum(Tab[:, 17]) / nb_ligne, 1)
            long_moy_ligne = int(np.sum(Tab[:, 11]) / nb_ligne)
        except:
            console_info("No cable line selected")
        tp = Vol_ha > 0
        if np.sum(tp) > 0:
            vtot = np.sum(Rast_couv[tp] * Vol_ha[tp]) * pix_area * prelevement
        else:
            vtot = 0
        tp = Vol_AM > 0
        if np.sum(tp) > 0:
            vam = round(np.mean(Rast_couv[tp] * Vol_AM[tp]), 1)
        else:
            vam = 0
        if np.sum(Tab[:, 11]) != 0:
            ipc_moy = round(float(vtot) / np.sum(Tab[:, 11]), 2)
        else:
            console_info("No cable line selected")
        vtot = int(vtot)

        Table[4, 2] = "\t\t\t\t" + str(Surface_proj)
        Table[5, 2] = "\t\t\t\t" + str(nb_ligne)
        Table[6, 2] = "\t\t\t\t" + str(nb_ligne_amont)
        Table[7, 2] = "\t\t\t\t" + str(nb_ligne - nb_ligne_amont)
        Table[8, 2] = "\t\t\t\t" + str(nb_moy_pyl)
        Table[9, 2] = "\t\t\t\t" + str(long_moy_ligne)
        Table[10, 2] = "\t\t\t\t" + str(vtot)
        Table[11, 2] = "\t\t\t\t" + str(ipc_moy)
        Table[12, 2] = "\t\t\t\t" + str(vam)

    np.savetxt(filename, Table, fmt='%s', delimiter='')


def generate_info_cable_simu(Dir_result, Tab, Rast_couv, Vol_ha, Csize, Forest, Pente, Pente_max_bucheron):
    filename = Dir_result + "Summary_results_sylvaccess_cable.txt"
    Pente_max = focal_stat_max(np.float_(Pente), -9999, 1)
    Manual_harvesting = np.int8((Pente_max <= Pente_max_bucheron))
    del Pente_max
    gc.collect()
    pix_area = Csize * Csize / 10000.
    Rast_couv[Forest == 0] = 0
    Surface_exis = round(np.sum(Rast_couv == 2) * pix_area, 1)
    Surface_proj = round(np.sum(Rast_couv == 1) * pix_area, 1)
    Surface_foret = round(np.sum(Forest == 1) * pix_area, 1)
    Surface_nonbuch = round(np.sum((Forest == 1) * (Manual_harvesting == 0)) * pix_area, 1)

    Vol_ha[np.isnan(Vol_ha)] = 0
    Vol_ha[Forest == 0] = 0
    tp = Vol_ha > 0
    if np.sum(tp) > 0:
        tp2 = (tp * (Rast_couv == 2)) > 0
        vtot_exis = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
        tp2 = (tp * (Rast_couv == 1)) > 0
        vtot_proj = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
        tp2 = (tp * (Forest == 1)) > 0
        vtot_forest = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
        tp2 = (tp * (Forest == 1) * (Pente > Pente_max_bucheron)) > 0
        vtot_nonbuch = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
    else:
        vtot_exis = 0
        vtot_proj = 0
        vtot_forest = 0
        vtot_nonbuch = 0

    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:, 12] > 0))
    nb_moy_pyl = round(np.sum(Tab[:, 17]) / nb_ligne, 1)
    long_moy_ligne = int(np.sum(Tab[:, 11]) / nb_ligne)

    Table = np.empty((17, 5), dtype='|U39')
    Table[0] = np.array(["", QCoreApplication.translate("MainWindow","Surface area (ha)"), QCoreApplication.translate("MainWindow","Surface (%)"), QCoreApplication.translate("MainWindow","Volume (m3)"), QCoreApplication.translate("MainWindow","Volume (%)")])
    Table[1, 0] = QCoreApplication.translate("MainWindow","From existing cable starts")
    Table[2, 0] = QCoreApplication.translate("MainWindow","From potential cable start")
    Table[4, 0] = QCoreApplication.translate("MainWindow","Total accessible forest")
    Table[5, 0] = QCoreApplication.translate("MainWindow","Total unaccessible forest")
    Table[6, 0] = QCoreApplication.translate("MainWindow","    including impossible manual felling")
    Table[8, 0] = QCoreApplication.translate("MainWindow","Total forest area")
    Table[11, 0] = QCoreApplication.translate("MainWindow","Total number of lines")
    Table[12, 0] = QCoreApplication.translate("MainWindow","    + With uphill yarding")
    Table[13, 0] = QCoreApplication.translate("MainWindow","    + With downhill yarding")
    Table[15, 0] = QCoreApplication.translate("MainWindow","Average length of the line (m)")
    Table[16, 0] = QCoreApplication.translate("MainWindow","Average number of intermediate support")

    if vtot_forest > 0:
        Table[1, 1:] = np.array([str(Surface_exis), str(int(Surface_exis / Surface_foret * 100 + 0.5)),
                                 str(vtot_exis), str(int(vtot_exis / vtot_forest * 100 + 0.5))])
        Table[2, 1:] = np.array([str(Surface_proj), str(int(Surface_proj / Surface_foret * 100 + 0.5)),
                                 str(vtot_proj), str(int(vtot_proj / vtot_forest * 100 + 0.5))])

        Table[4, 1:] = np.array([str(Surface_exis + Surface_proj), str(int((Surface_proj + Surface_exis) / Surface_foret * 100 + 0.5)),
                                 str(vtot_proj + vtot_exis), str(int((vtot_exis + vtot_proj) / vtot_forest * 100 + 0.5))])
        Table[5, 1:] = np.array([str(round(Surface_foret - (Surface_exis + Surface_proj), 1)),
                                 str(int((Surface_foret - (Surface_proj + Surface_exis)) / Surface_foret * 100 + 0.5)),
                                 str(vtot_forest - (vtot_proj + vtot_exis)),
                                 str(int((vtot_forest - (vtot_exis + vtot_proj)) / vtot_forest * 100 + 0.5))])
        Table[6, 1:] = np.array([str(Surface_nonbuch), str(int(Surface_nonbuch / Surface_foret * 100 + 0.5)),
                                 str(vtot_nonbuch), str(int(vtot_nonbuch / vtot_forest * 100 + 0.5))])
    else:
        Table[1, 1:] = np.array([str(Surface_exis), str(int(Surface_exis / Surface_foret * 100 + 0.5)), '0', '0'])
        Table[2, 1:] = np.array([str(Surface_proj), str(int(Surface_proj / Surface_foret * 100 + 0.5)), '0', '0'])

        Table[4, 1:] = np.array([str(Surface_exis + Surface_proj),
                                 str(int((Surface_proj + Surface_exis) / Surface_foret * 100 + 0.5)), '0', '0'])
        Table[5, 1:] = np.array([str(round(Surface_foret - (Surface_exis + Surface_proj), 1)),
                                 str(int((Surface_foret - (Surface_proj + Surface_exis)) / Surface_foret * 100 + 0.5)),
                                 '0', '0'])
        Table[6, 1:] = np.array([str(Surface_nonbuch), str(int(Surface_nonbuch / Surface_foret * 100 + 0.5)), '0', '0'])

    Table[8, 1:] = np.array([str(Surface_foret), "", str(vtot_forest), ""])

    Table[11, 1] = str(nb_ligne)
    Table[12, 1] = str(nb_ligne_amont)
    Table[13, 1] = str(nb_ligne - nb_ligne_amont)
    Table[15, 1] = str(long_moy_ligne)
    Table[16, 1] = str(nb_moy_pyl)

    np.savetxt(filename, Table, fmt='%s', delimiter=';')


def calculate_azimut(x1,y1,x2,y2):
    DX = x2-x1
    DY = y2-y1
    Deuc = np.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = np.degrees(np.arccos(DY/Deuc))
    Angle *=Fact
    return Angle%360   


def create_rast_couv(Tab_result,Dir_result,source_src,Extent,Csize,Lhor_max):
    drv = ogr.GetDriverByName("GBKG")    
    layer_name = "Extent"
    dst_ds = drv.CreateDataSource( Dir_result+layer_name+".gbkg" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('EXIST', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    layerDefinition = dst_layer.GetLayerDefn()  
    for idi,line in enumerate(Tab_result):
        Xstart,Ystart,Xend,Yend = line[2],line[3],line[6],line[7]
        az = calculate_azimut(Xstart,Ystart,Xend,Yend)
        conv = np.radians(90)
        ring = ogr.Geometry(ogr.wkbLinearRing)
        ring.AddPoint(Xstart+Lhor_max*np.cos(az-conv), Ystart+Lhor_max*np.sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*np.cos(az-conv), Yend+Lhor_max*np.sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*np.cos(az+conv), Yend+Lhor_max*np.sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*np.cos(az+conv), Ystart+Lhor_max*np.sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*np.cos(az-conv), Ystart+Lhor_max*np.sin(az-conv))
        poly = ogr.Geometry(ogr.wkbPolygon)
        poly.AddGeometry(ring)
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(poly)
        feature.SetFID(idi)        
        feature.SetField('EXIST',int(line[10]))
        dst_layer.CreateFeature(feature)
        ring.Destroy()
        poly.Destroy()
        feature.Destroy()
    dst_ds.Destroy()
    Rast_couv = np.int8(shapefile_to_np_array(Dir_result+layer_name+".shp",Extent,Csize,"EXIST","EXIST",'ASC') )
    for extension in [".shp",".prj",".shx",".dbf"]:
        os.remove(Dir_result+layer_name+extension)
    return Rast_couv


def prepa_data_cable(Wspace, file_MNT, file_shp_Foret, file_shp_Cable_Dep, Dir_Obs_cable):
    console_info(QCoreApplication.translate("MainWindow","Pre-processing of the inputs for cable model\n"))
    ### Make directory for temporary files
    Dir_temp = Wspace + "Temp/"
    try:
        os.mkdir(Dir_temp)
    except:
        pass
    ###########################################################################
    ### __         __ __   __         __ __               __   __
    ###|__|.-----.|__|  |_|__|.---.-.|  |__|.-----.---.-.|  |_|__|.-----.-----.
    ###|  ||     ||  |   _|  ||  _  ||  |  ||__ --|  _  ||   _|  ||  _  |     |
    ###|__||__|__||__|____|__||___._||__|__||_____|___._||____|__||_____|__|__|
    ###
    MNT, Extent, Csize, _ = load_float_raster(file_MNT, Dir_temp)
    np.save(Dir_temp + "MNT", MNT)

    #############################################################################################################
    ###        __                       ___ __ __             __                                __
    ###.-----.|  |--.---.-.-----.-----.'  _|__|  |.-----.    |  |_.-----.    .----.---.-.-----.|  |_.-----.----.
    ###|__ --||     |  _  |  _  |  -__|   _|  |  ||  -__|    |   _|  _  |    |   _|  _  |__ --||   _|  -__|   _|
    ###|_____||__|__|___._|   __|_____|__| |__|__||_____|    |____|_____|    |__| |___._|_____||____|_____|__|
    ###                   |__|
    Foret = shapefile_to_np_array(file_shp_Foret, Extent, Csize, "FORET")
    np.save(Dir_temp + "Foret", np.int8(Foret))
    del Foret
    console_info(QCoreApplication.translate("MainWindow","    - Forest raster processed"))
    ### Forest : shapefile to raster
    Exposition = exposition(MNT, Csize, -9999)
    np.save(Dir_temp + "Aspect", np.uint16(Exposition + 0.5))
    Pente = prepa_obstacle_cable(Dir_Obs_cable, file_MNT, Dir_temp)
    np.save(Dir_temp + "Pente", Pente)
    Pond_pente = np.np.sqrt((Pente * 0.01 * Csize) ** 2 + Csize ** 2) / float(Csize)
    Pond_pente[Pente == -9999] = 10000
    np.save(Dir_temp + "Pond_pente", Pond_pente)
    del Pente, MNT
    console_info(QCoreApplication.translate("MainWindow","    - Cable obstacles processed"))

    #################################################################################################################################
    ###             __     __                    __               __                                                 __              
    ###.----.---.-.|  |--.|  |.-----.    .-----.|  |_.---.-.----.|  |_     .-----.----.-----.----.-----.-----.-----.|__|.-----.-----.
    ###|  __|  _  ||  _  ||  ||  -__|    |__ --||   _|  _  |   _||   _|    |  _  |   _|  _  |  __|  -__|__ --|__ --||  ||     |  _  |
    ###|____|___._||_____||__||_____|    |_____||____|___._|__|  |____|    |   __|__| |_____|____|_____|_____|_____||__||__|__|___  |
    ###                                                                    |__|                                               |_____|
    Cable_start = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"CABLE","CABLE",'ASC') 
    testExist = check_field(file_shp_Cable_Dep,"EXIST")
    if testExist:    
        Existing = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"EXIST","EXIST",'ASC') 
    else:
        Existing = np.ones_like(Cable_start,dtype=np.int8)*2

    pixels = np.argwhere(Cable_start>0)
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.int16) 
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        Lien_RF[ID,4]=Cable_start[pixel[0],pixel[1]]
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=Existing[pixel[0],pixel[1]]
        ID +=1         
    # Link RF with res_pub and calculate transportation distance
    # Lien_RF=Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for, Lien_RF,Csize) 
    # Lien_RF=Lien_RF[Lien_RF[:,4]>0]
    Lien_RF=Lien_RF[Lien_RF[:,2]>-1]
    np.save(Dir_temp+"Lien_RF_c",Lien_RF)  
    console_info(QCoreApplication.translate("MainWindow","    - Potential cable yarding starts processed"))    

    ###################################################################################################################################################################################
    ###                                 __                                     __                      __                                      __                                      
    ###.----.----.-----.-----.----.    |  |.-----.-----.    .----.---.-.-----.|  |_.-----.----.    .--|  |.-----.    .----.-----.-----.----.--|  |.-----.-----.-----.-----.-----.-----.
    ###|  __|   _|  -__|  -__|   _|    |  ||  -__|__ --|    |   _|  _  |__ --||   _|  -__|   _|    |  _  ||  -__|    |  __|  _  |  _  |   _|  _  ||  _  |     |     |  -__|  -__|__ --|
    ###|____|__| |_____|_____|__|      |__||_____|_____|    |__| |___._|_____||____|_____|__|      |_____||_____|    |____|_____|_____|__| |_____||_____|__|__|__|__|_____|_____|_____|
    ###                                                                                                                                                                                
    _, values, _, Extent = raster_get_info(file_MNT)
    Csize, ncols, nrows = values[4], int(values[0]), int(values[1])  
    TableX, TableY=create_coord_pixel_center_raster(values, nrows, ncols, Csize, Dir_temp)
    CoordRoute = np.zeros((Lien_RF.shape[0], 2), dtype=np.float32)
    for i, pixel in enumerate(Lien_RF):
        CoordRoute[i, 0]=TableX[pixel[1]]
        CoordRoute[i, 1]=TableY[pixel[0]] 
    np.save(Dir_temp+"CoordRoute.npy", CoordRoute)  
    console_info(QCoreApplication.translate("MainWindow","    - Table of coordinates created"))  
    ##############################################################################################################################################
    ###       __                         __   __                                __         __   
    ###.----.|  |.-----.-----.-----.    |  |_|  |--.-----.    .-----.----.----.|__|.-----.|  |_ 
    ###|  __||  ||  _  |__ --|  -__|    |   _|     |  -__|    |__ --|  __|   _||  ||  _  ||   _|
    ###|____||__||_____|_____|_____|    |____|__|__|_____|    |_____|____|__|  |__||   __||____|
    ###                                                                            |__|         
    console_info(QCoreApplication.translate("MainWindow","\nCable input data processing achieved\n"))
    clear_big_nparray()


def line_selection(Rspace_c, w_list, lim_list, new_calc, file_shp_Foret, file_Vol_ha, file_Vol_AM, Lhor_max, prelevement, Pente_max_bucheron):
    console_info(QCoreApplication.translate("MainWindow","Selection of the best lines based on user criteria."))
    ### Check if temporary files have been generated and have the same extent
    Rspace_sel = Rspace_c + "FilesForOptimization/"
    console_info(QCoreApplication.translate("MainWindow","Start of the best lines selection according to user criteria."))
    try: 
        Tab = np.load(Rspace_sel + "Tab_all_lines.npy") 
    except:
        console_warning(QCoreApplication.translate("MainWindow","Please run first the Sylvaccess cable."))
        return ""
    Lmax = np.max(Tab[:, 11])    
    _, values, Extent = loadrasterinfo_from_file(Rspace_sel)
    Csize, nrows, ncols = values[4], int(values[1]), int(values[0]) 
    if not new_calc:
        f = open(Rspace_sel + "info_Lhormax.txt", "r")
        Lhor_max = f.readlines(0)
        f.close()
        Lhor_max = float(Lhor_max[0])
    
    _, _, _, _, Row_ext, Col_ext, D_ext, D_lat, _ = create_buffer2(Csize, Lmax, Lhor_max)        
    Lien_RF = np.load(Rspace_sel + "Lien_RF_c.npy")
    ############################################
    ### Recompute cable line stats if necessary
    ############################################
    if new_calc:
        console_info(QCoreApplication.translate("MainWindow","    - Processing new line characteristics with new input data...")) 
        #Couche foret
        if file_shp_Foret != "":
            Forest = np.int8(shapefile_to_np_array(file_shp_Foret, Extent, Csize, "FORET"))
        else:
            Forest = np.load(Rspace_sel + "Forest.npy")
        #Couche vol_ha
        if file_Vol_ha != "":
            Vol_ha = load_float_raster_simple(file_Vol_ha) 
            Vol_ha[Vol_ha < 0] = 0
            Vol_ha[np.isnan(Vol_ha)] = 0
            test_vp = True
        else:
            test_vp = False            
            if file_Vol_AM != "":
                Vol_ha = np.zeros_like(Forest, dtype=np.float32)
            else:
                Vol_ha = np.zeros_like(Forest, dtype=np.int8)
        #Couche vol_am
        if file_Vol_AM != "":
            Vol_AM = load_float_raster_simple(file_Vol_AM) 
            Vol_AM[Vol_AM < 0] = 0
            Vol_AM[np.isnan(Vol_AM)] = 0
            test_vam = True
        else:
            test_vam = False  
            if file_Vol_ha != "":
                Vol_AM = np.zeros_like(Forest, dtype=np.float32)   
            else:
                Vol_AM = np.zeros_like(Forest, dtype=np.int8)   
       
        if test_vp or test_vam:             
            Pente = np.load(Rspace_sel + "Pente.npy")
            Vol_AM[Pente > Pente_max_bucheron] = 0
            Vol_ha[Pente > Pente_max_bucheron] = 0
        nbline = Tab.shape[0]        
        Rast_couv = np.zeros_like(Forest, dtype=np.int8)
        for i in range(0, nbline):
            coordX = Lien_RF[Tab[i, 0], 1]
            coordY = Lien_RF[Tab[i, 0], 0]       
            az = Tab[i, 1]
            Lline = np.sqrt((Tab[i, 2] - Tab[i, 6]) ** 2 + (Tab[i, 3] - Tab[i, 7]) ** 2)                                                      
            if test_vp or test_vam:
                Distance_moyenne, Surface, Vtot, VAM, Rast_couv = get_line_carac_vol(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv, Vol_ha, Vol_AM)
            else:
                Distance_moyenne, Surface, Rast_couv = get_line_carac_simple(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv)
            #Surface foret Dmoy chariot
            Tab[i, 13], Tab[i, 14] = Surface, Distance_moyenne
            #Vtot IPC
            if test_vp:
                Tab[i, 15] = Vtot
            #VAM               
            if test_vam:
                Tab[i, 16] = VAM * 10
   
    
    ############################################
    ### Calc IPC according to prelevement
    ############################################
    
    Tab2 = np.zeros((Tab.shape[0], Tab.shape[1] + 4), dtype=np.int16)
    Tab2[:, 0:-4] = Tab
    Tab2[:, -4] = np.int_(100.0 * Tab[:, 15] * prelevement / Tab[:, 11])
    del Tab
    gc.collect()    
    Tab2[:, -1] = Lien_RF[Tab2[:, 0], 0]
    Tab2[:, -2] = Lien_RF[Tab2[:, 0], 1]     
    del Lien_RF
    gc.collect()
    sup_max = np.max(Tab2[:, 17])    
    
    lim_list[4] = lim_list[4] / prelevement  # in order to account for prelevement in line selection
    
    #Modify selection criteria in case of no volume or vam        
    if np.max(Tab2[:, 15]) == 0:        
        if w_list[4] > 0:
            console_info(QCoreApplication.translate("MainWindow","Impossible optimization on volume/ipc criteria (no information available)."))   
        w_list[4], lim_list[4] = 0, 0
        w_list[5], lim_list[5] = 0, 0
        
    if np.max(Tab2[:, 16]) == 0:
        if w_list[6] > 0:
            console_info(QCoreApplication.translate("MainWindow","Impossible optimization on average tree volume criteria (no information available)."))
        w_list[6], lim_list[6] = 0, 0
        
    Rast_couv, Tab_result, Tab_name = select_best_lines(w_list, lim_list, Tab2,
                                                                   nrows, ncols, Csize,
                                                                   Row_ext, Col_ext, D_ext,
                                                                   D_lat, Lhor_max, sup_max)
    del Tab2  
    gc.collect()
    #Get folder
    dirs = [d for d in os.listdir(Rspace_c) if os.path.isdir(os.path.join(Rspace_c, d))]
    list_dir = []
    for dire in dirs:
        if dire[:12] == QCoreApplication.translate("MainWindow","Optimization"):
            list_dir.append(dire)
    optnum = len(list_dir) + 1
    Dir_result = Rspace_c + "Optimization" + str(optnum) 
    ### Get best volume
    header = QCoreApplication.translate("MainWindow","ID_pixel Azimuth_deg X_Start Y_Start Elevation_Start Hcable_Start X_End Y_End Elevation_End Hcable_End ")
    header += QCoreApplication.translate("MainWindow","Existing_road Cable_length Configuration ")
    header += QCoreApplication.translate("MainWindow","Forest_area Carriage_average_distance Volume_total ATV NB_int_sup")
    for num in range(1, sup_max + 1):
        header += ' ' + QCoreApplication.translate("MainWindow","Xcoord_intsup") + str(num) + ' ' + QCoreApplication.translate("MainWindow","Ycoord_intsup") + str(num) + ' ' + QCoreApplication.translate("MainWindow","Elevation_intsup") + str(num)
        header += ' ' + QCoreApplication.translate("MainWindow","Hcable_intsup") + str(num) + ' ' + QCoreApplication.translate("MainWindow","Pression_intsup") + str(num)
    header += QCoreApplication.translate("MainWindow","IPC cost") 
    Dir_result += Tab_name  
    header += '\n'
    try:
        os.mkdir(Dir_result)
    except:
        pass
    Dir_result += "/"
    filename = Dir_result + "Database_Optimization_" + str(optnum) + ".gzip" 
    shape_name = Dir_result + "CableLines_Optimization_" + str(optnum) + ".shp"
    rast_name = Dir_result + "CableArea_Optimization_" + str(optnum)
    pyl_name = Dir_result + "Int_sup_Optimization_" + str(optnum) + ".shp"
    
    save_integer_ascii(filename, header, Tab_result)
    source_src = get_source_src(Rspace_sel + "info_proj.shp") 
    road_network_proj = get_proj_from_road_network(Rspace_sel + "info_proj.shp")
    Line_to_shapefile(Tab_result, shape_name, source_src, prelevement) 
    #New rast_couv to take into account project of cable start
    Rast_couv = create_rast_couv(Tab_result, Dir_result, source_src, Extent, Csize, Lhor_max)
    #Rast_couv[Rast_couv>0]=1
    if not new_calc:
        Forest = np.load(Rspace_sel + "Forest.npy")
        try:         
            Vol_ha = np.load(Rspace_sel + "MainWindow","Vol_ha.npy")
        except:
            Vol_ha = np.zeros_like(Forest)
        try:
            Vol_AM = np.load(Rspace_sel + "MainWindow","Vol_AM.npy")
        except:
            Vol_AM = np.zeros_like(Forest)    
    Rast_couv[Forest == 0] = 0
    ArrayToGtiff(Rast_couv, rast_name, Extent, nrows, ncols, road_network_proj, 0, 'UINT8')    
    Pylone_in_shapefile(Tab_result, pyl_name, source_src)
    ### Summary of the choice
    generate_info_ligne(Dir_result, w_list, lim_list, Tab_result, Rast_couv, Vol_ha, Vol_AM, Csize, prelevement, Lhor_max) 
    console_info(QCoreApplication.translate("MainWindow","Selection of the best cable lines achieved."))

 
