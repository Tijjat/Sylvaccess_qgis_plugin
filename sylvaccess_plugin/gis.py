"""
/***************************************************************************
 gis
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from .console import console_info
import os
from osgeo import gdal, ogr
import numpy as np
from PyQt5.QtCore import QCoreApplication

#############################
#  _______  __      _______.#
# /  _____||  |    /       |#
#|  |  __  |  |   |   (----`#
#|  | |_ | |  |    \   \    #
#|  |__| | |  | .---)   |   #
# \______| |__| |______/    #
#############################                            


def check_field(filename,fieldname):
    verif=False    
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break    
    source_ds.Destroy() 
    return verif


def check_field_EXIST(filename,fieldname):    
    verif=False
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break
    if verif:
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))      
        nbval = np.unique(vals).shape[0]
        if nbval==1:
            verif=False
    source_ds.Destroy() 
    return verif


def save_raster_info(values,Rspace_c):   
    np.savetxt(Rspace_c+"Area_extent.txt", values, fmt='%f', delimiter=';')


def loadrasterinfo_from_file(Rspace_c):
    values = list(np.loadtxt(Rspace_c+"Area_extent.txt"))
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']    
    ncols = values[0]
    nrows = values[1]
    xmin=values[2]
    ymin = values[3]    
    Csize = values[4] 
    Extent = [xmin,xmin+ncols*Csize,ymin,ymin+nrows*Csize]
    return names,values,Extent


def load_float_raster(raster_file,Dir_temp):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [round(cols,2), round(rows,2), round(xmin,2), round(ymin,2), round(Csize,2),round(nodatavalue,2)]
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    f = open(Dir_temp+'info_extent.txt',"w")
    f.write(head_text)
    f.close()
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array),Extent,Csize,proj 


def load_float_raster_simple(raster_file):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)    
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()    
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array)


def get_source_src(file_name):
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()
    return source_layer.GetSpatialRef()


def shapefile_to_np_array(file_name,Extent,Csize,attribute_name,order_field=None,order=None):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)
    # Get information from source shapefile
    orig_data_source = ogr.Open(file_name)
    source_ds = ogr.GetDriverByName("Memory").CopyDataSource(orig_data_source, "")
    source_layer = source_ds.GetLayer()
    if order:
        source_layer_ordered = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' ORDER BY '+order_field+' '+order)
    else:source_layer_ordered=source_layer
    source_srs = source_layer.GetSpatialRef()
    # Initialize the new memory raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], source_layer_ordered,options=["ATTRIBUTE="+attribute_name,"ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        return mask_arr


def fin_ligne(point_coords):
    fin_ligne = []
    for i in range(point_coords.shape[0]-1):
        ind = np.sum((point_coords[:,0]==point_coords[i,0])*(point_coords[:,1]==point_coords[i,1]))
        if ind ==1:
            if i>0 and i+1<point_coords.shape[0]:
                if point_coords[i-1,2]!=point_coords[i,2] or point_coords[i+1,2]!=point_coords[i,2]:
                    fin_ligne.append(i)
            elif i==0 and point_coords[i+1,2]==point_coords[i,2]:fin_ligne.append(i)
            elif i==point_coords.shape[0]-1 and point_coords[i-1,2]==point_coords[i,2]:fin_ligne.append(i)
    return fin_ligne  


def shapefile_obs_to_np_array(file_list,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Obstacle = np.zeros((nrows,ncols),dtype=np.int16)
    #Loop on all shaefile
    for shp in file_list:        
        # Get shapefile info
        source_ds = ogr.Open(shp)
        ## test
        console_info(f"file_list: {file_list}")
        console_info(f"source_ds: {source_ds}")
        ##
        source_layer = source_ds.GetLayer()    
        source_srs = source_layer.GetSpatialRef()
        source_type = source_layer.GetGeomType()
        # Create copy
        target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
        layerName = os.path.splitext(os.path.split(shp)[1])[0]
        layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
        layerDefinition = layer.GetLayerDefn()
        new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
        layer.CreateField(new_field)
        ind=0
        for feat in source_layer:
            geometry = feat.GetGeometryRef()
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(ind)
            feature.SetField('Transfo',1)
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            feature.Destroy()
            ind +=1
        # Initialize raster
        maskvalue = 1    
        xres=float(Csize)
        yres=float(Csize)
        geotransform=(xmin,xres,0,ymax,0, -yres)         
        target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
        target_ds.SetGeoTransform(geotransform)
        if source_srs:
            # Make the target raster have the same projection as the source
            target_ds.SetProjection(source_srs.ExportToWkt())
        else:
            # Source has no projection (needs GDAL >= 1.7.0 to work)
            target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        # Rasterize
        err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
        if err != 0:
            raise Exception("error rasterizing layer: %s" % err)
        else:
            target_ds.FlushCache()
            mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        Obstacle =+ mask_arr
        target_ds1.Destroy()
        source_ds.Destroy()
    Obstacle = np.int8(Obstacle>0)
    return Obstacle


def get_proj_from_road_network(road_network_file):
    source_ds = ogr.Open(road_network_file)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    return source_srs.ExportToWkt()


def ArrayToGtiff(Array,file_name,Extent,nrows,ncols,road_network_proj,nodata_value,raster_type='INT32'):
    xmin,xmax,ymin,ymax=Extent[0],Extent[1],Extent[2],Extent[3]
    xres=(xmax-xmin)/float(ncols)
    yres=(ymax-ymin)/float(nrows)
    geotransform=(xmin,xres,0,ymax,0, -yres)
    if raster_type=='INT32':
        #-2147483648 to 2147483647
        DataType = gdal.GDT_Int32    
    elif raster_type=='UINT8':
        #0 to 255
        DataType = gdal.GDT_Byte
    elif raster_type=='UINT16':
        #0 to 65535    
        DataType = gdal.GDT_UInt16
    elif raster_type=='INT16':
        #-32768 to 32767 
        DataType = gdal.GDT_Int16
    elif raster_type=='FLOAT32':
        #Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
        DataType = gdal.GDT_Float32
    elif raster_type=='FLOAT16':
        #Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
        DataType = gdal.GDT_Float16
    target_ds = gdal.GetDriverByName('GTiff').Create(file_name+'.tif', int(ncols), int(nrows), 1, DataType)
    target_ds.SetGeoTransform(geotransform)
    target_ds.SetProjection(road_network_proj)
    target_ds.GetRasterBand(1).WriteArray( Array )
    target_ds.GetRasterBand(1).SetNoDataValue(nodata_value)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache()


def crop_to_main_dtm_size(raster_file, main_raster_file):
    main = gdal.Open(main_raster_file, gdal.GA_ReadOnly)
    console_info("trying to crop")
    try:
        main_gt = main.GetGeoTransform()
        main_x_origin = main_gt[0]
        main_y_origin = main_gt[3]
        main_pixel_width = main_gt[1]
        main_pixel_height = main_gt[5]
        main_width = main.RasterXSize
        main_height = main.RasterYSize

        # Calculate the coordinates for cropping
        lx = main_x_origin
        ly = main_y_origin
        rx = main_x_origin + main_width * main_pixel_width
        ry = main_y_origin - main_height * main_pixel_height

        window = (lx, ly, rx, ry)
        gdal.Translate(raster_file, main_raster_file, projWin=window)

    except Exception as e:
        err = QCoreApplication.translate("MainWindow", "Error: ") + str(e)
        console_info(err)

