"""
/***************************************************************************
 skidder
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os,gc,datetime
from qgis.PyQt.QtCore import QCoreApplication
import numpy as np
import math
from .gis import ArrayToGtiff, load_float_raster_simple, get_proj_from_road_network, get_source_src, shapefile_obs_to_np_array, shapefile_to_np_array,load_float_raster
from .general import heures, raster_get_info, read_info, clear_big_nparray, from_az_to_arr
from .function_np import focal_stat_max, focal_stat_nb, calcul_distance_de_cout, Dfwd_flat_forest_tracks, Dfwd_flat_forest_road, skid_debusq_RF, skid_debusq_Piste, fill_Link, skid_debusq_contour, pente, Link_RF_res_pub, Link_tracks_res_pub
from osgeo import gdal, ogr
from .console import console_info, console_warning
#####################################################################
#    _______. __  ___  __   _______   _______   _______ .______     #
#    /       ||  |/  / |  | |       \ |       \ |   ____||   _  \   #
#   |   (----`|  '  /  |  | |  .--.  ||  .--.  ||  |__   |  |_)  |  #
##   \   \    |    <   |  | |  |  |  ||  |  |  ||   __|  |      /   #
#.----)   |   |  .  \  |  | |  '--'  ||  '--'  ||  |____ |  |\  \--.#
#|_______/    |__|\__\ |__| |_______/ |_______/ |_______|| _| `.___|#
#####################################################################

# Fonctions qui gère les calculs liés au skidder

def Skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder, file_Vol_ha,
            Pente_max_bucheron, Pente_max_skidder, Dtreuil_max_up, Dtreuil_max_down, Dmax_train_near_for, Pmax_amont, Pmax_aval,
            Option_Skidder, Skid_Debclass ):

    Hdebut = datetime.datetime.now()

    # Create a folder for process results
    Rspace_s = Rspace + "Skidder/"
    try:
        os.mkdir(Rspace_s)
    except:
        pass
    Dir_temp = Wspace + "Temp/"

    # Check if temporary files have been generated and have the same extent
    try:
        _, values, _, Extent = raster_get_info(file_MNT)
    except:
        return QCoreApplication.translate("MainWindow","Error: Please define a projection for the DTM raster.")
    try:
        _, v1 = read_info(Dir_temp + 'info_extent.txt')
        for i, item in enumerate(values):
            if v1[i] != round(item, 2):
                prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder)
            if i + 1 > 4:
                break
    except:
        prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder)

    # Inputs
    try:
        Foret = np.int8(np.load(Dir_temp + "Foret.npy"))
        Piste = np.int8(np.load(Dir_temp + "Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp + "Route_for.npy"))
        Res_pub = np.int8(np.load(Dir_temp + "Res_pub.npy"))
        Lien_piste = np.load(Dir_temp + "Lien_piste.npy")
        Lien_RF = np.load(Dir_temp + "Lien_RF.npy")
        Pente = np.load(Dir_temp + "Pente.npy")
        Pond_pente = np.load(Dir_temp + "Pond_pente.npy")
        MNT = np.load(Dir_temp + "MNT.npy")
        Full_Obstacles_skidder = np.int8(np.load(Dir_temp + "Full_Obstacles_skidder.npy"))
        Partial_Obstacles_skidder = np.int8(np.load(Dir_temp + "Partial_Obstacles_skidder.npy"))
    except:
        prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder)
        Foret = np.int8(np.load(Dir_temp + "Foret.npy"))
        Piste = np.int8(np.load(Dir_temp + "Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp + "Route_for.npy"))
        Res_pub = np.int8(np.load(Dir_temp + "Res_pub.npy"))
        Lien_piste = np.load(Dir_temp + "Lien_piste.npy")
        Lien_RF = np.load(Dir_temp + "Lien_RF.npy")
        Pente = np.load(Dir_temp + "Pente.npy")
        Pond_pente = np.load(Dir_temp + "Pond_pente.npy")
        MNT = np.load(Dir_temp + "MNT.npy")
        Full_Obstacles_skidder = np.int8(np.load(Dir_temp + "Full_Obstacles_skidder.npy"))
        Partial_Obstacles_skidder = np.int8(np.load(Dir_temp + "Partial_Obstacles_skidder.npy"))

    nrows, ncols = MNT.shape[0], MNT.shape[1]
    road_network_proj = get_proj_from_road_network(file_shp_Desserte)
    
    # Calculation of useful variables for the model process
    Pmax_up = float(abs(Pmax_amont)) / 100.0
    Pmax_down = -float(abs(Pmax_aval)) / 100.0
    deniv_up = math.sqrt(float(Dtreuil_max_up * Dtreuil_max_up) / float(1 + 1.0 / float(Pmax_up * Pmax_up)))
    deniv_down = -math.sqrt(float(Dtreuil_max_down * Dtreuil_max_down) / float(1 + 1.0 / float(Pmax_down * Pmax_down)))
    coeff = float(Dtreuil_max_up - Dtreuil_max_down) / float(deniv_up - deniv_down)
    orig = Dtreuil_max_up - coeff * deniv_up
    Csize = values[4]
    Pond_pente[Full_Obstacles_skidder == 1] = 1000
    Pente_max = focal_stat_max(np.float_(Pente), -9999, 1)
    Manual_harvesting = np.int8((Pente_max <= Pente_max_bucheron))
    del Pente_max
    gc.collect()
    Pente_ok_skid = np.int8((Pente <= Pente_max_skidder) * (Pente > -9999))
    MNT_OK = np.int8((MNT != values[5]))
    Zone_OK = np.int8(MNT_OK * (Foret == 1) * (Full_Obstacles_skidder == 0) * Manual_harvesting == 1)

    Surf_foret = np.sum((Foret == 1) * MNT_OK) * Csize * Csize * 0.0001
    Surf_foret_non_access = int(np.sum((Manual_harvesting == 0) * (Foret == 1) * MNT_OK * Csize * Csize * 0.0001) + 0.5)

    Row_line, Col_line, D_line, Nbpix_line = create_buffer_skidder(Csize, Dtreuil_max_up, Dtreuil_max_down)

    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)] = 0
        Temp = ((Vol_ha > 0) * (Foret == 1) * MNT_OK) > 0
        Vtot = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
        Temp = ((Vol_ha > 0) * (Manual_harvesting == 0) * (Foret == 1) * MNT_OK) > 0
        Vtot_non_buch = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
        del Vol_ha, Temp
    else:
        Vtot = 0
        Vtot_non_buch = 0

    ArrayToGtiff(Manual_harvesting, Rspace_s + 'Manual_harvesting', Extent, nrows, ncols, road_network_proj, 0, 'UINT8')
    console_info(QCoreApplication.translate("MainWindow","    - Initialization achieved, processing..."))
    del Pente, Manual_harvesting
    gc.collect()

    
    ###############################################################################################################################################    
    ### Calculation of skidding distance inside the forest stands
    ###############################################################################################################################################                  
    # Identify the forest area that may be run through by the skidder
    zone_rast = Pente_ok_skid*(Foret==1)
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    from_rast = np.int8(((Piste==1)+(Route_for==1))>0)
    from_rast[Res_pub==1]=0
    Zone_for,_ = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Zone_for[Zone_for>=0]=1
    Zone_for[from_rast==1]=1
    Zone_for=np.int8(Zone_for)
    
    # Create a buffer of Dmax_out_forest around these area taking into account slope and obstacles
    from_rast = focal_stat_nb(np.float_(Zone_for==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.copy(Pente_ok_skid)
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0 
    Zone_for2,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Dmax_train_near_for) 
    Pente_ok_skidder = np.int8(Zone_for2>0)
    Pente_ok_skidder[Zone_for==1]=1 
    
    del Zone_for,Zone_for2,Out_alloc
    gc.collect()
    
    #Stick all forest with pente_ok_skidder to the area
    from_rast = focal_stat_nb(np.float_(Pente_ok_skidder==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.int8(1*Pente_ok_skid*(Foret==1))
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Pente_ok_skidder[Zone_for>=0]=1    
           
    del Zone_for,from_rast,zone_rast,Out_alloc,Pente_ok_skid
    gc.collect()     
    
    
    D_foret_piste,L_Piste,D_piste=Dfwd_flat_forest_tracks(Lien_piste, Pond_pente, Pente_ok_skidder*(Route_for==0)*1, Csize)    
    D_foret_RF,L_RF = Dfwd_flat_forest_road(Lien_RF,Pond_pente,Pente_ok_skidder*1*(Piste==0),Csize)
    
    del Pente_ok_skidder, Pond_pente
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Skidding distance from forest roads network calculated"))

    ###############################################################################################################################################
    ### Calculation of skidding distance from forest roads
    ###############################################################################################################################################

    DebRF_D, DebRF_LRF = skid_debusq_RF(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line, coeff, orig, Pmax_up, Pmax_down,
                                        Dtreuil_max_up, Dtreuil_max_down, nrows, ncols, Zone_OK * (Route_for == 0) * 1 * (Piste == 0))

    console_info(QCoreApplication.translate("MainWindow","    - Winching distance from forest roads calculated"))

    ###############################################################################################################################################
    #### Calculation of skidding distance from forest tracks
    ###############################################################################################################################################                 

    Debp_D, Debp_LP, Debp_Dtrpiste = skid_debusq_Piste(Lien_piste, MNT, Row_line, Col_line, D_line, Nbpix_line, coeff, orig, Pmax_up, Pmax_down,
                                                    Dtreuil_max_up, Dtreuil_max_down, nrows, ncols, Zone_OK * (Piste == 0) * 1 * (Route_for == 0))

    console_info(QCoreApplication.translate("MainWindow","    - Winching distance from forest tracks calculated"))
    gc.collect()

        
    ###############################################################################################################################################    
    ### Concatenation of the resultats (1)
    ###############################################################################################################################################
    DTrain_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    DTrain_foret = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Ddebusquage = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_RF = np.ones((nrows,ncols),dtype=np.int32)*-9999
             
    if Option_Skidder==1:
        # Option 1 : Skidder is forced to stay as much possible as possible on forest road networks
        # Get value of winching distance from forest roads
        Temp = (DebRF_D>=0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = DebRF_D[Temp]
        Lien_foret_RF[Temp] = DebRF_LRF[Temp]
            
        # Get value of winching distance from forest tracks  
        Temp = Debp_D>=0
        Temp[(Debp_D+0.1*Debp_Dtrpiste)>Ddebusquage]=0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp]
        Lien_foret_RF[Temp] = -9999
        Temp = ((Ddebusquage<0)*(Debp_D>=0))>0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp]
        Lien_foret_RF[Temp] = -9999
        
        # Get value of skidding distance within forest stand from forest tracks
        Temp = (Ddebusquage<0)*(D_foret_piste>=0)
        DTrain_piste[Temp] = D_piste[Temp]
        DTrain_foret[Temp] = D_foret_piste[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_piste[Temp] = L_Piste[Temp]
        
        # Get value of skidding distance within forest stand from forest roads
        Temp = (Ddebusquage==0)*(D_foret_RF>=0)
        Temp[(DTrain_foret+0.1*DTrain_piste)<D_foret_RF]=0
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]  
        Temp = (Ddebusquage<0)*(D_foret_RF>=0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]   
         
        
    else:
        # Option 2 : Limit the skidding : skidder goes as close as possible to the timber before using winching possibility

        # Get value of skidding distance within forest stand from forest tracks
        Temp = (D_foret_piste>=0)
        DTrain_piste[Temp] = D_piste[Temp]
        DTrain_foret[Temp] = D_foret_piste[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_piste[Temp] = L_Piste[Temp]   
        
        # Get value of skidding distance within forest stand from forest roads       
        Temp = (Ddebusquage==0)*(D_foret_RF>=0)
        Temp[(DTrain_foret+0.1*DTrain_piste)<D_foret_RF]=0
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]     
        Temp = (D_foret_RF>=0)*(DTrain_foret<0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]                  
        
        # Get value of winching distance from forest roads
        Temp = (DebRF_D>=0)*(DTrain_foret<0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = DebRF_D[Temp]
        Lien_foret_RF[Temp] = DebRF_LRF[Temp]   
        
        # Get value of winching distance from forest tracks
        Temp = Debp_D>=0
        Temp[(Debp_D+0.1*Debp_Dtrpiste)>Ddebusquage]=0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp] 
        Lien_foret_RF[Temp] = -9999        
        Temp = ((DTrain_foret<0)*(Debp_D>=0))>0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp] 
        Lien_foret_RF[Temp] = -9999
        
        
    # Calculation of the forest area accessible with a skidder
    zone_tracteur = np.zeros_like(MNT,dtype=np.int8)
    zone_tracteur[((D_foret_piste>=0)*(Foret==1))>0]=1
    zone_tracteur[((D_foret_RF>=0)*(Foret==1))>0]=1    
    
    ArrayToGtiff(zone_tracteur,Rspace_s+'Free_access_of_the_skidder',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    console_info(QCoreApplication.translate("MainWindow","    - First concatenation done"))  
    del DebRF_D,DebRF_LRF,Debp_D,Debp_LP,Debp_Dtrpiste
    gc.collect() 
    
    ################################################################################################################################################  
    ### Calculation of winching distance from contours
    ################################################################################################################################################
    contour = focal_stat_nb(np.float_((zone_tracteur==1)*1),0,1)
    contour = ((contour<9)*(contour>0)>0)*1
    contour[Full_Obstacles_skidder==1]=0
    contour[Partial_Obstacles_skidder==1]=0
    contour[Res_pub==1]=0   
    contour[MNT_OK==0]=0  
    
    pixels=np.argwhere(contour>0)
    del zone_tracteur,Full_Obstacles_skidder,Partial_Obstacles_skidder,Res_pub,MNT_OK,contour
    gc.collect()
    
    #line=ID_contour, Y, X,L_RF,L_piste,Dtrain,Dpis
    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int16)    
    ID = 1
    for pixel in pixels:
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        testpiste=0
        if D_foret_RF[pixel[0],pixel[1]]<0:
            testpiste=1
        elif D_piste[pixel[0],pixel[1]]>=0:
            if (D_foret_piste[pixel[0],pixel[1]]+0.1*D_piste[pixel[0],pixel[1]])<D_foret_RF[pixel[0],pixel[1]]:
                testpiste=1
        if testpiste:
            Lien_contour[ID,2],Lien_contour[ID,3]=-9999,L_Piste[pixel[0],pixel[1]]
            Lien_contour[ID,4],Lien_contour[ID,5]=D_foret_piste[pixel[0],pixel[1]],D_piste[pixel[0],pixel[1]]
        else:
            Lien_contour[ID,2],Lien_contour[ID,3]=L_RF[pixel[0],pixel[1]],-9999
            Lien_contour[ID,4],Lien_contour[ID,5]=D_foret_RF[pixel[0],pixel[1]],0     
        ID += 1
    del D_foret_piste,L_Piste,D_piste,D_foret_RF,L_RF
    gc.collect()    
    
    # Get the contour of traversable area
    Ddebus,L_RF,L_Piste,Dpis,Dfor=skid_debusq_contour(Lien_contour,MNT,Row_line,Col_line,D_line,Nbpix_line,coeff,orig,Pmax_up,Pmax_down,
                                                         Dtreuil_max_up,Dtreuil_max_down,nrows,ncols,Zone_OK*1*(Ddebusquage<=0))
                                                      
    del Lien_contour,pixels,MNT
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Distance de debusquage depuis le contour de la zone parcourable calculee"))      
    
    ################################################################################################################################################  
    ### Concatenation (2)
    ################################################################################################################################################    
    
    Temp = (Ddebusquage<0)*(Ddebus>=0)
    DTrain_piste[Temp] = Dpis[Temp]
    DTrain_foret[Temp] = Dfor[Temp]
    Ddebusquage[Temp] = Ddebus[Temp]
    Lien_foret_RF[Temp] = L_RF[Temp]
    Lien_foret_piste[Temp] = L_Piste[Temp]
        
    del Ddebus,L_RF,L_Piste,Dpis,Dfor
    gc.collect()
    
    Temp = (Foret==0)
    DTrain_piste[Temp] = -9999
    DTrain_foret[Temp] = -9999
    Ddebusquage[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    
    del Temp
    gc.collect()
    
    # Fill Lien foret respub and Lien foret RF
    Lien_foret_Res_pub,Lien_foret_RF,Keep=fill_Link(Lien_foret_piste,Lien_piste,Lien_RF, Lien_foret_RF, nrows,ncols)
    
    Temp = (Keep<1)*((Piste==1)+(Route_for==1))>0
    DTrain_piste[Temp] = -9999
    DTrain_foret[Temp] = -9999
    Ddebusquage[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_Res_pub[Temp] = -9999
        
    del Temp,Keep
    gc.collect()
    
    # Calculation of the total skidding distance
    Dtotal = np.ones((nrows,ncols),dtype=np.int32)*-9999
    zone_accessible = np.zeros((nrows,ncols),dtype=np.int8)
    Temp = (Ddebusquage>=0)
    Dtotal[Temp]= DTrain_piste[Temp] + DTrain_foret[Temp] + Ddebusquage[Temp]
    zone_accessible[Temp] = 1    
   
    del Temp
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Concatenation des resultats terminee. Sauvegarde en cours..."))             
        
    
    ### Saving all rasters
    ##################################################################################################################################################
    ### Create a summary table of accessible area    
    make_summary_surface_vol(Skid_Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,Dtotal,Vtot,Vtot_non_buch,Rspace_s,"Skidder")
     
    ### Save output rasters
    ArrayToGtiff(zone_accessible,Rspace_s+'Accesible_forest',Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    ArrayToGtiff(Foret-zone_accessible,Rspace_s+'Unacccessible_forest',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    ArrayToGtiff(DTrain_piste,Rspace_s+'Skidding_distance_on_tracks',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(DTrain_foret,Rspace_s+'Skidding_distance_in_forest',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Ddebusquage,Rspace_s+'Winching_distance',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Dtotal,Rspace_s+'Total_distance',Extent,nrows,ncols,road_network_proj,-9999,'INT32')        
    ArrayToGtiff(Lien_foret_piste,Rspace_s+'Link_forest_ForestTrack',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_RF,Rspace_s+'Link_forest_ForestRoads',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_Res_pub,Rspace_s+'link_forest_public_road_network',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    layer_name = 'Skidder_recap_accessibility'
    source_src=get_source_src(file_shp_Desserte)  
    create_access_shapefile(Dtotal,Rspace_s,Foret,Skid_Debclass.split(";"),road_network_proj,source_src, Dir_temp,Extent,nrows,ncols,layer_name)
      
    del zone_accessible,DTrain_piste,DTrain_foret,Ddebusquage,Dtotal
    del Lien_foret_piste,Lien_foret_RF,Lien_foret_Res_pub
    
    str_duree,str_fin,str_debut=heures(Hdebut)
    
    ### Genere le fichier avec le resume des parametres de simulation
    file_name = str(Rspace_s)+"Parameters_of_simulation.txt"
    resume_texte = QCoreApplication.translate("MainWindow","Sylvaccess : AUTOMATIC MAPPING OF FOREST ACCESSIBILITY WITH SKIDDER\n\n\n")
    ver = "0.2"
    date = "2024/02"
    resume_texte += QCoreApplication.translate("MainWindow","Software version :") + ver + QCoreApplication.translate("MainWindow"," - ", "skidder_results") + date + "\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","Resolution       : " + str(Csize) + QCoreApplication.translate("MainWindow"," m ") + "\n\n")
    resume_texte += "" .join (["_"]*80) + "\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","Date and time when launching the script:              ")+str_debut+"\n"
    resume_texte += QCoreApplication.translate("MainWindow","Date and time at the end of execution of the script:  ")+str_fin+"\n"
    resume_texte += QCoreApplication.translate("MainWindow","Total execution time of the script:                   ")+str_duree+"\n\n"
    resume_texte += "" .join (["_"]*80) + "\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","PARAMETERS USED FOR THE MODELING:\n\n")
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum uphill distance for winching:                        ")+str(Dtreuil_max_up)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum downhill distance for winching:                      ")+str(Dtreuil_max_down)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope to get maximum uphill winching distance:       ")+str(Pmax_amont)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope to get maximum downhill winching distance:     ")+str(Pmax_aval)+" %\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum distance outside forest and forest road network:     ")+str(Dmax_train_near_for)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for a free access of the parcels with skidder: ")+str(Pente_max_skidder)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for manual felling of the trees:               ")+str(Pente_max_bucheron)+" %\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Simulation option:\n"  )  
    if Option_Skidder==1:
        resume_texte += QCoreApplication.translate("MainWindow","      * Limit soil damages: force the skidder to process as much as possible \n")    
        resume_texte += QCoreApplication.translate("MainWindow","        from the forest road network\n" )
    else:
        resume_texte += QCoreApplication.translate("MainWindow","      * Limit winching distances: force the skidder to go as close as possible\n")    
        resume_texte += QCoreApplication.translate("MainWindow","        to the timber\n" )
    if Dir_Full_Obs_skidder!='':
        resume_texte += QCoreApplication.translate("MainWindow","      * Simulation with areas where skidder operations are forbidden (Full obstacles)\n" ) 
    if Dir_Partial_Obs_skidder!='':
        resume_texte += QCoreApplication.translate("MainWindow","      * Simulation with areas where skidding is forbidden but winching possible (Partial obstacles)\n" ) 
        
    if os.path.exists(Rspace_s+"Forest_tracks_not_connected.tif"):
        resume_texte += "\n\n"
        resume_texte += "".join(["_" * 80])
        resume_texte += QCoreApplication.translate("MainWindow","      !!! Warning !!! Some forest tracks are not connected to public network.\n")  
        resume_texte += QCoreApplication.translate("MainWindow","      They were removed from the analysis.\n")  
    if os.path.exists(Rspace_s+"Forest_road_not_connected.tif"):
        resume_texte += "".join(["_" * 80])
        resume_texte += "\n\n" + QCoreApplication.translate("MainWindow","      !!! Warning !!! Some forest roads are not connected to public network.\n")  
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    
        
        
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    console_info(QCoreApplication.translate("MainWindow","Skidder model finished"))
    clear_big_nparray()
    gc.collect()
    

def create_new_road_network(file_shp_Desserte,Wspace):
    Dir_temp = Wspace+"Temp/"    
    try:os.mkdir(Dir_temp)
    except:pass 
    File_fin = Dir_temp+"Existing_roads.shp"    
    source_ds = ogr.Open(file_shp_Desserte)
    source_layer = source_ds.GetLayer()
    source_src = source_layer.GetSpatialRef()
    driver = ogr.GetDriverByName('ESRI Shapefile')
    target_ds = driver.CreateDataSource(File_fin)
    layerName = os.path.splitext(os.path.split(File_fin)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn("CL_SVAC", ogr.OFTInteger)
    layer.CreateField(new_field)
    for feat in source_layer:
        geometry = feat.GetGeometryRef()
        label = feat.GetField('EXIST')
        if label == 2:
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetField("CL_SVAC",feat.GetField("CL_SVAC"))
            layer.CreateFeature(feature)
            feature.Destroy()
    source_ds.Destroy()
    target_ds.Destroy()
    return File_fin


def make_summary_surface_vol(Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,Dtotal,Vtot,Vtot_non_buch,Rspace_s,modele_name):
    Skid_list = Debclass.split(";")
    nbclass = len(Skid_list)
    file_name = str(Rspace_s)+"Summary_results_Sylvaccess_"+modele_name+".txt" 
    vol = False

    #SURFACE
    Surf_Cum = 0 
    recap_surface = []
    totaux_surface = []

    for i in range(1, nbclass):
        dmin, dmax = int(Skid_list[i - 1]), int(Skid_list[i])
        class_text = f"{dmin} - {dmax} m"
        Temp = np.sum((Dtotal >= dmin) * (Dtotal < dmax) * Csize * Csize * 0.0001)
        recap_surface.append(class_text)
        recap_surface.append(str(round(Temp, 1)))
        recap_surface.append(str(round(Temp / Surf_foret * 100, 1)))
        recap_surface.append(str(round(Temp + Surf_Cum, 1)))
        recap_surface.append(str(round((Temp + Surf_Cum) / Surf_foret * 100, 1)))
        Surf_Cum += Temp

    # Ajouter la classe de distance infinie
    dmin = Skid_list[nbclass - 1]
    if dmin.isdigit():
        dmin = int(dmin)
        try:
            Temp = np.sum((Dtotal >= dmin) * Csize * Csize * 0.0001)
            recap_surface.append(f"> {dmin} m")
            recap_surface.append(str(round(Temp, 1)))
            recap_surface.append(str(round(Temp / Surf_foret * 100, 1)))
            recap_surface.append(str(round(Temp + Surf_Cum, 1)))
            recap_surface.append(str(round((Temp + Surf_Cum) / Surf_foret * 100, 1)))
            Surf_Cum += Temp
        except ValueError as e:
            console_warning(QCoreApplication.translate("MainWindow","Error converting '{dmin}' to an integer. Skid_list: {Skid_list}", dmin=dmin, Skid_list=Skid_list))
            console_warning(QCoreApplication.translate("MainWindow","Dtotal: {Dtotal}", Dtotal=Dtotal))
            raise e
    else:
        console_warning(QCoreApplication.translate("MainWindow","Invalid literal for int() with base 10: '{dmin}'. Skid_list: {Skid_list}", dmin=dmin, Skid_list=Skid_list))
        raise ValueError(QCoreApplication.translate("MainWindow","Invalid literal for int() with base 10: '{dmin}'", dmin=dmin))


    # Calcul des totaux
    totaux_surface.append(str(round(Surf_Cum, 1)) + " ha")
    totaux_surface.append(str(round(Surf_Cum / Surf_foret * 100, 1)) + " %")
    totaux_surface.append(str(round(Surf_foret - Surf_Cum, 1)) + " ha")
    totaux_surface.append(str(round((Surf_foret - Surf_Cum) / Surf_foret * 100, 1)) + " %")
    totaux_surface.append(str(round(Surf_foret_non_access, 1)) + " ha")
    totaux_surface.append(str(round(Surf_foret_non_access / Surf_foret * 100, 1)) + " %")
    totaux_surface.append(str(round(Surf_foret, 1)) + " ha")
            
    #VOLUME            
    recap_volume = []
    totaux_volume = []

    if file_Vol_ha != "":
        vol = True
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)] = 0

        # Créer des tableaux pour les classes de distance et les valeurs associées
        classes_distance = []
        valeurs_associees = []

        # Create recap per distance class
        Vol_Cum = 0
        for i in range(1, nbclass):
            dmin, dmax = int(Skid_list[i - 1]), int(Skid_list[i])
            Temp = ((Dtotal >= dmin) * (Dtotal < dmax) * (Vol_ha >= 0)) > 0
            if np.sum(Temp > 0):
                Vclass = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
            else:
                Vclass = 0
            classes_distance.append(f"{dmin}-{dmax}")
            valeurs_associees.append(Vclass)

        # Ajouter la classe de distance infinie
        dmin = int(Skid_list[nbclass - 1])
        Temp = ((Dtotal >= dmin) * (Vol_ha >= 0)) > 0
        if np.sum(Temp > 0):
            Vclass = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
        else:
            Vclass = 0
        classes_distance.append(f"{dmin}-inf")
        valeurs_associees.append(Vclass)

        # Enregistrer les valeurs cumulées
        Vol_Cum = 0
        for i in range(len(classes_distance)):
            Vol_Cum += valeurs_associees[i]
            recap_volume.append(classes_distance[i])
            recap_volume.append(str(int(valeurs_associees[i] + 0.5)))
            recap_volume.append(str(round(valeurs_associees[i] / Vtot * 100, 1)))
            recap_volume.append(str(int(valeurs_associees[i] + Vol_Cum + 0.5)))
            recap_volume.append(str(round(100 * (valeurs_associees[i] + Vol_Cum) / Vtot, 1)))

        # Ajouter les totaux
        totaux_volume.append(str(int(Vol_Cum + 0.5)) + " m3")
        totaux_volume.append(str(round(100 * Vol_Cum / Vtot, 1)) + " %")
        totaux_volume.append(str(int(Vtot - Vol_Cum + 0.5)) + " m3")
        totaux_volume.append(str(round(100 * (Vtot - Vol_Cum) / Vtot, 1)) + " %")
        totaux_volume.append(str(int(Vtot_non_buch + 0.5)) + " m3")
        totaux_volume.append(str(round(100 * (Vtot_non_buch) / Vtot, 1)) + " %")
        totaux_volume.append(str(int(Vtot + 0.5)) + " m3")

    # Les en-têtes des colonnes dans le fichier texte
    headers =QCoreApplication.translate("MainWindow", "Total yarding distance |   Surface area (ha)   | Surface per class (%) |Cumulative surface (ha)|Cumulative surface (%) \n", " each section between | has to be 23 character wide to retain the layout")
    headers2= QCoreApplication.translate("MainWindow","Total yarding distance |      Volume (m3)      | Volume per class (%)  |Cumulative volume (m3) |Cumulative volume (%) \n" , " each section between | has to be 23 character wide to retain the layout")

    # Ajouter des espaces pour que les colonnes aient la même largeur
    recap_surface = [str(elem) for elem in recap_surface]
    recap_surface = [elem.ljust(30) for elem in recap_surface]
    recap_volume = [str(elem) for elem in recap_volume]
    recap_volume = [elem.ljust(30) for elem in recap_volume]

    # Données des tableaux
    data = zip(recap_surface[::5], recap_surface[1::5], recap_surface[2::5], recap_surface[3::5], recap_surface[4::5])
    data2 = zip(recap_volume[::5], recap_volume[1::5], recap_volume[2::5], recap_volume[3::5], recap_volume[4::5])
    # Écriture dans le fichier
    with open(file_name, "w") as file:
        # Écriture des en-têtes
        file.write(headers)
        # Écriture des données
        for row in data:
            file.write("|".join(row) + "\n")
        file.write("".join(["_" * len(headers)]))
        file.write("\n\n")
        file.write(QCoreApplication.translate("MainWindow","Total accessible forest") + ":   " + totaux_surface[0] + ";  " + totaux_surface[1] + "\n")
        file.write(QCoreApplication.translate("MainWindow","Total unaccessible forest") + ": " + totaux_surface[2] + ";  " + totaux_surface[3] + "\n")
        file.write(QCoreApplication.translate("MainWindow","    --> including impossible manual felling") + ":   " + totaux_surface[4] + ";" + totaux_surface[5] + "\n") 
        file.write("".join(["_" * len(headers)]))
        file.write("\n\n")
        file.write(QCoreApplication.translate("MainWindow","Total area of forest :") + "   " + totaux_surface[6] + "\n")
        if vol:
            file.write(headers2)
            for row in data2:
                file.write("|".join(row) + "\n")


def make_dif_files(Rspace, idmod):  # idmod 0 : Skidder, 1 : Forwarder
    Modele = ["Skidder","Forwarder"]
    Rspace_s = Rspace+Modele[idmod]+"/"
    filename = "Summary_results_Sylvaccess_"+Modele[idmod]+".txt"
    rastname = "Total_distance.tif"
    foldExist = Rspace_s+"1_Existing/"
    foldProj = Rspace_s+"2_Project/"
    txtname = Rspace_s+"Comparison_before_after_project.txt"
    shpname = "Impacted_area"
        

    #Shapefile des differences
    _,values,_,Extent = raster_get_info(foldExist+rastname)
    Csize = values[4]
    DExist =  load_float_raster_simple(foldExist+rastname)
    DProj =  load_float_raster_simple(foldProj+rastname)
    nrows,ncols = DProj.shape
    Diff2 = DExist-DProj
    Diff2[DExist==-9999]=0
    Diff2[DProj==-9999]=0
    Diff = np.zeros_like(DExist,dtype=np.int8)
    Diff[((DExist==-9999)*(DProj>=0))>0] = 1 #Nouvel accessible
    Diff[((Diff2>0)*(Diff2<500))>0] = 2 
    Diff[((Diff2>500)*(Diff2<1000))>0] = 3
    Diff[((Diff2>1000)*(Diff2<1500))>0] = 4
    Diff[Diff2>1500] = 5
    Surf_impact = round(np.sum(Diff>0)*Csize*Csize/10000,1)
    road_network_proj=get_proj_from_road_network(foldExist+Modele[idmod]+"_recap_accessibility.shp")
    source_src=get_source_src(foldExist+Modele[idmod]+"_recap_accessibility.shp") 

       
    ArrayToGtiff(Diff,Rspace_s+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    del DExist,DProj,Diff2,Diff
    gc.collect()
    
    label =  QCoreApplication.translate("MainWindow",["","0_New accessible area","4_Shortened distance from 1 to 500m",
               "3_Shortened distance from 500 to 999m", "2_Shortened distance from 1000 to 1499m",
               "1_Shortened distance of at least 1500m"])

    
    ds = gdal.Open(Rspace_s+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("GPKG")
    dst_ds = drv.CreateDataSource( Rspace_s+shpname+".gpkg")
    dst_layer = dst_ds.CreateLayer(shpname, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds = None
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
            feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()    
    
    os.remove(Rspace_s+"Recap.tif")
    
    
    #Tableau des differences   
    TabExist = np.loadtxt(foldExist+filename,dtype='|U39',delimiter=";")
    TabProj = np.loadtxt(foldProj+filename,dtype='|U39',delimiter=";")
    if TabExist.shape[1]<6:        
        colrecap=[1,2]       
    else:        
        colrecap=[1,2,5,6] 
    Table = np.empty((TabExist.shape[0]-3,TabExist.shape[1]),dtype='|U39')    
    Table[0:-3,0]=TabExist[0:-6,0]
    for i in range(1,Table.shape[1]):
        Table[0,i]=str("Diff. ")+TabExist[0,i]
    
    for i in range(1,TabExist.shape[0]-6):
        for j in range(1,Table.shape[1]):
            Table[i,j]=round(float(TabProj[i,j])-float(TabExist[i,j]),1)
    
        Table[-2,0]=QCoreApplication.translate("MainWindow","Total supplementary forest area")
        Table[-1,0]=QCoreApplication.translate("MainWindow","Impacted forest area")
            
    for i in colrecap:
        Table[-2,i]=round(np.sum(np.float32(Table[1:-3,i])),1)
        
    Table[-1,1:3]=Surf_impact,round(Surf_impact/float(TabExist[-1,1][:-3])*100,1)   
    np.savetxt(txtname, Table,fmt='%s', delimiter=';') 


def prepa_obstacle_skidder(Obstacles_directory,Extent,Csize,ncols,nrows,Rast_desserte_ok):
    liste_file = os.listdir(Obstacles_directory)
    liste_obs = []
    for files in liste_file:
        if files[-4:len(files)] == '.shp' or files[-4:len(files)] == '.gbkg':
            liste_obs.append(Obstacles_directory+files)
    if len(liste_obs)>0:
        Obstacles_skidder = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        Temp = (Rast_desserte_ok>0)
        Obstacles_skidder[Temp] = 0
    else: Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    return Obstacles_skidder


def create_buffer_skidder(Csize,Dtreuil_max_up,Dtreuil_max_down):
    Lcote = max(Dtreuil_max_up,Dtreuil_max_down)+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((max(Dtreuil_max_up,Dtreuil_max_down)/Csize+1.5))
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float32)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)    
    for az in Dir_list:
        #Fill line info
        _,_,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lcote,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],3))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix        
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line


def create_access_shapefile(Dtotal,Rspace_s,Foret,HarvClass_list,road_network_proj,source_src,Dir_temp,Extent,nrows,ncols,layer_name):
    Recap = np.copy(Foret)
    #0: no Forest
    #1: inaccessible forest
    #2: Non_buch
    #Then harvesting classes
    label = [QCoreApplication.translate("MainWindow","Non-forest area"),QCoreApplication.translate("MainWindow","Inaccessible forest"),QCoreApplication.translate("MainWindow","Non harvestable (too steep slope)")]
    nbclass = len(HarvClass_list)    
    for i in range(1,nbclass):
        dmin,dmax = int(HarvClass_list[i-1]),int(HarvClass_list[i])
        label.append(QCoreApplication.translate("MainWindow","Accessible - Skidding class ")+str(i)+': '+str(HarvClass_list[i-1])+" - "+str(HarvClass_list[i])+" m")
        Temp = ((Dtotal>=dmin)*(Dtotal<dmax)*(Foret==1))>0
        Recap[Temp]=2+i
    #add infinite distance class 
    dmin = int(HarvClass_list[nbclass-1])
    label.append(QCoreApplication.translate("MainWindow","Accessible - Skidding class ")+str(nbclass)+" : > "+str(dmin)+" m")
    Temp = ((Dtotal>=dmin)*(Foret==1))>0
    Recap[Temp]=2+nbclass
    #Get area too slopy for harvesting
    Temp = load_float_raster_simple(Rspace_s+'Manual_harvesting.tif')
    Temp = ((Temp!=1)*(Foret==1))>0
    Recap[Temp]=2
    #Save as Gtiff
    ArrayToGtiff(Recap,Dir_temp+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    #Convert to shape
    type_mapping = { gdal.GDT_Byte: ogr.OFTInteger,
                 gdal.GDT_UInt16: ogr.OFTInteger,   
                 gdal.GDT_Int16: ogr.OFTInteger,    
                 gdal.GDT_UInt32: ogr.OFTInteger,
                 gdal.GDT_Int32: ogr.OFTInteger,
                 gdal.GDT_Float32: ogr.OFTReal,
                 gdal.GDT_Float64: ogr.OFTReal,
                 gdal.GDT_CInt16: ogr.OFTInteger,
                 gdal.GDT_CInt32: ogr.OFTInteger,
                 gdal.GDT_CFloat32: ogr.OFTReal,
                 gdal.GDT_CFloat64: ogr.OFTReal}

    ds = gdal.Open(Dir_temp+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("GPKG")
    dst_ds = drv.CreateDataSource( Rspace_s+layer_name+".gpkg" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', type_mapping[srcband.DataType])
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds.FlushCache()
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
        feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()


def create_arrays_from_roads(source_shapefile,Extent,Csize):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #Recupere le driver
    #Get information from source shapefile
    source_ds = ogr.Open(source_shapefile)
    source_layer = source_ds.GetLayer()    
    source_type = source_layer.GetGeomType()
    source_srs = source_layer.GetSpatialRef()
    ###################################################
    ###                                                      __     __ __       
    ###.----.-----.-----.-----.---.-.--.--.    .-----.--.--.|  |--.|  |__|.----.
    ###|   _|  -__|__ --|  -__|  _  |  |  |    |  _  |  |  ||  _  ||  |  ||  __|
    ###|__| |_____|_____|_____|___._|_____|    |   __|_____||_____||__|__||____|
    ###                                        |__|                                 
    expression = '"CL_SVAC" = 3'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Res_pub = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###                   __               ___                          __   __                   
    ###.----.-----.--.--.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|   _|  _  |  |  ||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|__| |_____|_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
                                                                                           
    expression = '"CL_SVAC" = 2'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Route_For = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###        __         __               ___                          __   __                   
    ###.-----.|__|.-----.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|  _  ||  ||__ --||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|   __||__||_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
    ###|__|                                                                                       
    expression = '"CL_SVAC" = 1'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Piste = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    source_ds.Destroy()    
    return Res_pub,Route_For,Piste


def prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder):
    console_info(QCoreApplication.translate("MainWindow","Pre-processing of the inputs for skidder model"))
    ### Make directory for temporary files
    Dir_temp = Wspace+"Temp/"
    try:os.mkdir(Dir_temp)
    except:pass 
    Rspace_s = Rspace+"Skidder/"
    try:os.mkdir(Rspace_s)
    except:pass
    ##############################################################################################################################################
    ### Initialization
    ##############################################################################################################################################
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    ##############################################################################################################################################
    ### Forest : shapefile to raster
    ##############################################################################################################################################
    Foret = shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET")
    np.save(Dir_temp+"Foret",np.int8(Foret))    
    del Foret
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Forest raster processed"))
        
    ##############################################################################################################################################
    ### Calculation of a slope raster and a cost raster of slope
    ##############################################################################################################################################
    # Slope raster
    MNT,Extent,Csize,_ = load_float_raster(file_MNT,Dir_temp)
    np.save(Dir_temp+"MNT",np.float32(MNT))
    Pente = pente(MNT,Csize,-9999)
    np.save(Dir_temp+"Pente",np.float32(Pente))    
    # Cost raster of slope
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    np.save(Dir_temp+"Pond_pente",np.float32(Pond_pente))
    # Report a success message   
    del Pente,MNT
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Slope raster processed")  )
    ##############################################################################################################################################
    ### Road network processing
    ##############################################################################################################################################
    Res_pub,Route_for,Piste= create_arrays_from_roads(file_shp_Desserte,Extent,Csize)
    np.save(Dir_temp+"Res_pub",Res_pub)  
    ##############################################################################################################################################
    ### Forest road network processing
    ##############################################################################################################################################
    pixels = np.argwhere(Res_pub==1) 
    # Give an identifiant to each public network pixel    
    ID = 1    
    Tab_res_pub = np.zeros((pixels.shape[0]+1,2),dtype=np.int32) 
    for pixel in pixels:
        Tab_res_pub[ID,0],Tab_res_pub[ID,1]=pixel[0],pixel[1]
        ID +=1         
    np.save(Dir_temp+"Tab_res_pub",Tab_res_pub)
    pixels = np.argwhere(Route_for==1)
    #num_ligne = id_RF, Y, X, Dtransp,Lien_Respub
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.float32)     
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=100001
        ID +=1 
    # Link RF with res_pub and calculate transportation distance
    Lien_RF=Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for,Res_pub, Lien_RF,Csize) 
    Lien_RF[:,2]=np.int_(Lien_RF[:,2]+0.5)
    Lien_RF=Lien_RF.astype('int')
    Temp = (Lien_RF[:,3]>0)*(Lien_RF[:,2]==0)
    Lien_RF=Lien_RF[Temp==0]    
    np.save(Dir_temp+"Lien_RF",Lien_RF)
    # Check if all Forest road are linked to public network    
    if np.max(Lien_RF[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_RF[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_RF[ind,0],Lien_RF[ind,1]]=1        
        ArrayToGtiff(RF_bad,Rspace_s+'Forest_road_not_connected',Extent,nrows,ncols,road_network_proj,0,'UINT8')
        console_info(QCoreApplication.translate("MainWindow","    - Some forest road are not connected to public network. To see where, check raster "+Rspace_s+"Forest_road_not_connected.tif"))
    else:
        console_info(QCoreApplication.translate("MainWindow","    - Forest road processed") )
            
    ##############################################################################################################################################
    ### Forest tracks network processing
    ##############################################################################################################################################
    # Tracks
    pixels = np.argwhere(Piste==1)
    #num_ligne = id_piste, Y, X, Dpiste,Dtransp,Lien_RF, Lien_Respub,
    Lien_piste = np.zeros((pixels.shape[0]+1,7),dtype=np.float32)    
    ID = 1
    for pixel in pixels:
        Lien_piste[ID,0],Lien_piste[ID,1]=pixel[0],pixel[1]
        Lien_piste[ID,4]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_piste[ID,2]=-9999
        else:
            Lien_piste[ID,2]=100001
        ID +=1
    Lien_piste=Link_tracks_res_pub(Tab_res_pub,Lien_RF,Pond_pente,Piste,Route_for,Res_pub,Lien_piste,Csize)
    Lien_piste[:,2]=np.int_(Lien_piste[:,2]+0.5)
    Lien_piste=Lien_piste.astype('int')
    Temp = (Lien_piste[:,5]>0)*(Lien_piste[:,2]==0)
    Lien_piste=Lien_piste[Temp==0]    
    ind = np.lexsort((Lien_piste[:,1],Lien_piste[:,2]))
    Lien_piste=Lien_piste[ind]
    np.save(Dir_temp+"Lien_piste",Lien_piste) 
    if np.max(Lien_piste[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_piste[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_piste[ind,0],Lien_piste[ind,1]]=1   
            Piste[Lien_piste[ind,0],Lien_piste[ind,1]]=0
            ArrayToGtiff(RF_bad,Rspace_s+'Forest_tracks_not_connected',Extent,nrows,ncols,road_network_proj,0,'UINT8')
            console_info(QCoreApplication.translate("MainWindow","    - Some forest tracks are not connected to public network or forest road."))
            console_info(QCoreApplication.translate("MainWindow","      To see where, check raster "+Rspace_s+"Forest_tracks_not_connected.tif"))
    else:
        console_info(QCoreApplication.translate("MainWindow","    - Forest tracks processed"))  
    Route_for[Res_pub==1]=0
    Piste[Res_pub==1]=0
    np.save(Dir_temp+"Route_for",Route_for) 
    np.save(Dir_temp+"Piste",np.int8(Piste))
    del Tab_res_pub,Lien_RF,Lien_piste,Res_pub  
    gc.collect()     
    ##############################################################################################################################################
    ### Create a raster of total obstacle for skidder
    ##############################################################################################################################################
    if Dir_Full_Obs_skidder!="":
        Full_Obstacles_skidder = prepa_obstacle_skidder(Dir_Full_Obs_skidder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))
    else:
        Full_Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Full_Obstacles_skidder",np.int8(Full_Obstacles_skidder))  
    console_info(QCoreApplication.translate("MainWindow","    - Skidder total obstacle raster processed"))
    ##############################################################################################################################################
    ### Create a raster of partial obstacle for skidder
    ##############################################################################################################################################
    if Dir_Partial_Obs_skidder!="":
        Partial_Obstacles_skidder = prepa_obstacle_skidder(Dir_Partial_Obs_skidder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))        
    else:
        Partial_Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Partial_Obstacles_skidder",np.int8(Partial_Obstacles_skidder))  
    console_info(QCoreApplication.translate("MainWindow","    - Skidder partial obstacle raster processed"))
    console_info(QCoreApplication.translate("MainWindow","Input data processing achieved"))
    ##############################################################################################################################################
    ### Close the script
    ##############################################################################################################################################
    clear_big_nparray()
    gc.collect()

