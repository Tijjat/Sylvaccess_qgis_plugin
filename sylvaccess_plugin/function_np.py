"""
/***************************************************************************
 function_np
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import numpy as np

global g
g = 9.80665

####################################################################
#  ______ ____    ____ .___________. __    __    ______   .__   __.# 
# /      |\   \  /   / |           ||  |  |  |  /  __  \  |  \ |  |#
#|  ,----' \   \/   /  `---|  |----`|  |__|  | |  |  |  | |   \|  |# 
#|  |       \_    _/       |  |     |   __   | |  |  |  | |  . `  |# 
#|  `----.    |  |         |  |     |  |  |  | |  `--'  | |  |\   |# 
# \______|    |__|         |__|     |__|  |__|  \______/  |__| \__|# 
####################################################################                                                                  


def dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4):
    a = 1. / (Th * Th) * (
            -Tv * Tv / rac1 + (Tv - F - W) * (Tv - F - W) / rac2 -
            (Tv - F - W * s1 / Lo) * (Tv - F - W * s1 / Lo) / rac3 +
            (Tv - W * s1 / Lo) * (Tv - W * s1 / Lo) / rac4
    )
    a += np.sqrt(1 + (Tv / Th) * (Tv / Th)) - np.sqrt(1 + ((Tv - F - W) / Th) * ((Tv - F - W) / Th)) + \
         np.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th) * ((Tv - F - W * s1 / Lo) / Th)) - \
         np.sqrt(1 + ((Tv - W * s1 / Lo) / Th) * ((Tv - W * s1 / Lo) / Th))
    a *= Lo / W
    return a


def double_max(a, b):
    return a if a >= b else b


def int_max(a, b):
    return a if a >= b else b


def double_min(a, b):
    return a if a <= b else b


def pente(raster_mnt, Csize, nodata):
    nline, ncol = raster_mnt.shape
    pente = np.zeros_like(raster_mnt, dtype=np.float32)

    for y in range(1, nline-1):
        for x in range(1, ncol-1):
            e = raster_mnt[y, x]
            if e > nodata:
                a, b, c, d, f, g, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                          raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                          raster_mnt[y + 1, x], raster_mnt[y + 1, x + 1])
                if a == nodata: a = e
                if b == nodata: b = e
                if c == nodata: c = e
                if d == nodata: d = e
                if f == nodata: f = e
                if g == nodata: g = e
                if h == nodata: h = e
                if i == nodata: i = e
                dz_dx = float(c + 2*f + i - (a + 2*d + g)) / float(8 * Csize)
                dz_dy = float(g + 2*h + i - (a + 2*b + c)) / float(8 * Csize)
                pente[y, x] = np.sqrt(dz_dx * dz_dx + dz_dy * dz_dy) * 100
            else:
                pente[y, x] = nodata

    # Coins sup gauche
    if raster_mnt[0,0]>nodata:
        e = raster_mnt[0,0]
        f = raster_mnt[0,1]
        if f==nodata:f=e
        h = raster_mnt[1,0]
        if h==nodata:h=e
        i = raster_mnt[1,1]
        if i==nodata:i=e
        dz_dx = float(f+i-(e+h))/float(2*Csize)
        dz_dy = float(h+i-(d+f))/float(2*Csize)
        pente[0,0]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100      
    else: pente[0, 0] = nodata
        # Coin inferieur gauche    
    if raster_mnt[nline-1,0]>nodata:
        e = raster_mnt[nline-1,0]
        b = raster_mnt[nline-2,0]
        if b==nodata:b=e
        c = raster_mnt[nline-2,1]
        if c==nodata:c=e
        f = raster_mnt[nline-1,1]
        if f==nodata:f=e
        dz_dx = float(c+f-(b+e))/float(2*Csize)
        dz_dy = float(e+f-(b+c))/float(2*Csize)
        pente[nline-1,0]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100       
    else: pente[nline-1,0]=nodata 
    # Coin superieur droite
    if raster_mnt[0,ncol-1]>nodata:
        e = raster_mnt[0,ncol-1]
        d = raster_mnt[0,ncol-2]
        if d==nodata:d=e
        g = raster_mnt[1,ncol-2]
        if g==nodata:g=e
        h = raster_mnt[1,ncol-1]
        if h==nodata:h=e
        dz_dx = float(e+h-(d+g))/float(2*Csize)
        dz_dy = float(g+h-(d+e))/float(2*Csize)
        pente[0,ncol-1]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100      
    else: pente[0,ncol-1]=nodata
    # Coin inferieur droite
    if raster_mnt[nline-1,ncol-1]>nodata:
        e = raster_mnt[nline-1,ncol-1]
        a = raster_mnt[nline-2,ncol-2]
        if a==nodata:a=e
        d = raster_mnt[nline-1,ncol-2]
        if d==nodata:d=e
        b = raster_mnt[nline-2,ncol-1]
        if b==nodata:b=e
        dz_dx = float(e+b-(d+a))/float(2*Csize)
        dz_dy = float(d+e-(a+b))/float(2*Csize)
        pente[nline-1,ncol-1]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100       
    else: pente[nline - 1, ncol - 1] = nodata
    # Pour premiere ligne
    x=1
    for x in range( 1 <= x < ncol-1):
        e = raster_mnt[0,x] 
        if e > nodata:            
            d = raster_mnt[0,x-1]    
            if d==nodata:d=e
            f = raster_mnt[0,x+1]
            if f==nodata:f=e
            g = raster_mnt[1,x-1]  
            if g==nodata:g=e
            h = raster_mnt[1,x] 
            if h==nodata:h=e
            i = raster_mnt[1,x+1]
            if i==nodata:i=e                            
            dz_dx = float(f+i-(d+g))/float(4*Csize)
            dz_dy = float(g+h+i-(d+e+f))/float(3*Csize)
            pente[0,x]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[0,x]=nodata
    # Pour derniere ligne
    for x in range (1 <= x < ncol-1):
        e = raster_mnt[nline-1,x] 
        if e > nodata:            
            d = raster_mnt[nline-1,x-1]    
            if d==nodata:d=e
            f = raster_mnt[nline-1,x+1]
            if f==nodata:f=e
            a = raster_mnt[nline-2,x-1]  
            if a==nodata:a=e
            b = raster_mnt[nline-2,x] 
            if b==nodata:b=e
            c = raster_mnt[nline-2,x+1]
            if c==nodata:c=e                            
            dz_dx = float(f+c-(d+a))/float(4*Csize)
            dz_dy = float(d+e+f-(a+b+c))/float(3*Csize)
            pente[nline-1,x]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[nline-1,x]=nodata
    # Pour premiere colonne
    for y in range (1 <= x < nline-1):
        e = raster_mnt[x,0] 
        if e > nodata:            
            b = raster_mnt[x+1,0]    
            if b==nodata:b=e
            c = raster_mnt[x+1,1]
            if c==nodata:c=e
            f = raster_mnt[x,1]  
            if f==nodata:f=e
            h = raster_mnt[x+1,0] 
            if h==nodata:h=e
            i = raster_mnt[x+1,1]
            if i==nodata:i=e                            
            dz_dx = float(c+f+i-(b+e+h))/float(3*Csize)
            dz_dy = float(h+i-(b+c))/float(4*Csize)
            pente[x,0]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[x,0]=nodata
    # Pour derniere colonne
    for x in range (1 <= x < nline-1):
        e = raster_mnt[x,ncol-1] 
        if e > nodata:            
            a = raster_mnt[x-1,ncol-2]    
            if a==nodata:a=e
            b = raster_mnt[x-1,ncol-1]
            if b==nodata:b=e
            d = raster_mnt[x,ncol-2]  
            if d==nodata:d=e
            g = raster_mnt[x+1,ncol-2] 
            if g==nodata:g=e
            h = raster_mnt[x+1,ncol-1]
            if h==nodata:h=e                            
            dz_dx = float(b+e+h-(a+d+g))/float(3*Csize)
            dz_dy = float(h+g-(b+a))/float(4*Csize)
            pente[x,ncol-1]= np.sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[x,ncol-1]=nodata

    return pente


def exposition(raster_mnt, Csize, nodata):
    nline, ncol = raster_mnt.shape
    expo = np.zeros_like(raster_mnt, dtype=np.float32)

    for y in range(1, nline-1):
        for x in range(1, ncol-1):
            e = raster_mnt[y, x]
            if e > nodata:
                a, b, c, d, f, g, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                          raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                          raster_mnt[y+1, x], raster_mnt[y+1, x+1])
                dz_dx = float(c + 2*f + i - (a + 2*d + g)) / float(8 * Csize)
                dz_dy = float(g + 2*h + i - (a + 2*b + c)) / float(8 * Csize)
                expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
                if a == nodata: a = e
                if b == nodata: b = e
                if c == nodata: c = e
                if d == nodata: d = e
                if f == nodata: f = e
                if g == nodata: g = e
                if h == nodata: h = e
                if i == nodata: i = e
                if expo1 < 0.:
                    expo[y, x] = 90.0 - expo1
                elif expo1 > 90.:
                    expo[y, x] = 360.0 - expo1 + 90.0
                else:
                    expo[y, x] = 90.0 - expo1
            else:
                expo[y, x] = nodata

    # Coins
    # Coin sup gauche
    if raster_mnt[0,0]>nodata:
        e = raster_mnt[0,0]
        f = raster_mnt[0,1]
        if f==nodata:f=e
        h = raster_mnt[1,0]
        if h==nodata:h=e
        i = raster_mnt[1,1]
        if i==nodata:i=e
        dz_dx = float(f+i-(e+h))/float(2*Csize)
        dz_dy = float(h+i-(d+f))/float(2*Csize)
        expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[0,0]= 90.0 - expo1
        elif expo1>90.:
            expo[0,0]= 360.0 - expo1 + 90.0
        else:
            expo[0,0]= 90.0 - expo1    
    else: expo[0,0]=nodata
        # Coin inferieur gauche    
    if raster_mnt[nline-1,0]>nodata:
        e = raster_mnt[nline-1,0]
        b = raster_mnt[nline-2,0]
        if b==nodata:b=e
        c = raster_mnt[nline-2,1]
        if c==nodata:c=e
        f = raster_mnt[nline-1,1]
        if f==nodata:f=e
        dz_dx = float(c+f-(b+e))/float(2*Csize)
        dz_dy = float(e+f-(b+c))/float(2*Csize)
        expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[nline-1,0]= 90.0 - expo1
        elif expo1>90.:
            expo[nline-1,0]= 360.0 - expo1 + 90.0
        else:
            expo[nline-1,0]= 90.0 - expo1          
    else: expo[nline-1,0]=nodata 
    # Coin superieur droite
    if raster_mnt[0,ncol-1]>nodata:
        e = raster_mnt[0,ncol-1]
        d = raster_mnt[0,ncol-2]
        if d==nodata:d=e
        g = raster_mnt[1,ncol-2]
        if g==nodata:g=e
        h = raster_mnt[1,ncol-1]
        if h==nodata:h=e
        dz_dx = float(e+h-(d+g))/float(2*Csize)
        dz_dy = float(g+h-(d+e))/float(2*Csize)
        expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[0,ncol-1]= 90.0 - expo1
        elif expo1>90.:
            expo[0,ncol-1]= 360.0 - expo1 + 90.0
        else:
            expo[0,ncol-1]= 90.0 - expo1           
    else: expo[0,ncol-1]=nodata
    # Coin inferieur droite
    if raster_mnt[nline-1,ncol-1]>nodata:
        e = raster_mnt[nline-1,ncol-1]
        a = raster_mnt[nline-2,ncol-2]
        if a==nodata:a=e
        d = raster_mnt[nline-1,ncol-2]
        if d==nodata:d=e
        b = raster_mnt[nline-2,ncol-1]
        if b==nodata:b=e
        dz_dx = float(e+b-(d+a))/float(2*Csize)
        dz_dy = float(d+e-(a+b))/float(2*Csize)
        expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[nline-1,ncol-1]= 90.0 - expo1
        elif expo1>90.:
            expo[nline-1,ncol-1]= 360.0 - expo1 + 90.0
        else:
            expo[nline-1,ncol-1]= 90.0 - expo1 
    else: expo[nline-1,ncol-1]=nodata
    # Pour premiere ligne
    x=1
    for x in range(1,ncol-1):
        e = raster_mnt[0,x] 
        if e > nodata:            
            d = raster_mnt[0,x-1]    
            if d==nodata:d=e
            f = raster_mnt[0,x+1]
            if f==nodata:f=e
            g = raster_mnt[1,x-1]  
            if g==nodata:g=e
            h = raster_mnt[1,x] 
            if h==nodata:h=e
            i = raster_mnt[1,x+1]
            if i==nodata:i=e                            
            dz_dx = float(f+i-(d+g))/float(4*Csize)
            dz_dy = float(g+h+i-(d+e+f))/float(3*Csize)
            expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[0,x]= 90.0 - expo1
            elif expo1>90.:
                expo[0,x]= 360.0 - expo1 + 90.0
            else:
                expo[0,x]= 90.0 - expo1 
        else: expo[0,x]=nodata
    # Pour derniere ligne
    x=1
    for x in range(1,ncol-1):
        e = raster_mnt[nline-1,x] 
        if e > nodata:            
            d = raster_mnt[nline-1,x-1]    
            if d==nodata:d=e
            f = raster_mnt[nline-1,x+1]
            if f==nodata:f=e
            a = raster_mnt[nline-2,x-1]  
            if a==nodata:a=e
            b = raster_mnt[nline-2,x] 
            if b==nodata:b=e
            c = raster_mnt[nline-2,x+1]
            if c==nodata:c=e                            
            dz_dx = float(f+c-(d+a))/float(4*Csize)
            dz_dy = float(d+e+f-(a+b+c))/float(3*Csize)
            expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[nline-1,x]= 90.0 - expo1
            elif expo1>90.:
                expo[nline-1,x]= 360.0 - expo1 + 90.0
            else:
                expo[nline-1,x]= 90.0 - expo1 
        else: expo[nline-1,x]=nodata
    # Pour premiere colonne
    y=1
    for y in range(1,nline-1):
        e = raster_mnt[y,0] 
        if e > nodata:            
            b = raster_mnt[y+1,0]    
            if b==nodata:b=e
            c = raster_mnt[y+1,1]
            if c==nodata:c=e
            f = raster_mnt[y,1]  
            if f==nodata:f=e
            h = raster_mnt[y+1,0] 
            if h==nodata:h=e
            i = raster_mnt[y+1,1]
            if i==nodata:i=e                            
            dz_dx = float(c+f+i-(b+e+h))/float(3*Csize)
            dz_dy = float(h+i-(b+c))/float(4*Csize)
            expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[y,0]= 90.0 - expo1
            elif expo1>90.:
                expo[y,0]= 360.0 - expo1 + 90.0
            else:
                expo[y,0]= 90.0 - expo1 
        else: expo[y,0]=nodata
    # Pour derniere colonne
    y=1
    for y in range(1,nline-1):
        e = raster_mnt[y,ncol-1] 
        if e > nodata:            
            a = raster_mnt[y-1,ncol-2]    
            if a==nodata:a=e
            b = raster_mnt[y-1,ncol-1]
            if b==nodata:b=e
            d = raster_mnt[y,ncol-2]  
            if d==nodata:d=e
            g = raster_mnt[y+1,ncol-2] 
            if g==nodata:g=e
            h = raster_mnt[y+1,ncol-1]
            if h==nodata:h=e                            
            dz_dx = float(b+e+h-(a+d+g))/float(3*Csize)
            dz_dy = float(h+g-(b+a))/float(4*Csize)
            expo1 = 57.29578 * np.arctan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[y,ncol-1]= 90.0 - expo1
            elif expo1>90.:
                expo[y,ncol-1]= 360.0 - expo1 + 90.0
            else:
                expo[y,ncol-1]= 90.0 - expo1 
        else: expo[y,ncol-1]=nodata

    return expo


def mask_zone(matrice):
    nline, ncol = matrice.shape
    top, bottom, left, right = nline, 0, ncol, 0

    for y in range(nline):
        for x in range(ncol):
            if matrice[y, x] > 0:
                top = min(top, y)
                bottom = max(bottom, y)
                left = min(left, x)
                right = max(right, x)

    return top, bottom, left, right


def calcul_distance_de_cout(from_rast, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = from_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    h, b, l, r = mask_zone(from_rast)
    
    # Création des rasters de sortie
    Out_distance = np.ones_like(from_rast, dtype=np.int32) * Max_distance
    Out_alloc = np.ones_like(from_rast, dtype=np.int32) * -9999
    
    x1, y1 = l, h
    for y1 in range(h, b):
        for x1 in range(l, r):
            if from_rast[y1, x1] > 0:
                Out_distance[y1, x1] = 0
                Out_alloc[y1, x1] = from_rast[y1, x1]
                for y in range(max(0, y1-1), min(nline, y1+2)):
                    for x in range(max(0, x1-1), min(ncol, x1+2)):                        
                        if zone_rast[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag
                            else:
                                Dist = cost_rast[y, x] * direct
                            if Out_distance[y, x] > Dist:
                                Out_distance[y, x] = int(Dist + 0.5)                                
                                Out_alloc[y, x] = from_rast[y1, x1]
    
    # Traitement complet
    h, b, l, r = mask_zone(zone_rast)
    dist_ac = Csize
    count_sans_match = 0
    
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        test = 0
        y1, x1 = h, l
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1   
                    for y in range(max(0, y1-1), min(nline, y1+2)):
                        for x in range(max(0, x1-1), min(ncol, x1+2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] > Dist:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    Out_alloc[y, x] = Out_alloc[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
    
    for y in range(nline):
        for x in range(ncol):
            if Out_distance[y, x] == Max_distance:
                Out_distance[y, x] = -9999
                Out_alloc[y, x] = -9999
    
    return Out_distance, Out_alloc


def focal_stat_nb(raster, nodata, cote):
    nline, ncol = raster.shape
    rnb = np.ones_like(raster, dtype=np.float32) * nodata
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                nb, y, x = 0.0, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            nb += 1.0
                
                rnb[y1, x1] = nb
    
    return rnb


def focal_stat_max(raster, nodata, cote):
    nline, ncol = raster.shape
    rmax = np.ones_like(raster, dtype=np.float32) * nodata
    min_value = np.min(raster[raster != nodata])
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                local_max, y, x = min_value, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            local_max = max(local_max, raster[y, x])
                
                rmax[y1, x1] = local_max
    
    return rmax


def get_npix(az, npix, coordY, coordX, ncols, nrows, Row_line, Col_line):
    for i in range(npix):
        x = Col_line[az, i] + coordX
        if x < 0 or x >= ncols:
            break
        y = Row_line[az, i] + coordY
        if y < 0 or y >= nrows:
            break
    return i


def get_line_carac_simple(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv):
    i = 0
    nfor = 0
    Dmoy_car = 0
    Forest_area = 0

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0:
            i += 1
            continue
        if x >= ncols:
            i += 1
            continue
        y = Row_ext[az, i] + coordY
        if y < 0:
            i += 1
            continue
        if y >= nrows:
            i += 1
            continue
        if Forest[y, x] == 1:
            nfor += 1
            Dmoy_car += D_ext[az, i]
            Rast_couv[y, x] = 1
        i += 1

    if nfor > 0:
        Forest_area = nfor * Csize * Csize
        Dmoy_car = Dmoy_car / nfor
    else:
        Dmoy_car = D_ext[az, i]

    return int(Dmoy_car), int(Forest_area), Rast_couv


def Check_line(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, D_lat, Rast_couv, debut, recouv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.zeros((nrows, ncols), dtype=np.int8)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0:
            i += 1
            continue
        if x >= ncols:
            i += 1
            continue
        y = Row_ext[az, i] + coordY
        if y < 0:
            i += 1
            continue
        if y >= nrows:
            i += 1
            continue
        if Rast_couv[y, x] == 0:
            if D_ext[az, i] < debut:
                Rast_couv_bis[y, x] = 2
                nb2 += 1
            else:
                if float(D_lat[az, i]) < float(recouv):  # Ensure consistent types
                    Rast_couv_bis[y, x] = 1
                    nb1 += 1
                else:
                    Rast_couv_bis[y, x] = 2
                    nb2 += 1
        elif Rast_couv[y, x] == 1:
            test = 0
            break
        else:
            nb2 += 1
        i += 1

    # Check if the line is really important
    if test and nb1 >= (nb1 + nb2) * rapport:
        Rast_couv = Rast_couv + Rast_couv_bis
    else:
        test = 0

    return test, Rast_couv


def Check_line2(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, D_lat, Rast_couv, recouv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.zeros((nrows, ncols), dtype=np.int8)
    debut = min(100, Lline * 0.4)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if 0 <= x < ncols:
            y = Row_ext[az, i] + coordY
            if 0 <= y < nrows:
                Rast_couv_bis[y, x] = 1
                if Rast_couv[y, x] == 0:
                    nb1 += 1
                elif Rast_couv[y, x] > 1 and D_ext[az, i] > debut and D_lat[az, i] < recouv:
                    test = 0
                    break
                else:
                    nb2 += 1
        i += 1

    if test and nb1 >= (nb1 + nb2) * rapport:
        Rast_couv += Rast_couv_bis
    else:
        test = 0

    return test, Rast_couv


def Check_line3(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Rast_couv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.copy(Rast_couv)
    debut = min(100, Lline * 0.4)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if 0 <= x < ncols:
            y = Row_ext[az, i] + coordY
            if 0 <= y < nrows:
                if Rast_couv[y, x] > 0:
                    Rast_couv_bis[y, x] -= 1
                if Rast_couv[y, x] == 1:
                    nb1 += 1
                elif Rast_couv[y, x] > 1:
                    if D_ext[az, i] > debut:
                        nb2 += 1
                    else:
                        nb1 += 1
        i += 1

    # Check if the line is really important
    if nb1 < (nb1 + nb2) * rapport:
        test = 0
        Rast_couv = Rast_couv_bis

    return test, Rast_couv


def df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4):
    a = (1.0 / Th) * (-Tv / rac1 + (Tv - F - W) / rac2 - (Tv - F - W * s1 / Lo) / rac3 + (Tv - W * s1 / Lo) / rac4)
    a += np.arcsinh(Tv / Th) - np.arcsinh((Tv - F - W) / Th) + np.arcsinh((Tv - F - W * s1 / Lo) / Th) - np.arcsinh((Tv - W * s1 / Lo) / Th)
    a *= Lo / W
    a += Lo / EAo
    return a


def f_x(Th, Tv, Lo, EAo, W, F, s1, D):
    x = Th * Lo / EAo - D
    x += Th * Lo / W * (
        np.arcsinh(Tv / Th)
        - np.arcsinh((Tv - F - W) / Th)
        + np.arcsinh((Tv - F - W * s1 / Lo) / Th)
        - np.arcsinh((Tv - W * s1 / Lo) / Th)
    )
    return x


def f_z(Th, Tv, Lo, EAo, W, F, s1, H):
    z = (W * Lo / EAo) * (Tv / W - 0.5) - H
    Temp = (
        np.sqrt(1 + (Tv / Th) ** 2)
        - np.sqrt(1 + ((Tv - F - W) / Th) ** 2)
        + (F * W / (Th * EAo)) * (s1 / Lo - 1)
    )
    Temp += np.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th) ** 2) - np.sqrt(1 + ((Tv - W * s1 / Lo) / Th) ** 2)
    z += Th * Lo / W * Temp
    return z


def calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s):
    x = Th * s / EAo
    x += Th * Lo / W * (
        np.arcsinh(Tv / Th)
        - np.arcsinh((Tv - F - W * s / Lo) / Th)
        + np.arcsinh((Tv - F - W * s1 / Lo) / Th)
        - np.arcsinh((Tv - W * s1 / Lo) / Th)
    )
    return x


def calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s):
    z = W * s / EAo * (Tv / W - s / (2 * Lo))
    Temp = (
        np.sqrt(1 + (Tv / Th))
        - np.sqrt(1 + ((Tv - F - W * s / Lo) / Th))
        + F * W / (Th * EAo) * (s1 / Lo - s / Lo)
    )
    Temp += np.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th)) - np.sqrt(1 + ((Tv - W * s1 / Lo) / Th))
    z += Th * Lo / W * Temp
    return z


def find_ThTvTmax(Tmax, W, EAo, F, pas, D, H, Lo, step=50):
    Fx_min = 0.05
    Gz_min = 0.05
    sum_min = 10.0
    Th = -1.0
    Tv = -1.0
    T = 1
    test = 0

    for i in range(0, int(Tmax), step):
        for j in range(0, int(Tmax), step):
            Fx = f_x(float(i), float(j), Lo, EAo, W, F, pas, D)
            if abs(Fx) < Fx_min:
                Gz = f_z(float(i), float(j), Lo, EAo, W, F, pas, H)
                if abs(Gz) < Gz_min:
                    if abs(Fx) + abs(Gz) < sum_min:
                        sum_min = min(abs(Fx) + abs(Gz), sum_min)
                        Th = float(i)
                        Tv = float(j)
                        if sum_min < 0.03:
                            test = 1
                            break
        if test == 1:
            break

    if np.sqrt(Th * Th + Tv * Tv) > Tmax:
        T = 0

    return Th, Tv, T


def newton_ThTv(Th, Tv, H, D, Lo, W, s1, F, EAo, Tmax, err=1.0):
    h = 100.0
    k = 100.0
    it = 0
    step = 100
    fo = 0
    go = 0
    rac1 = 0
    rac2 = 0
    rac3 = 0
    rac4 = 0
    dfTv = 0
    dfTh = 0
    dgTv = 0
    dgTh = 0
    coeff = 0
    Fx = 0
    Gz = 0
    Fx_min = 0.05
    Gz_min = 0.05
    sum_min = 10.0
    i = 0
    j = 0
    test = 0

    while abs(h) > err and abs(k) > err:
        fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
        go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
        rac1 = np.sqrt((Tv / Th) ** 2 + 1)
        rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
        rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
        rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
        dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
        dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
        dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
        dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
        coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
        h = coeff * (-dgTv * fo + dfTv * go)
        k = coeff * (dgTh * fo - dfTh * go)
        Th = Th + h
        Tv = Tv + k
        it += 1

        if min(Th, Tv) < 0:
            it = 0
            for i in range(1, np.ceil(Tmax), step):
                for j in range(0, np.ceil(Tmax), step):
                    Fx = f_x(float(i), float(j), Lo, EAo, W, F, s1, D)
                    if abs(Fx) < Fx_min:
                        Gz = f_z(float(i), float(j), Lo, EAo, W, F, s1, H)
                        if abs(Gz) < Gz_min:
                            if abs(Fx) + abs(Gz) < sum_min:
                                sum_min = min(abs(Fx) + abs(Gz), sum_min)
                                Th = float(i)
                                Tv = float(j)
                                if sum_min < 0.03:
                                    test = 1
                                    break
                if test:
                    break

        if it > 20:
            break

    return Th, Tv


def Tabmesh(d, E, Tmax, Lmax, Fo, q1, q2, q3, Csize):
    pas = 1
    ncol = int(np.ceil((Lmax + Csize) / pas - 1))
    nline = ncol + 1
    rastLosup = np.full((nline, ncol), np.nan, dtype=np.float32)
    rastTh = np.copy(rastLosup)
    rastTv = np.copy(rastLosup)
    col = 0
    lig = 0
    Hmax = 0
    Tvo = 0.1 * Tmax
    Tho = 0.9 * Tmax
    Lsupo = 0.0
    D = 0.0
    H = 0.0
    Tvprec = Tvo
    Thprec = Tho
    Lsup_prec = Lsupo
    diag = 0.0
    Lo = 0.0
    W = 0.0
    F = 0.0
    Th = 0.0
    Tv = 0.0
    Tcalc = 0.0
    incr = 0.0
    signe = 0.0

    EAo = 0.25 * np.pi * (d * d) * E

    for D in range(5, int(Lmax + Csize), pas):
        lig = 0
        Hmax = int(np.ceil(np.sqrt(Lmax * Lmax - D * D) + Csize))
        Tvprec = Tvo
        Thprec = Tho
        Lsup_prec = Lsupo

        for H in range(0, Hmax, pas):
            diag = np.sqrt(H ** 2 + D ** 2)
            Lo = diag + Lsup_prec
            W = q1 * 9.81 * Lo
            F = 0.5 * ((q2 + (Lo - D) * q3) + Fo) * 9.81

            Th, Tv = newton_ThTv(Thprec, Tvprec, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2, 0.1)

            # Check if Th, Tv are OK
            if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                Th, Tv = newton_ThTv(D / diag * Tmax, Tmax * (H / diag + 0.01), H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                    Th, Tv, _ = find_ThTvTmax(Tmax, W, EAo, F, Lo * 0.5, D, H, Lo, 20)
                    Th, Tv = newton_ThTv(Th, Tv, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                    if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                        continue

            # Find Lo so that Tcalc does not exceed Tmax
            Tcalc = np.sqrt(Th ** 2 + Tv ** 2)

            if np.ceil(Lsup_prec * 0.1) >= 1:
                incr = 1.0
            elif np.ceil(Lsup_prec) >= 1:
                incr = 0.1
            elif np.ceil(Lsup_prec * 10.0) >= 1:
                incr = 0.01
            else:
                incr = 0.001

            signe = (Tcalc - Tmax) / abs(Tcalc - Tmax)

            # Incrementation
            while abs(Tcalc - Tmax) > 10.0:
                Lo += signe * incr
                F = 0.5 * ((q2 + (Lo - D) * q3) + Fo) * 9.81
                W = q1 * 9.81 * Lo
                Th, Tv = newton_ThTv(Th, Tv, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                Tcalc = np.sqrt(Th ** 2 + Tv ** 2)

                if signe * (Tcalc - Tmax) < 0:
                    incr *= 0.1
                    signe *= -1.0

                if Lo > np.sqrt(H ** 2 + D ** 2) + 1000.0:
                    break

            if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                continue

            Tvprec = Tv
            Thprec = Th
            Lsup_prec = Lo - diag
            rastLosup[lig, col] = Lsup_prec
            rastTh[lig, col] = Th
            rastTv[lig, col] = Tv

            if H == 0:
                Tvo = Tv
                Tho = Th
                Lsupo = Lsup_prec

            lig += 1

        col += 1

    return rastLosup, rastTh, rastTv


def check_droite(fact, H, D, Xup, Zup, Line, Hline_min, Hline_max, Tmax, q1, q2, q3, Fo, pg, pd, Dsupdep=0., Dsupend=0.):
    test = 1
    L = np.sqrt(H**2 + D**2)
    F = (0.5 * ((0.5 * L + Dsupdep) * q2 + (0.5 * L + Dsupend) * q3)) * 9.80665 + Fo
    fleche = 1.1 * (F * L / (4 * Tmax) + q1 * 9.80665 * L**2 / (8 * Tmax))
    
    for i in range(pg + 1, pd):
        droite = -fact * H / D * (Line[i, 0] - Xup) + Zup - Line[i, 1]
        if droite < Hline_min:
            test = 0
            break
        if droite - fleche > Hline_max:
            test = 0
            break
    
    return test


def check_Hlinemin(Alts, H, D, Lo, fact, Tho, Tvo, Xup, Zup, Fo, Tmax, Hline_min, Hline_max, q1, q2, q3, Csize, EAo, Dsupdep=0., Dsupend=0.):
    end = Lo - 10.
    test = 1
    Th, Tv = Tho, Tvo
    W = g * q1 * Lo
    s1 = Lo * 0.5
    h, k = 100.0, 100.0
    it = 0
    err = 1.0
    
    while s1 > 10.:
        F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo

        # Newton Th Tv
        it = 0
        while abs(h) > err and abs(k) > err:
            fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
            go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
            rac1 = np.sqrt((Tv / Th) ** 2 + 1)
            rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
            rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
            rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
            dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
            dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
            dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
            dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
            coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
            h = coeff * (-dgTv * fo + dfTv * go)
            k = coeff * (dgTh * fo - dfTh * go)
            Th += h
            Tv += k
            it += 1
            if it > 20:
                break

        if abs(f_x(Th, Tv, Lo, EAo, W, F, s1, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, s1, H)) > 0.03:
            test = 0
            break

        xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s1)
        zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s1)
        ind = int(xcoord * 2 + 0.5)
        Hmin = zcoord - (Alts[ind] + Hline_min)

        if Hmin < 0 or Hmin + Hline_min > Hline_max or np.sqrt(Th ** 2 + Tv ** 2) > (Tmax + 1000):
            test = 0
            break
        s1 -= Csize

    if test:
        Th, Tv = Tho, Tvo
        middle = min(int(Lo * 0.5 + Csize), end)
        s1 = middle
        while s1 < end:
            F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo

            # Newton Th Tv
            h, k = 100.0, 100.0
            it = 0
            while abs(h) > err and abs(k) > err:
                fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
                go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
                rac1 = np.sqrt((Tv / Th) ** 2 + 1)


def Find_Lomin(D, H, Xup, Zup, fact, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Hline_min, Hline_max, Csize, Dsupdep=0., Dsupend=0.):
    h = 100.0
    err = 1.0
    error = 50.
    k = 100.0
    it = 0
    test = 1
    diag = np.sqrt(D * D + H * H)
    col = int_max(np.ceil(D - 5) - 1, 0)
    line = np.ceil(H)
    Lsup = rastLosup[line, col]
    Th = rastTh[line, col]
    Tv = rastTv[line, col]
    Lo = Lsup + diag
    W = q1 * g * Lo
    s1 = 0.5 * Lo
    F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
    Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
    xcoord, zcoord, Hmin = 0., 0., 0.

    if np.isnan(Th) or np.isnan(Tv):
        test = 0

    if test:
        # Newton Th Tv
        while abs(h) > err and abs(k) > err:
            fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
            go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
            rac1 = np.sqrt((Tv / Th) ** 2 + 1)
            rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
            rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
            rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
            dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
            dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
            dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
            dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
            coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
            h = coeff * (-dgTv * fo + dfTv * go)
            k = coeff * (dgTh * fo - dfTh * go)
            Th += h
            Tv += k
            it += 1
            if double_min(Th, Tv) < 0:
                test = 0
                break
            if it > 20:
                test = 0
                break

        if test:
            # Find Lo so that Tcalc does not exceed Tmax
            Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
            incr = 0.01
            signe = (Tcalc - Tmax) / abs(Tcalc - Tmax)

            # Incrementation
            while abs(Tcalc - Tmax) > error and test:
                Lo += signe * incr
                W = q1 * g * Lo
                s1 = Lo * 0.5
                F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
                h = 100.0
                k = 100.0
                it = 0

                # Newton Th Tv
                while abs(h) > err and abs(k) > err:
                    fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
                    go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
                    rac1 = np.sqrt((Tv / Th) ** 2 + 1)
                    rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
                    rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
                    rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
                    dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
                    dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
                    dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
                    dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
                    coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
                    h = coeff * (-dgTv * fo + dfTv * go)
                    k = coeff * (dgTh * fo - dfTh * go)
                    Th += h
                    Tv += k
                    it += 1

                    if double_min(Th, Tv) < 0:
                        test = 0
                        break
                    if it > 20:
                        test = 0
                        break

                Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
                if signe * (Tcalc - Tmax) < 0:
                    incr *= 0.1
                    signe *= -1.

                if abs(Lo - np.sqrt(H * H + D * D)) > 100.:
                    test = 0
                    break

    if test:
        F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
        xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, Lo * 0.5, Lo * 0.5)
        zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, Lo * 0.5, Lo * 0.5)
        ind = int(np.floor(xcoord * 2 + 0.5))
        Hmin = zcoord - (Alts[ind] + Hline_min)
        if Hmin >= 0:
            Hmin = check_Hlinemin(Alts, H, D, Lo, fact, Th, Tv, Xup, Zup, Fo, Tmax, Hline_min, Hline_max, q1, q2, q3, Csize, EAo, Dsupdep, Dsupend)
            if Hmin < 0:
                test = 0
    else:
        test = 0

    return test, Lo, Th, Tv, Tcalc, F


def test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep=0., slope_prev=-9999.):
    test = 0
    D = Line[posi, 0] - Line[pg, 0]
    H = np.abs(Line[pg, 1] + Hg - (Line[posi, 1] + Hd))
    Xup, Zup = 0, 0
    fact = 0
    diag, slope, Lo, Th, Tv, F, Tcalc = 0, 0, 0, 0, 0, 0, 0

    if Line[pg, 1] + Hg >= Line[posi, 1] + Hd:
        Xup, Zup = Line[pg, 0], Line[pg, 1] + Hg
        fact = 1.
    else:
        Xup, Zup = Line[posi, 0], Line[posi, 1] + Hd
        fact = -1.

    if check_droite(fact, H, D, Xup, Zup, Line, Hline_min, Hline_max, Tmax, q1, q2, q3, Fo, pg, posi, Dsupdep):
        diag = np.sqrt(H * H + D * D)
        slope = -1 * fact * np.arctan(H / D)

        if slope < slope_min or slope > slope_max:
            test = 0
        else:
            # Check slopes around intermediate support
            if slope_prev > -9999 and (np.abs(slope - slope_prev) >= angle_intsup or (slope * slope_prev < 0 and np.abs(slope - slope_prev) >= 0.1)):
                test = 0
            else:
                test, Lo, Th, Tv, Tcalc, F = Find_Lomin(D, H, Xup, Zup, fact, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Hline_min, Hline_max, Csize, Dsupdep)

    return test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F


def get_Tabis(Tab, lineTab, nbconfig, intsup, indmax):
    i, j = 0, 0
    col = (intsup - 1) * 14 + 13
    colH = (intsup - 1) * 14 + 12
    idmax = 0
    idmax2 = indmax + 1
    idline = 0
    linemax = min(lineTab, nbconfig)
    Tabis = np.zeros((linemax, Tab.shape[1]), dtype=np.float32)

    Hmin = 100

    while i < linemax:
        for j in range(0, lineTab):
            if idmax <= Tab[j, col] < idmax2:
                idmax = np.ceil(Tab[j, col])
                if Tab[j, colH] < Hmin:
                    Hmin = Tab[j, colH]
                    idline = j

        Tabis[i] = Tab[idline]
        i += 1
        idmax2 = idmax
        idmax = 0
        Hmin = 100

    return Tabis


def get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax):
    i, j = 0, 0
    col = (intsup - 1) * 15 + 13
    colH = (intsup - 1) * 15 + 12
    idmax = 0
    idmax2 = indmax + 1
    idline = 0
    linemax = min(lineTab, nbconfig)
    Tabis = np.zeros((linemax, Tab.shape[1]), dtype=np.float32)

    Hmin = 100

    while i < linemax:
        for j in range(0, lineTab):
            if idmax <= Tab[j, col] < idmax2:
                idmax = np.ceil(Tab[j, col])
                if Tab[j, colH] < Hmin:
                    Hmin = Tab[j, colH]
                    idline = j

        Tabis[i] = Tab[idline]
        i += 1
        idmax2 = idmax
        idmax = 0
        Hmin = 100

    return Tabis


def OptPyl_Up(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
              angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
              slope_max, test_hfor, nbconfig=10):
    indmax = Line.shape[0] - 1
    test = 0
    D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    # Begin without intermediate support
    Hd = Line[indmax, 7] if test_hfor else Hend
    while Hd > 1:
        test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hd,
                                                                                 Hline_min, Hline_max,
                                                                                 slope_min, slope_max, Alts, Fo, Tmax, q1,
                                                                                 q2, q3, EAo, rastLosup, rastTh, rastTv,
                                                                                 Csize, angle_intsup, 0, slope_prev=-9999)
        if test:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
                Th * Th + (Tv - F - Lo * g * q1) ** 2)
            Span[0, 14], Span[0, 15] = Hd, indmax
            test = 1
        else:
            break
        Hd -= 1

    # Cut the line if no intermediate support allowed
    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hd = Line[posi, 7] if test_hfor else Hend
            while Hd > 1:
                test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd,
                                                                                         Hline_min, Hline_max,
                                                                                         slope_min, slope_max, Alts, Fo,
                                                                                         Tmax, q1, q2, q3, EAo, rastLosup,
                                                                                         rastTh, rastTv, Csize,
                                                                                         angle_intsup, 0, slope_prev=-9999)
                if test:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
                        Th * Th + (Tv - F - Lo * g * q1) ** 2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                else:
                    break
                Hd -= 1
            if test:
                break

    # Start intermediate support position optimization
    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * nbconfig * 100, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -14):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]
                for posi in range(indmaxmulti, indmin, -1):
                    if test_hfor:
                        Hdmax = Line[indmax, 7]
                    else:
                        Hdmax = Hend
                    Hd = 1
                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                            Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo,
                            newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                        if test1:
                            Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                                Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1
                            if test_hfor:
                                Hdmax2 = Line[indmax, 7]
                            else:
                                Hdmax2 = Hend
                            Hd2 = 1
                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                    Line, posi, indmax, Hd, Hd2, Hline_min, Hline_max, slope_min, slope_max,
                                    Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize,
                                    angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                                        Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break
                                Hd2 += 1
                            if best:
                                break
                        Hd += 1
                    if best:
                        break
                if best:
                    break
            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2
                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0
                    break
                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]
                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * nbconfig * 100, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break
    # Cut the line at the farthest position if sup_max > 0
    if not best and test:
        lineTab = 0
        for p in range(0, nblineTabis):
            lineTabis = p
            col = (intsup - 2) * 14
            pg = np.ceil(Tabis[p, 13 + col])
            Hg = Tabis[p, 12 + col]
            indminmulti = pg
            diff = 0.
            while diff < double_max(Csize, LminSpan):
                indminmulti += 1
                diff = Line[indminmulti, 0] - Line[pg, 0]
            newTmax = Tabis[p, 10 + col]
            Dsupdep = 0
            for c in range(col + 2, 1, -14):
                Dsupdep += Tabis[p, c]
            slope_prev = Tabis[p, 3 + col]
            for posi in range(indmax - 1, indminmulti - 1, -1):
                if test_hfor:
                    Hdmax = Line[indmax, 7]
                else:
                    Hdmax = Hend
                Hd = 1
                while Hd <= Hdmax:
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                        Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1,
                        q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                    if test1:
                        Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break
                    Hd += 1
        if lineTab == 0:
            intsup -= 2
            lineTab = 0
            Tab[lineTab] = Tabis[0]
        else:
            Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
            lineTab = 0
            intsup = sup_max

    # Save Span characteristics
    for i in range(0, intsup + 1):
        col = i * 14
        Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up_NoH(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                  angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                  slope_max, test_hfor, nbconfig=10):
    """
    Cable machine en haut
    Optimise le placement des pylones intermediaire sans bouger la hauteur de fixation du cable Forwarder pour chaque pylone sur un profil
    """

    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hd = Line[posi, 7] if test_hfor else Hend
            test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd,
                                                                                    Hline_min, Hline_max, slope_min,
                                                                                    slope_max, Alts, Fo, Tmax, q1, q2, q3,
                                                                                    EAo, rastLosup, rastTh, rastTv, Csize,
                                                                                    angle_intsup, 0, slope_prev=-9999)
            if test0:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hd, posi
                test = 1

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -14):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hd = Line[posi, 7]
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, 0,
                                                                                              slope_prev=-9999)
                    if test1:
                        Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1

                        if test_hfor:
                            Hd2 = Line[indmax, 7]
                        else:
                            Hd2 = Hend

                        test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Hd2,
                                                                                                  Hline_min, Hline_max,
                                                                                                  slope_min, slope_max,
                                                                                                  Alts, Fo, Tdown, q1, q2,
                                                                                                  q3, EAo, rastLosup, rastTh,
                                                                                                  rastTv, Csize,
                                                                                                  angle_intsup,
                                                                                                  diag + Dsupdep, slope)
                        if test2:
                            best = 1
                            Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                            Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                                Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                            break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = np.ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down_init(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                     angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                     slope_max, test_hfor, nbconfig=5):
    """
    Cable machine en bas
    Permet de recuperer la partie de profil ou il est possible de tendre un cable (avec hauteur de cable Forwarder variable)
    """

    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    while test and Hend > 1:
        Hend -= 1
        test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                                Hline_min, Hline_max, slope_min,
                                                                                slope_max, Alts, Fo, Tmax, q1, q2, q3,
                                                                                EAo, rastLosup, rastTh, rastTv, Csize,
                                                                                angle_intsup, 0, slope_prev=-9999)
        if test0:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
            Span[0, 14], Span[0, 15] = Hend, indmax
            test = 1
        else:
            break

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hdmax = Line[posi, 7]
            Hd = np.ceil(Hline_min)
            while Hd <= Hdmax:
                test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
                if test1:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                    break
                Hd += 1
            if test:
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hd = 1

                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                        if test1:
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1

                            Hdmax2 = Line[indmax, 7] if test_hfor else Hend
                            Hd2 = 1

                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Hd2, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break

                                Hd2 += 1

                            if best:
                                break

                        Hd += 1

                    if best:
                        break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = np.ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down_init_NoH(Line, Alts, Span, Htower , Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                         angle_intsup, EAo,  sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                         slope_max, test_hfor, nbconfig=5):
    """
    Cable machine en bas
    Permet de recuperer la partie de profil ou il est possible de tendre un cable (avec hauteur de cable Forwarder fixe)
    """
    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
            Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            if test_hfor:
                Hd = Line[posi, 7]
            else:
                Hd = Hend
            test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd, Hline_min,
                                                                                    Hline_max, slope_min, slope_max, Alts,
                                                                                    Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                                    rastTh, rastTv, Csize, angle_intsup, 0,
                                                                                    slope_prev=-9999)
            if test1:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
                    Th * Th + (Tv - F - Lo * g * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hd, posi
                test = 1
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hd = 1

                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                                Hline_min, Hline_max,
                                                                                                slope_min, slope_max, Alts,
                                                                                                Fo, newTmax, q1, q2, q3,
                                                                                                EAo, rastLosup, rastTh,
                                                                                                rastTv, Csize,
                                                                                                angle_intsup, 0,
                                                                                                slope_prev=-9999)

                        if test1:
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1

                            Hdmax2 = Line[indmax, 7] if test_hfor else Hend
                            Hd2 = 1

                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi,
                                                                                                      indmax, Hd, Hd2,
                                                                                                      Hline_min,
                                                                                                      Hline_max,
                                                                                                      slope_min,
                                                                                                      slope_max, Alts,
                                                                                                      Fo, Tmax, q1,
                                                                                                      q2, q3, EAo,
                                                                                                      rastLosup, rastTh,
                                                                                                      rastTv, Csize,
                                                                                                      angle_intsup, 0,
                                                                                                      slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break

                                Hd2 += 1

                            if best:
                                break

                        Hd += 1

                    if best:
                        break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = np.ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up2(Line, Alts, Span, Htower,  Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
               angle_intsup, EAo,  sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
               slope_max, test_hfor, nbconfig=10):
    """
    Cable machine en bas
    Optimise le placement des pylones intermediaire et la hauteur de fixation du cable Forwarder pour chaque pylone sur un profil
        
    """
    indmax = Line.shape[0] - 1
    test = 0
    test0 = test1 = test2 = 0
    indminmulti = indmaxmulti = pg = posi = lineTab = lineTabis = 0
    intsup = best = nblineTabis = indmin = 0
    Hg = Hd = Tdown = Hgmax = Hdmax = Hginit = 0
    slope_prev = Dsupdep = newTmax = diff = 0.0
    
    # Begin without intermediate support
    if test_hfor:
        Hg = Line[indmax, 7]
    else:
        Hg = Hend
    while Hg > 1:
        test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
            Line, 0, indmax, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
        if test0:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th*Th + Tv*Tv), np.sqrt(Th*Th + (Tv - F - Lo*g*q1)**2)
            Span[0, 14], Span[0, 15] = Hg, indmax
            test = 1
        else:
            break
        Hg -= 1

    # End without intermediate support
    # Start Cut the line if no intermediate support allowed
    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            if test_hfor:
                Hd = Line[posi, 7]
            else:
                Hd = Hend
            while Hd > 1:
                test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                    Line, 0, posi, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
                if test0:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th*Th + Tv*Tv), np.sqrt(Th*Th + (Tv - F - Lo*g*q1)**2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                else:
                    break
                Hd -= 1
            if test:
                break

    # End Cut the line if no intermediate support allowed
    # Start intermediate support position optimization
    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 15 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0

        test = 1
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = 0

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 15
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -15):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]
                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hg = Hginit
                    while Hg <= Hgmax:
                        Hd = np.ceil(Hline_min)
                        while Hd <= Hdmax:
                            test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                            if test1:
                                Tdown = np.sqrt(Th*Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                                Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                                Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hg, posi, Hd
                                lineTab += 1
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                    Line, posi, indmax, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 15] = Tab[lineTab - 1, 0:intsup * 15]
                                    Tab[lineTab, intsup * 15:(intsup * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hd, indmax, Htower
                                    break
                            Hd += 1
                        if best:
                            break
                        Hg += 1
                    if best:
                        break
                if best:
                    break
            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2
                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0
                    break
                Tabis = get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]
                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float32)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0
            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 15
                pg = np.ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 14 + col]
                indminmulti = pg
                diff = 0.
                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]
                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0
                for c in range(col + 2, 1, -15):
                    Dsupdep += Tabis[p, c]
                slope_prev = Tabis[p, 3 + col]
                for posi in range(indmax - 1, indminmulti - 1, -1):
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                        Line, pg, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                    if test1:
                        Tdown = np.sqrt(Th*Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hg, posi, Htower
                        lineTab += 1

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]
            else:
                Tab = get_Tabis2(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 15
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up2_NoH(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                    angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                      slope_max, test_hfor, nbconfig=10):
    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2)
        Span[0, 14], Span[0, 15] = Line[indmax, 7] if test_hfor else Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.0
        while diff < Csize * LminSpan:
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]

        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hg = Line[posi, 7] if test_hfor else Hend
            test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
            if test0:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hg, posi
                test = 1
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.0
        while diff < Csize * LminSpan and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 15 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        test = 1
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hginit = Line[0, 7] if test_hfor else Hend
        best = 0
        slope_prev = -9999
        indmin = 0

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 15
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hginit = Tabis[p, 14 + col]

                    for c in range(col + 2, 1, -15):
                        Dsupdep += Tabis[p, c]

                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hd = Line[posi, 7]
                    Hg = Hginit
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                    if test1:
                        Tdown = np.sqrt(Th * Th + (Tv - q1 * 9.81 * Lo) * (Tv - q1 * 9.81 * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hg, posi, Hd
                        lineTab += 1
                        test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)

                        if test2:
                            best = 1
                            Tab[lineTab, 0:intsup * 15] = Tab[lineTab - 1, 0:intsup * 15]
                            Tab[lineTab, intsup * 15:(intsup * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hd, indmax, Htower
                            break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * nbconfig * Tabis.shape[0] * 100, 15 * (sup_max + 1)), dtype=np.float32)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 15
                pg = np.ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 14 + col]
                indminmulti = pg
                diff = 0.0

                while diff < Csize * LminSpan:
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -15):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                    if test1:
                        Tdown = np.sqrt(Th * Th + (Tv - q1 * 9.81 * Lo) * (Tv - q1 * 9.81 * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hg, posi, Htower
                        lineTab += 1

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]
            else:
                Tab = get_Tabis2(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 15
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down(Line, Alts, Span, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig=5):
    indmax = Line.shape[0] - 1
    i = -1
    j = sup_max
    Dmax = Line[indmax, 0]
    test = 0
    Spanbis = np.zeros_like(Span)

    while not test:
        indmax = Line.shape[0] - 1
        if indmax == 1:
            test = 0
            break

        Span = OptPyl_Up2(Line, Alts, Span * 0, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig)

        if np.max(Span[:, 15]) == indmax:
            test = 1
            break
        else:
            Line = Line[1:]

    if test:
        for j in range(sup_max, -1, -1):
            if Span[j, 0] > 0:
                break

        i = -1

        while j > -1:
            i += 1
            Spanbis[i] = Span[j]
            Spanbis[i, 5] = Dmax - Span[j, 5]
            Spanbis[i, 15] = indmax - Span[j - 1, 15]
            j -= 1

        Spanbis[i, 15] = indmax
        Spanbis[:, 4] *= -1

    return Spanbis


def OptPyl_Down_NoH(Line, Alts, Span, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig=5):
    indmax = Line.shape[0] - 1
    i = -1
    j = sup_max
    Dmax = Line[indmax, 0]
    test = 0
    Spanbis = np.zeros_like(Span)

    while not test:
        indmax = Line.shape[0] - 1
        if indmax == 1:
            test = 0
            break

        Span = OptPyl_Up2_NoH(Line, Alts, Span * 0, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig)

        if np.max(Span[:, 15]) == indmax:
            test = 1
            break
        else:
            Line = Line[1:]

    if test:
        for j in range(sup_max, -1, -1):
            if Span[j, 0] > 0:
                break

        i = -1

        while j > -1:
            i += 1
            Spanbis[i] = Span[j]
            Spanbis[i, 5] = Dmax - Span[j, 5]
            Spanbis[i, 15] = indmax - Span[j - 1, 15]
            j -= 1

        Spanbis[i, 15] = indmax
        Spanbis[:, 4] *= -1

    return Spanbis


def skid_debusq_RF(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                   coeff, orig, Pmax_up, Pmax_down, damont, daval,
                   nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_des = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = np.sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)
                coef_l = (Alt_pixel - Alt_RF) / Hdist

                if Out_distance[Y, X] > dist:
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / np.sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_des[Y, X] = pixel
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_des[coordY, coordX] = pixel

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_des[Y, X] = -9999

    return Out_distance, L_des


def skid_debusq_Piste(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                      coeff, orig, Pmax_up, Pmax_down, damont, daval,
                      nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_des = np.zeros((nrows, ncols), dtype=np.int32)
    Dpis = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0
        dpist = Lien_RF[pixel, 2]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = np.sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)
                coef_l = (Alt_pixel - Alt_RF) / Hdist

                if Out_distance[Y, X] > dist:
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / np.sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_des[Y, X] = pixel
                    Dpis[Y, X] = int(dpist + 0.5)
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_des[coordY, coordX] = pixel
            Dpis[coordY, coordX] = int(dpist + 0.5)

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_des[Y, X] = -9999
                Dpis[Y, X] = -9999

    return Out_distance, L_des, Dpis


def skid_debusq_contour(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                        coeff, orig, Pmax_up, Pmax_down, damont, daval,
                        nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_RF = np.zeros((nrows, ncols), dtype=np.int32)
    L_Piste = np.zeros((nrows, ncols), dtype=np.int32)
    Dpis = np.zeros((nrows, ncols), dtype=np.int32)
    Dfor = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX] 
        testRF = 0
        lienRF, lienPiste = Lien_RF[pixel, 2], Lien_RF[pixel, 3]
        dpist, dfor = Lien_RF[pixel, 5], Lien_RF[pixel, 4]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                coef_l = (Alt_pixel - Alt_RF) / Hdist
                dist = np.sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)

                if (Out_distance[Y, X] + Dpis[Y, X] + Dfor[Y, X]) > (dist + dpist + dfor):
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / np.sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_RF[Y, X] = lienRF 
                    L_Piste[Y, X] = lienPiste
                    Dpis[Y, X] = int(dpist + 0.5)
                    Dfor[Y, X] = int(dfor + 0.5)
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_RF[coordY, coordX] = lienRF 
            L_Piste[coordY, coordX] = lienPiste
            Dpis[coordY, coordX] = int(dpist + 0.5)
            Dfor[coordY, coordX] = int(dfor + 0.5)

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_RF[Y, X] = -9999
                L_Piste[Y, X] = -9999
                Dpis[Y, X] = -9999
                Dfor[Y, X] = -9999

    return Out_distance, L_RF, L_Piste, Dpis, Dfor


def seek_ind(Tab, x, y):
    nline = Tab.shape[0]
    y1 = 1
    ind = 1

    while y1 < nline:
        if Tab[y1, 0] == y:
            if Tab[y1, 1] == x:
                ind = y1
                break
        y1 += 1

    return ind


def seek_ind_i(Tab, x, y):
    nline = Tab.shape[0]
    y1 = 1
    ind = 1

    while y1 < nline:
        if Tab[y1, 0] == y:
            if Tab[y1, 1] == x:
                ind = y1
                break
        y1 += 1

    return ind


def Link_RF_res_pub(Tab_res_pub, cost_rast, RF, Res_pub, Link_RF, Csize, Max_distance=100000):
    nline, ncol = cost_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    dist_ac = Csize
    nb_pixel_res_pub = Tab_res_pub.shape[0]
    nb_pixel_RF = Link_RF.shape[0]
    pixel = 1

    while pixel < nb_pixel_res_pub:
        y1 = Tab_res_pub[pixel, 0]
        x1 = Tab_res_pub[pixel, 1]
        if RF[y1, x1] == 1:
            ind = seek_ind(Link_RF, x1, y1)
            Link_RF[ind, 2] = 0
            Link_RF[ind, 3] = pixel
            Link_RF[ind, 4] = 1
        pixel += 1

    while dist_ac <= Max_distance:
        test = 0
        pixel = 1
        while pixel < nb_pixel_RF:
            if Link_RF[pixel, 4] == 1:
                test = 1
                y1 = int(Link_RF[pixel, 0])
                x1 = int(Link_RF[pixel, 1])
                Link_RF[pixel, 4] = 2
                dist_ac = Link_RF[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if RF[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_RF, x, y)
                            if Link_RF[ind, 2] > Dist:
                                Link_RF[ind, 2] = Dist
                                Link_RF[ind, 3] = Link_RF[pixel, 3]
                                Link_RF[ind, 4] = 1
            pixel += 1

        if test == 0:
            break

    test = 0
    pixel = 1

    while pixel < nb_pixel_RF:
        if Link_RF[pixel, 2] == 100001:
            y1 = int(Link_RF[pixel, 0])
            x1 = int(Link_RF[pixel, 1])
            for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                    if Res_pub[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        ind = seek_ind_i(Tab_res_pub, x, y)
                        Link_RF[pixel, 2] = Dist
                        Link_RF[pixel, 3] = ind
                        Link_RF[pixel, 4] = 1
                        test = 1
        pixel += 1

    while test:
        test = 0
        pixel = 1
        while pixel < nb_pixel_RF:
            if Link_RF[pixel, 4] == 1:
                test = 1
                y1 = int(Link_RF[pixel, 0])
                x1 = int(Link_RF[pixel, 1])
                Link_RF[pixel, 4] = 2
                dist_ac = Link_RF[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if RF[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_RF, x, y)
                            if Link_RF[ind, 2] > Dist:
                                Link_RF[ind, 2] = Dist
                                Link_RF[ind, 3] = Link_RF[pixel, 3]
                                Link_RF[ind, 4] = 1
            pixel += 1

    return Link_RF[:, 0:-1]


def Link_tracks_res_pub(Tab_res_pub, Link_RF, cost_rast, Piste, RF, Res_Pub, Link_Piste, Csize, Max_distance=100000):
    nline, ncol = cost_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    dist_ac = Csize
    nb_pixel_res_pub = Tab_res_pub.shape[0]
    nb_pixel_RF = Link_RF.shape[0]
    nb_pixel_Piste = Link_Piste.shape[0]
    pixel = 1

    # Initialisation du raster depuis reseau public
    while pixel < nb_pixel_res_pub:
        y1 = Tab_res_pub[pixel, 0]
        x1 = Tab_res_pub[pixel, 1]
        if Piste[y1, x1] == 1:
            ind = seek_ind(Link_Piste, x1, y1)
            Link_Piste[ind, 2] = 0
            Link_Piste[ind, 3] = 0
            Link_Piste[ind, 4] = -9999
            Link_Piste[ind, 5] = pixel
            Link_Piste[ind, 6] = 1
        pixel += 1

    pixel = 1
    # Initialisation du raster depuis route_for
    while pixel < nb_pixel_RF:
        y1 = Link_RF[pixel, 0]
        x1 = Link_RF[pixel, 1]
        if Piste[y1, x1] == 1:
            ind = seek_ind(Link_Piste, x1, y1)
            Link_Piste[ind, 2] = 0
            Link_Piste[ind, 3] = Link_RF[pixel, 2]
            Link_Piste[ind, 4] = pixel
            Link_Piste[ind, 5] = Link_RF[pixel, 3]
            Link_Piste[ind, 6] = 1
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance:
        test = 0
        pixel = 1
        while pixel < nb_pixel_Piste:
            if Link_Piste[pixel, 6] == 1:
                test = 1
                y1 = int(Link_Piste[pixel, 0])
                x1 = int(Link_Piste[pixel, 1])
                Link_Piste[pixel, 6] = 2
                dist_ac = Link_Piste[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if Piste[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_Piste, x, y)
                            if Link_Piste[ind, 2] > Dist:
                                Link_Piste[ind, 2] = Dist
                                Link_Piste[ind, 3] = Link_Piste[pixel, 3]
                                Link_Piste[ind, 4] = Link_Piste[pixel, 4]
                                Link_Piste[ind, 5] = Link_Piste[pixel, 5]
                                Link_Piste[ind, 6] = 1
            pixel += 1

        if test == 0:
            break

    # Verifie si certaines pistes ne sont pas connectee
    test = 0
    pixel = 1

    # Initialisation du raster
    while pixel < nb_pixel_Piste:
        if Link_Piste[pixel, 2] == 100001:
            y1 = int(Link_Piste[pixel, 0])
            x1 = int(Link_Piste[pixel, 1])
            for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                    if Res_Pub[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        if Link_Piste[pixel, 2] > Dist:
                            ind = seek_ind_i(Tab_res_pub, x, y)
                            Link_Piste[pixel, 2] = Dist
                            Link_Piste[pixel, 3] = 0
                            Link_Piste[pixel, 4] = -9999
                            Link_Piste[pixel, 5] = ind
                            Link_Piste[pixel, 6] = 1
                            test = 1
                    if RF[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        if Link_Piste[pixel, 2] > Dist:
                            ind = seek_ind_i(Link_RF, x, y)
                            Link_Piste[pixel, 2] = Dist
                            Link_Piste[pixel, 3] = Link_RF[ind, 2]
                            Link_Piste[pixel, 4] = ind
                            Link_Piste[pixel, 5] = Link_RF[ind, 3]
                            Link_Piste[pixel, 6] = 1
                            test = 1
        pixel += 1

    # Traitement complet
    while test:
        test = 0
        pixel = 1
        while pixel < nb_pixel_Piste:
            if Link_Piste[pixel, 6] == 1:
                test = 1
                y1 = int(Link_Piste[pixel, 0])
                x1 = int(Link_Piste[pixel, 1])
                Link_Piste[pixel, 6] = 2
                dist_ac = Link_Piste[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if Piste[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_Piste, x, y)
                            if Link_Piste[ind, 2] > Dist:
                                Link_Piste[ind, 2] = Dist
                                Link_Piste[ind, 3] = Link_Piste[pixel, 3]
                                Link_Piste[ind, 4] = Link_Piste[pixel, 4]
                                Link_Piste[ind, 5] = Link_Piste[pixel, 5]
                                Link_Piste[ind, 6] = 1
            pixel += 1

    return Link_Piste[:, 0:-1]


def Dfwd_flat_forest_road(Link_RF, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = zone_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    nb_pixel_RF = Link_RF.shape[0]

    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (Max_distance + 1)
    L_forRF = np.ones_like(zone_rast, dtype=np.int32) * -9999

    x, y, x1, y1 = 0, 0, 0, 0
    test = 0
    count_sans_match = 0
    Dist = 0
    dist_ac = Csize
    h = nline
    b = 0
    l = ncol
    r = 0

    # Initialisation du raster
    pixel = 1
    while pixel < nb_pixel_RF:
        y1 = Link_RF[pixel, 0]
        x1 = Link_RF[pixel, 1]
        Out_distance[y1, x1] = 0
        L_forRF[y1, x1] = pixel
        for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct
                    if Out_distance[y, x] > Dist:
                        Out_distance[y, x] = int(Dist + 0.5)
                        L_forRF[y, x] = pixel
                        x1, y1 = x, y
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        y1, x1 = h, l
        test = 0
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] > Dist:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    L_forRF[y, x] = L_forRF[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline):
        for x in range(0, ncol):
            if Out_distance[y, x] > Max_distance:
                Out_distance[y, x] = -9999
                L_forRF[y, x] = -9999

    return Out_distance, L_forRF


def Dfwd_flat_forest_tracks(Link_Piste, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline = zone_rast.shape[0]
    ncol = zone_rast.shape[1]
    diag = 1.414214 * Csize
    direct = Csize
    nb_pixel_Piste = Link_Piste.shape[0]


    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (Max_distance + 1)
    L_forPiste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dpiste = np.ones_like(zone_rast, dtype=np.int32) * -9999

    x, y, x1, y1 = 0, 0, 0, 0
    test = 0
    count_sans_match = 0
    Dist = 0
    dist_ac = Csize
    h = nline
    b = 0
    l = ncol
    r = 0


    # Initialisation du raster
    pixel = 1
    while pixel < nb_pixel_Piste:
        y1 = Link_Piste[pixel, 0]
        x1 = Link_Piste[pixel, 1]
        Out_distance[y1, x1] = 0
        L_forPiste[y1, x1] = pixel
        Dpiste[y1, x1] = Link_Piste[pixel, 2]
        for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct
                    if Out_distance[y, x] >= Dist and Dpiste[y, x] + 2 * Out_distance[y, x] > 2 * Dist + Link_Piste[
                        pixel, 2]:
                        Out_distance[y, x] = int(Dist + 0.5)
                        L_forPiste[y, x] = pixel
                        Dpiste[y, x] = Link_Piste[pixel, 2]
                        if y < h: h = y
                        if x < l: l = x
                        if y > b: b = y
                        if x > r: r = x
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        y1, x1 = h, l
        test = 0
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] >= Dist and Dpiste[y, x] + 2 * Out_distance[y, x] > 2 * Dist + Dpiste[
                                    y1, x1]:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    L_forPiste[y, x] = L_forPiste[y1, x1]
                                    Dpiste[y, x] = Dpiste[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline):
        for x in range(0, ncol):
            if Out_distance[y, x] > Max_distance:
                Out_distance[y, x] = -9999
                L_forPiste[y, x] = -9999
                Dpiste[y, x] = -9999

    return Out_distance, L_forPiste, Dpiste


def fwd_azimuts_contour(Lien_RF, MNT, Aspect, Pente, Row_line, Col_line, D_line, Nbpix_line,
                        Fwd_max_up, Fwd_max_down, Fwd_max_inc, Forw_Lmax, nrows, ncols, Zone_ok):
    Max_distance = 100000
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    Dfor = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    Dpis = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_pis = np.zeros((nrows, ncols), dtype=np.int32) - 9999
    L_RF = np.zeros((nrows, ncols), dtype=np.int32) - 9999

    for pixel in range(1, Lien_RF.shape[0]):
        coordY = Lien_RF[pixel, 0]
        coordX = Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0
        lienRF = Lien_RF[pixel, 4]
        lienPiste = Lien_RF[pixel, 5]
        dpist = Lien_RF[pixel, 2]
        dfor = Lien_RF[pixel, 3]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y = coordY + Row_line[az, i]
                if Y < 0:
                    break
                if Y >= nrows:
                    break
                X = coordX + Col_line[az, i]
                if X < 0:
                    break
                if X >= ncols:
                    break
                if not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = np.sqrt(Hdist * Hdist + (Alt_pixel - Alt_RF) * (Alt_pixel - Alt_RF))

                if dist > Forw_Lmax:
                    break

                if MNT[Y, X] > Alt_RF:
                    if Pente[Y, X] > Fwd_max_down:
                        break
                else:
                    if Pente[Y, X] > Fwd_max_up:
                        break

                dif_angle = (az - Aspect[Y, X]) % 180.
                max_slope = np.fabs(Fwd_max_inc / np.cos((90. - dif_angle) / 180 * np.pi))

                if Pente[Y, X] > max_slope:
                    break

                if Dpis[Y, X] == (Max_distance + 1):
                    Out_distance[Y, X] = int(dist + 0.5)
                    Dpis[Y, X] = int(dpist + 0.5)
                    Dfor[Y, X] = int(dfor + 0.5)
                    L_RF[Y, X] = lienRF
                    L_pis[Y, X] = lienPiste
                    testRF = 1
                else:
                    if (Out_distance[Y, X] + Dpis[Y, X] * 0.1 + Dfor[Y, X]) > (dist + dfor + 0.1 * dpist):
                        Out_distance[Y, X] = int(dist + 0.5)
                        Dpis[Y, X] = int(dpist + 0.5)
                        Dfor[Y, X] = int(dfor + 0.5)
                        L_RF[Y, X] = lienRF
                        L_pis[Y, X] = lienPiste
                        testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            Dpis[coordY, coordX] = int(dpist + 0.5)
            Dfor[coordY, coordX] = int(dfor + 0.5)
            L_RF[coordY, coordX] = lienRF
            L_pis[coordY, coordX] = lienPiste

    for Y in range(0, nrows, 1):
        for X in range(0, ncols, 1):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_RF[Y, X] = -9999
                L_pis[Y, X] = -9999
                Dpis[Y, X] = -9999
                Dfor[Y, X] = -9999

    return Out_distance, L_RF, L_pis, Dpis, Dfor


def Fwd_add_contour(Lien_contour, cost_rast, zone_rast, Forw_portee, Csize):
    nline, ncol = zone_rast.shape[0], zone_rast.shape[1]
    diag = 1.414214 * Csize
    direct = Csize
    Dist, dist_ac = Csize, Csize
    Max_distance = int(Forw_portee + 0.5)
    nb_pixel_contour = Lien_contour.shape[0]
    h, b, l, r = nline, 0, ncol, 0

    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (100 + 1)
    Lien_RF = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Lien_piste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dpiste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dforet = np.ones_like(zone_rast, dtype=np.int32) * -9999

    y1, x1, test, count_sans_match, pixel = 0, 0, 0, 0, 1

    # Initialisation du raster
    while pixel < nb_pixel_contour:
        y1, x1 = Lien_contour[pixel, 0], Lien_contour[pixel, 1]
        Out_distance[y1, x1] = 0
        Lien_RF[y1, x1] = Lien_contour[pixel, 3]
        Lien_piste[y1, x1] = Lien_contour[pixel, 5]
        Dpiste[y1, x1] = Lien_contour[pixel, 4]
        Dforet[y1, x1] = Lien_contour[pixel, 2]

        for y in range(max(0, y1 - 1), min(nline, y1 + 2), 1):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2), 1):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct

                    if Dist <= Max_distance:
                        if Out_distance[y, x] == 101:
                            Out_distance[y, x] = int(Dist + 0.5)
                            Lien_RF[y, x] = Lien_RF[y1, x1]
                            Lien_piste[y, x] = Lien_piste[y1, x1]
                            Dpiste[y, x] = Dpiste[y1, x1]
                            Dforet[y, x] = Dforet[y1, x1]

                            if y < h:
                                h = y
                            if x < l:
                                l = x
                            if y > b:
                                b = y
                            if x > r:
                                r = x
                        else:
                            if Out_distance[y, x] + 0.1 * Dpiste[y, x] + Dforet[y, x] > Dist + 0.1 * Dpiste[y1, x1] + Dforet[y1, x1]:
                                Out_distance[y, x] = int(Dist + 0.5)
                                Lien_RF[y, x] = Lien_RF[y1, x1]
                                Lien_piste[y, x] = Lien_piste[y1, x1]
                                Dpiste[y, x] = Dpiste[y1, x1]
                                Dforet[y, x] = Dforet[y1, x1]

                                if y < h:
                                    h = y
                                if x < l:
                                    l = x
                                if y > b:
                                    b = y
                                if x > r:
                                    r = x

        pixel += 1

    # Traitement complet
    while dist_ac <= 100 and count_sans_match < 15 * Csize:
        test = 0
        y1, x1 = h, l

        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2), 1):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2), 1):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac

                                if Dist <= Max_distance:
                                    if Out_distance[y, x] == 101:
                                        Out_distance[y, x] = int(Dist + 0.5)
                                        Lien_RF[y, x] = Lien_RF[y1, x1]
                                        Lien_piste[y, x] = Lien_piste[y1, x1]
                                        Dpiste[y, x] = Dpiste[y1, x1]
                                        Dforet[y, x] = Dforet[y1, x1]
                                    else:
                                        if Out_distance[y, x] + 0.1 * Dpiste[y, x] + Dforet[y, x] > Dist + 0.1 * Dpiste[y1, x1] + Dforet[y1, x1]:
                                            Out_distance[y, x] = int(Dist + 0.5)
                                            Lien_RF[y, x] = Lien_RF[y1, x1]
                                            Lien_piste[y, x] = Lien_piste[y1, x1]
                                            Dpiste[y, x] = Dpiste[y1, x1]
                                            Dforet[y, x] = Dforet[y1, x1]

        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1

        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline, 1):
        for x in range(0, ncol, 1):
            if Out_distance[y, x] > 100:
                Out_distance[y, x] = -9999
                Lien_RF[y, x] = -9999
                Lien_piste[y, x] = -9999
                Dpiste[y, x] = -9999
                Dforet[y, x] = -9999

    return Out_distance, Lien_RF, Lien_piste, Dpiste, Dforet


def fill_Link(Lien_foret_piste, Lien_piste, Lien_RF, Lien_foret_RF, nrows, ncols):
    Lien_foret_res_pub = np.ones((nrows, ncols), dtype=np.int32) * -9999
    Keep = np.zeros((nrows, ncols), dtype=np.int8)

    for y in range(nrows):
        for x in range(ncols):
            pixel = Lien_foret_piste[y, x]

            if pixel > 0:
                Keep[Lien_piste[pixel, 0], Lien_piste[pixel, 1]] = 1
                Lien_foret_res_pub[y, x] = Lien_piste[pixel, 5]
                Lien_foret_RF[y, x] = Lien_piste[pixel, 4]
            else:
                pixel2 = Lien_foret_RF[y, x]

                if pixel2 > 0:
                    Keep[Lien_RF[pixel2, 0], Lien_RF[pixel2, 1]] = 1
                    Lien_foret_res_pub[y, x] = Lien_RF[pixel2, 3]

    return Lien_foret_res_pub, Lien_foret_RF, Keep


def get_line_carac_vol(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv, Vol_ha, Vol_AM):
    x, y = 0, 0
    i = 0
    nfor = 0
    nvam = 0
    Dmoy_car = 0
    Dmoy_car2 = 0
    Vtot = 0
    VAM = 0

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0 or x >= ncols:
            i += 1
            continue

        y = Row_ext[az, i] + coordY
        if y < 0 or y >= nrows:
            i += 1
            continue

        if Forest[y, x] == 1:
            nfor += 1
            Dmoy_car2 += D_ext[az, i]
            Rast_couv[y, x] = 1

        if Vol_ha[y, x] > 0:
            Vtot += Vol_ha[y, x] * Csize * Csize * 0.0001
            Dmoy_car += Vol_ha[y, x] * D_ext[az, i] * Csize * Csize * 0.0001

        if Vol_AM[y, x] > 0:
            nvam += 1
            VAM += Vol_AM[y, x]

        i += 1

    Forest_area = nfor * Csize * Csize

    if Vtot > 0:
        Dmoy_car = Dmoy_car / Vtot
    else:
        Vtot = -1
        if nfor > 0:
            Dmoy_car = Dmoy_car2 / nfor
        else:
            Dmoy_car = D_ext[az, i]

    if nvam > 0:
        VAM = VAM / nvam
    else:
        VAM = -1

    return int(Dmoy_car), int(Forest_area), int(Vtot), int(10 * VAM), Rast_couv


def get_prop(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Rast_couv):
    x, y = 0, 0
    i = 0
    nb1 = 0
    nb2 = 0

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0 or x >= ncols:
            i += 1
            continue

        y = Row_ext[az, i] + coordY
        if y < 0 or y >= nrows:
            i += 1
            continue

        if Rast_couv[y, x] == 1:
            nb1 += 1
        elif Rast_couv[y, x] > 1:
            nb2 += 1

        i += 1

    total = nb1 + nb2
    return nb1 / total if total > 0 else 0

