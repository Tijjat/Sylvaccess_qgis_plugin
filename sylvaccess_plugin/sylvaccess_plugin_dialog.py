# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Sylvaccess_pluginDialog
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5 import QtWidgets, uic
from PyQt5.QtWidgets import QFileDialog
import os
from qgis.core import *
from scipy import spatial
import numpy as np
from osgeo import gdal, osr, ogr
import math
#from cython import pyximport
#pyximport.install()
#import sylvaccess_cython3 as fc
from math import sqrt,degrees,atan,cos,sin,radians
import shutil
import gc
import datetime
from scipy.interpolate import interpolateUnivariateSpline


# Chargement de l'interface utilisateur depuis le fichier .ui
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'sylvaccess_plugin_dialog_base.ui'))

class Sylvaccess_pluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        super(Sylvaccess_pluginDialog, self).__init__(parent)
        self.setupUi(self)

###################################################################
#.______     ______    __    __  .___________.  ______   .__   __.# 
#|   _  \   /  __  \  |  |  |  | |           | /  __  \  |  \ |  |# 
#|  |_)  | |  |  |  | |  |  |  | `---|  |----`|  |  |  | |   \|  |# 
#|   _  <  |  |  |  | |  |  |  |     |  |     |  |  |  | |  . `  |# 
#|  |_)  | |  `--'  | |  `--'  |     |  |     |  `--'  | |  |\   |# 
#|______/   \______/   \______/      |__|      \______/  |__| \__|# 
###################################################################        
        # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
        for i in range(1, 14):
            button = getattr(self, f"pushButton_{i}")
            button.clicked.connect(lambda _, num=i: self.open_folder(num))

        # Connexion des signaux des checkbox
        for i in range(1, 5):
            checkbox = getattr(self, f"checkBox_{i}")
            checkbox.stateChanged.connect(lambda _, num=i: self.checkbox_state_changed(num))

        # Connexion des signaux des boutons OK et Annuler
        self.button_box.accepted.connect(self.launch)
        self.button_box.rejected.connect(self.reject)
        self.spinBox_40.valueChanged.connect(self.spinBox_40_changed)

    # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
    def open_folder(self, button_number):
        # Définit les filtres génériques pour Shapefiles et fichiers raster
        shapefile_filter = "Shapefiles (*.shp);;All files (*)"
        raster_filter = "Raster files (*.tif *.asc *.txt);;All files (*)"

        # Définit les options de la boîte de dialogue
        options = QFileDialog.Options()
        #options |= QFileDialog.DontUseNativeDialog

        # Affiche le dialogue de sélection de fichier avec les filtres appropriés
        if button_number in [4, 5, 6]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, "Choisir un fichier", filter=shapefile_filter, options=options)
        elif button_number in [3, 11, 12, 13]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, "Choisir un fichier", filter=raster_filter, options=options)
        elif button_number in [1, 2, 7, 8, 9, 10]:  # Pour le bouton qui doit ouvrir un dossier
            selected_file = QFileDialog.getExistingDirectory(
                None, "Choisir un dossier", options=options)

        if selected_file:
            # Mise à jour du champ de texte approprié
            if button_number == 2:
                text_edit = getattr(self, f"lineEdit_2")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_17")
                text_edit.setText(selected_file)
            elif button_number == 4 :
                text_edit = getattr(self, f"lineEdit_4")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_14")
                text_edit.setText(selected_file)
            elif button_number == 13:
                text_edit = getattr(self, f"lineEdit_13")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_15")
                text_edit.setText(selected_file)
            elif button_number == 12 :
                text_edit = getattr(self, f"lineEdit_12")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_16")
                text_edit.setText(selected_file)
            else:
                text_edit = getattr(self, f"lineEdit_{button_number}")
                text_edit.setText(selected_file)

    # Fonction appelée lorsqu'une checkbox est cochée ou décochée
    def checkbox_state_changed(self, checkbox_number):
        # Récupère l'état de la checkbox
        checkbox = getattr(self, f"checkBox_{checkbox_number}")
        checkbox_state = checkbox.isChecked()

        if checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(True)
                # désactive les lineEdit pour éviter les erreurs
                self.lineEdit_14.setEnabled(False)
                self.lineEdit_15.setEnabled(False)
                self.lineEdit_16.setEnabled(False)
                self.lineEdit_17.setEnabled(False)
                self.spinBox_49.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(True)
            if checkbox_number == 3:
                self.porteur.setEnabled(True) 
            if checkbox_number == 4:
                self.skidder.setEnabled(True)
        elif not checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(False)
            if checkbox_number == 3:
                self.porteur.setEnabled(False) 
            if checkbox_number == 4:
                self.skidder.setEnabled(False)


    def spinBox_40_changed(self):
        value = self.spinBox_40.value()
        self.spinBox_49.setValue(value)
###############################################################################################
# __          ___      .__   __.   ______  _______ .___  ___.  _______ .__   __. .___________.#
#|  |        /   \     |  \ |  |  /      ||   ____||   \/   | |   ____||  \ |  | |           |#
#|  |       /  ^  \    |   \|  | |  ,----'|  |__   |  \  /  | |  |__   |   \|  | `---|  |----`#
#|  |      /  /_\  \   |  . `  | |  |     |   __|  |  |\/|  | |   __|  |  . `  |     |  |     #
#|  `----./  _____  \  |  |\   | |  `----.|  |____ |  |  |  | |  |____ |  |\   |     |  |     #
#|_______/__/     \__\ |__| \__|  \______||_______||__|  |__| |_______||__| \__|     |__|     #
###############################################################################################                                                                                             
    # Fonction appelée lorsqu'on clique sur le bouton OK
    def launch(self):
        for i in range (1,5):
            if not getattr(self, f"lineEdit_{i}").text():
                console_warning("Veuillez remplir tous les champs")
                return
        Sylvaccess_pluginDialog.check_files()    
        if self.checkBox_4.isChecked():
            Skidder()
        if self.checkBox_3.isChecked():
            Porteur()
        if self.checkBox_2.isChecked() or self.checkBox_1.isChecked():
            if not getattr(self, f"lineEdit_6".text()):
                console_warning("Veuillez remplir les Départs potentiels de câble")
                return
                if self.checkBox_2.isChecked():
                    Cable()
                if self.checkBox_1.isChecked():
                    Cable_opti()
        else:
            console_warning("Veuillez choisir au moins un type de machine")
            return

    # Fonction qui vérifie que tous les fichiers nécessaires sont bien présents
    def check_files(self):
        verif=True
        test_Skidder = self.checkBox_4.isChecked()
        test_Porteur = self.checkBox_3.isChecked()
        test_cable_optim = self.checkBox_1.isChecked()
        test_Cable = self.checkBox_2.isChecked()
        file_MNT = getattr(self, f"lineEdit_3".text())
        file_shp_Desserte = getattr(self, f"lineEdit_5".text())
        file_shp_Foret = getattr(self, f"lineEdit_4".text())
        file_vol_BP = getattr(self, f"lineEdit_13".text())
        file_vol_AM = getattr(self, f"lineEdit_12".text())
        file_HA = getattr(self, f"lineEdit_14".text())
        new_calc = self.checkBox_6.isChecked()
        file_shp_Cable_dep = getattr(self, f"lineEdit_6".text())

        msg="\nLES PROBLEMES SUIVANTS ONT ETE IDENTIFIES CONCERNANT LES ENTREES SPATIALES: \n"
        #Check MNT
        if test_Skidder+test_Porteur+test_Cable>0:
            try:
                _,values,_,Extent = raster_get_info(file_MNT)   
                if values[5]==None:
                    verif=False
                    msg+=" -   Raster MNT: Aucune valeur de NoData definie\n" 
            except:
                msg+=" -   Raster MNT:  Le chemin d'acces est manquant ou incorrect. Ce raster est obligatoire pour lancer Sylvaccess\n" 
                
        #Check file_shp_Desserte   
        if test_Skidder+test_Porteur>0:
            try:    
                if not check_field(file_shp_Desserte,"CL_SVAC"):
                    verif=False
                    msg+=" -   Couche desserte: Le champs 'CL_SVAC' est manquant\n"  
            except:
                verif=False
                msg+=" -   Couche desserte: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour les modules skidder et porteur\n" 
            

        #Check file_shp_Cable_Dep    
        if test_Cable:   
            try: 
                if not check_field(file_shp_Cable_dep,"CABLE"):
                    verif=False
                    msg+=" -   Couche desserte: Le champs 'CABLE' est manquant\n"  
            except:
                verif=False
                msg+=" -   Couche départs de cable potentiels: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour le module cable\n" 

            
        #Check file_shp_Foret   
        if test_Skidder+test_Porteur+test_Cable>0:    
            try:     
                if not check_field(file_shp_Foret,"FORET"):
                    verif=False
                    msg+=" -   Couche foret: Le champs 'FORET' est manquant\n" 
            except:
                verif=False
                msg+=" -   Couche foret: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour lancer Sylvaccess\n"     
                    
        #Check file_shp_Foret for cable optim
        if not test_Cable and test_cable_optim and new_calc and file_shp_Foret!="":
            try:     
                if not check_field(file_shp_Foret,"FORET"):
                    verif=False
                    msg+=" -   Couche foret (onglet optimisation cable): Le champs 'FORET' est manquant\n" 
            except:
                verif=False
                msg+=" -   Couche foret (onglet optimisation cable): Le chemin d'acces est manquant ou incorrect. \n"     
            
        #Check file_vol_BP,file_vol_AM,file_HA
        FR_name = ["Raster Volume/ha","Raster volume arbre moyen","Raster hauteur des arbres"]
        for i,f in enumerate([file_vol_BP,file_vol_AM,file_HA]):
            if f!="":
                try:
                    _,values2,_,Extent2 = raster_get_info(f)    
                    if values2[5]==None:
                        verif=False
                        msg+=" -   "+FR_name[i]+": Aucune valeur de NoData definie\n" 
                    if not values[4]==values2[4]:
                        verif=False
                        msg+=" -   "+FR_name[i]+": La taille de cellules du raster doit etre la meme que celle du MNT\n" 
                    if not np.all(Extent==Extent2):
                        verif=False
                        msg+=" -   "+FR_name[i]+": L'etendue du raster doit etre la meme que celle du MNT\n" 
                except:
                    verif=False
                    msg+=" -   "+FR_name[i]+": Le chemin d'access est incorrect\n"     

        if not verif:
            msg+="\n"
            msg+="MERCI DE CORRIGER AVANT DE RELANCER SYLVACCESS\n"
            console_warning(msg)
        return verif


########################################################################################################################
#  _______  _______ .___________.   ____    ____  ___      .______       __       ___      .______    __       _______ #
# /  _____||   ____||           |   \   \  /   / /   \     |   _  \     |  |     /   \     |   _  \  |  |     |   ____|#
#|  |  __  |  |__   `---|  |----`    \   \/   / /  ^  \    |  |_)  |    |  |    /  ^  \    |  |_)  | |  |     |  |__   #
#|  | |_ | |   __|      |  |          \      / /  /_\  \   |      /     |  |   /  /_\  \   |   _  <  |  |     |   __|  #
#|  |__| | |  |____     |  |           \    / /  _____  \  |  |\  \----.|  |  /  _____  \  |  |_)  | |  `----.|  |____ #
# \______| |_______|    |__|            \__/ /__/     \__\ | _| `._____||__| /__/     \__\ |______/  |_______||_______|#
########################################################################################################################
    def get_general(self,ski,por,cab,opti,pente):
        if ski:
            ski = getattr(self, f"checkBox_4").isChecked()
        if por:
            por = getattr(self, f"checkBox_3").isChecked()
        if cab:
            cab = getattr(self, f"checkBox_2").isChecked()
        if opti:
            opti = getattr(self, f"checkBox_1").isChecked()
        if pente:
            pente = self.spinBox_1.value()


    def get_spatial(self,Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP):
        if Wspace: 
            Wspace = getattr(self, f"lineEdit_1").text()
        if Rspace:
            Rspace = getattr(self, f"lineEdit_2").text()
        if mnt:
            mnt = getattr(self, f"lineEdit_3").text()
        if foret:
            foret = getattr(self, f"lineEdit_4").text()
        if desserte:
            desserte = getattr(self, f"lineEdit_5").text()
        if dep_cable:
            dep_cable = getattr(self, f"lineEdit_6").text()
        if ski_no_t_d:
            ski_no_t_d = getattr(self, f"lineEdit_7").text()
        if ski_no_t:
            ski_no_t = getattr(self, f"lineEdit_8").text()
        if por_obstacle:
            por_obstacle = getattr(self, f"lineEdit_9").text()
        if cab_obstacle:
            cab_obstacle = getattr(self, f"lineEdit_10").text()
        if HA:
            HA = getattr(self, f"lineEdit_11").text()
        if VAM:
            VAM = getattr(self, f"lineEdit_12").text()
        if VBP:
            VBP = getattr(self, f"lineEdit_13").text()

        return Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP


    def get_skidder(self,pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes_s):
        if pente_max:
            pente_max = self.spinBox_3.value()
        if distance_max_amont:
            distance_max_amont = self.spinBox_4.value()
        if distance_max_aval:
            distance_max_aval = self.spinBox_5.value()
        if distance_max_hors_frt_dsrt:
            distance_max_hors_frt_dsrt = self.spinBox_6.value() 
        if pente_amont_max:
            pente_amont_max = self.spinBox_7.value()
        if pente_aval_max:
            pente_aval_max = self.spinBox_1.value()
        if limite:
            if self.radioButton_1.isChecked():
                limite = True
            else:
                limite = False
        if bornes_s:
            bornes_s = self.plainTextEdit_1.toPlainText()
            if not bornes_s:
                console_warning("Veuillez remplir les bornes minimales des classes de débardages pour le skidder")
                return
        return pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes_s   


    def get_porteur(self,pente_max,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes_p):
        if pente_max:
            pente_max = self.spinBox_8.value()
        if pente_max_remonant:
            pente_max_remonant = self.spinBox_9.value()
        if pente_max_descendant:
            pente_max_descendant = self.spinBox_12.value()
        if distance_max_pente_sup:
            distance_max_pente_sup = self.spinBox_10.value()
        if distance_max_hors_frt:
            distance_max_hors_frt = self.spinBox_11.value()
        if taille_grue:
            taille_grue = self.doublespinBox_1.value()
        if bornes_p:
            bornes_p = self.plainTextEdit_2.toPlainText()
            if not bornes_p:
                console_warning("Veuillez remplir les bornes minimales des classes de débardages pour le porteur")
                return
        return pente_max,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes_p


    def get_type_cable(self, type_machine,supports_inter,hauteur,longueure_max,longueure_min):
        if type_machine:
            type_machine = self.comboBox_1.currentText()
        if supports_inter:
            supports_inter = self.spinBox_14.value()
        if hauteur:
            hauteur = self.doublespinBox_2.value()
        if longueure_max:
            longueure_max = self.spinBox_16.value()
        if longueure_min:
            longueure_min = self.spinBox_17.value()
        return type_machine,supports_inter,hauteur,longueure_max,longueure_min


    def get_type_chariot(self, type_chariot,masse,pente_min,pente_max_amont,pente_max_aval):
        if type_chariot:
            type_chariot = self.comboBox_2.currentText()
        if masse:
            masse = self.spinBox_22.value()
        if pente_min:
            pente_min = self.spinBox_23.value()
        if pente_max_amont:
            pente_max_amont = self.spinBox_24.value()
        if pente_max_aval:
            pente_max_aval = self.spinBox_25.value()
        return type_chariot,masse,pente_min,pente_max_amont,pente_max_aval      


    def get_proprietes_cable(self,diamètre,masse_li,tension_rupt,elasticité):
        if diamètre:
            diamètre = self.doublespinBox_3.value()
        if masse_li:
            masse_li = self.doublespinBox_4.value()
        if tension_rupt:
            tension_rupt = self.spinBox_26.value()
        if elasticité:
            elasticité = self.spinBox_27.value()
        return diamètre,masse_li,tension_rupt,elasticité


    def get_param_modelisation(self,hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite):
        if hauteur_sup:
            hauteur_sup = self.doublespinBox_5.value()
        if hauteur_mat:
            hauteur_mat = self.doublespinBox_8.value()
        if hauteur_min_cable:
            hauteur_min_cable = self.doublespinBox_6.value()
        if hauteur_max_cable:
            hauteur_max_cable = self.doublespinBox_9.value()
        if pechage:
            pechage = self.spinBox_40.value()
        if masse_max:
            masse_max = self.spinBox_39.value()
        if securite:
            securite = self.doublespinBox_10.value()
        return hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite


    def get_options(self,opti,precision):
        if opti:
            opti = self.checkBox_5.isChecked()
        if precision:
            precision = self.spinBox_41.value()
        return opti,precision


    def get_opti_cable(self,prelevement,recalculer,Rspace_c,foret_c,VBP_c,VAM_c,pechage_c):
        if prelevement:
            prelevement = self.spinBox_48.value()
        if recalculer:
            recalculer = self.checkBox_6.isChecked()
        if Rspace_c:
            Rspace_c = getattr(self, f"lineEdit_17").text()
        if foret_c:
            foret_c = getattr(self, f"lineEdit_14").text()
        if VBP_c:
            VBP_c = getattr(self, f"lineEdit_15").text()
        if VAM_c:
            VAM_c = getattr(self, f"lineEdit_16").text()
        if pechage_c:
            pechage_c = self.spinBox_49.value()
        return prelevement,recalculer,Rspace_c,foret_c,VBP_c,VAM_c,pechage_c


    def get_crit_opti(self,surface,nbr_sup_int,sens_debardage,longueure_ligne,vol_ligne,indice_prelev,VAM,dist_chariot):
        surface_poids,nbr_sup_int_poids,sens_debardage_poids,longueure_ligne_poids,vol_ligne_poids,indice_prelev_poids,VAM_poids,dist_chariot_poids = 0,0,0,0,0,0,0,0   
        if surface and self.checkBox_7.isChecked():
            surface = self.doublespinBox_11.value()
            surface_poids = self.spinBox_18.value()
        else:
            surface = 0
        if nbr_sup_int and self.checkBox_8.isChecked():
            nbr_sup_int = self.spinBox_46.value()
            nbr_sup_int_poids = self.spinBox_19.value()
        else:
            nbr_sup_int = 0
        if sens_debardage and self.checkBox_9.isChecked():
            sens_debardage = self.spinBox_45.value()
            sens_debardage_poids = self.spinBox_20.value()
        else:
            sens_debardage = 0
        if longueure_ligne and self.checkBox_10.isChecked():
            longueure_ligne = self.spinBox_44.value()
            longueure_ligne_poids = self.spinBox_21.value()
        else:
            longueure_ligne = 0
        if vol_ligne and self.checkBox_11.isChecked():
            vol_ligne = self.spinBox_43.value()
            vol_ligne_poids = self.spinBox_31.value()
        else:
            vol_ligne = 0
        if indice_prelev and self.checkBox_12.isChecked():
            indice_prelev = self.doublespinBox_12.value()
            indice_prelev_poids = self.spinBox_32.value()
        else:
            indice_prelev = 0
        if VAM and self.checkBox_13.isChecked():
            VAM = self.doublespinBox_13.value()
            VAM_poids = self.spinBox_33.value()
        else:
            VAM = 0
        if dist_chariot and self.checkBox_14.isChecked():
            dist_chariot = self.spinBox_50.value()
            dist_chariot_poids = self.spinBox_51.value()
        else:
            dist_chariot = 0
        return surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM,VAM_poids,dist_chariot,dist_chariot_poids


# Fonctions qui gère les calculs liés au porteur
def Porteur():
    console_info("Porteur")
#####################################################
#.______   .______       __  .__   __. .___________.#
#|   _  \  |   _  \     |  | |  \ |  | |           |#
#|  |_)  | |  |_)  |    |  | |   \|  | `---|  |----`#
#|   ___/  |      /     |  | |  . `  |     |  |     #
#|  |      |  |\  \----.|  | |  |\   |     |  |     #
#| _|      | _| `._____||__| |__| \__|     |__|     #
#####################################################
# Fonctions qui affiche un message d'erreur dans la console
def console_warning(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Warning)

# Fonctions qui affiche un message d'information dans la console
def console_info(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Info)

###########################################################################
#  _______  _______ .__   __.  _______ .______          ___       __      #
# /  _____||   ____||  \ |  | |   ____||   _  \        /   \     |  |     #
#|  |  __  |  |__   |   \|  | |  |__   |  |_)  |      /  ^  \    |  |     #
#|  | |_ | |   __|  |  . `  | |   __|  |      /      /  /_\  \   |  |     #
#|  |__| | |  |____ |  |\   | |  |____ |  |\  \----./  _____  \  |  `----.#
# \______| |_______||__| \__| |_______|| _| `._____/__/     \__\ |_______|#
###########################################################################
    

def heures(Hdebut):
    Hfin = datetime.datetime.now()
    duree = Hfin - Hdebut
    ts = duree.seconds
    nb_days = int(ts/3600./24.)
    ts -= nb_days*3600*24
    nb_hours = int(ts/3600)
    ts -= nb_hours*3600
    nb_minutes = int(ts/60)
    ts -= nb_minutes*60  
    if nb_days>0:
        str_duree = str(nb_days)+'j '+str(nb_hours)+'h '+str(nb_minutes)+'min '+str(ts)+'s'
    elif nb_hours >0:
        str_duree = str(nb_hours)+'h '+str(nb_minutes)+'min '+str(ts)+'s'
    elif nb_minutes>0:
        str_duree = str(nb_minutes)+'min '+str(ts)+'s'
    else:
        str_duree = str(ts)+'s'        
        str_debut = str(Hdebut.day)+'/'+str(Hdebut.month)+'/'+str(Hdebut.year)+' '+str(Hdebut.hour)+':'+str(Hdebut.minute)+':'+str(Hdebut.second)
        str_fin = str(Hfin.day)+'/'+str(Hfin.month)+'/'+str(Hfin.year)+' '+str(Hfin.hour)+':'+str(Hfin.minute)+':'+str(Hfin.second)

    return str_duree,str_fin,str_debut


def get_info_ascii(file_name):
    fs = open(file_name, 'r')
    head_text=''
    line = 1
    while line<7:
        head_text = head_text+fs.readline()
        line=line+1
    fs.close()
    Csize = np.genfromtxt(file_name, dtype=None,usecols=(1))[4]
    return head_text, Csize


def save_integer_ascii(file_name,head_text,data):
    np.savetxt(file_name, data, fmt='%i', delimiter=' ')
    with open(file_name, "r+") as f:
        old = f.read()
        f.seek(0)
        f.write(head_text + old)
        f.close()


def save_float_ascii(file_name,head_text,data):
    np.savetxt(file_name, data, fmt='%f', delimiter=' ')
    with open(file_name, "r+") as f:
        old = f.read()
        f.seek(0)
        f.write(head_text + old)
        f.close()


def replace_all(text, dic):
    for i, j in dic.iteritems(): text = text.replace(i, j)
    return text

def clear_big_nparray():    
    """clear all globals over 100 Mo size and their associated memory space"""
    for uniquevar in [var for var in dir() if isinstance(globals()[var],np.ndarray)]:
        if globals()[uniquevar].nbytes/1000000>50:
            del globals()[uniquevar]
    gc.collect()

def read_info(info_file):
    names = np.genfromtxt(info_file, dtype=None,usecols=(0),encoding ='latin1')
    values = np.genfromtxt(info_file, dtype=None,usecols=(1),encoding ='latin1')  
    return list(names),list(values)


def raster_get_info(in_file_name):
    source_ds = gdal.Open(in_file_name)    
    src_proj = osr.SpatialReference(wkt=source_ds.GetProjection())
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform()
    ymin = ymax+src_nrows*Csize_y
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [src_ncols,src_nrows,xmin,ymin,Csize_x,nodata]
    Extent = [xmin,xmin+src_ncols*Csize_x,ymin,ymax]
    return names,values,src_proj,Extent


##############################
#  _______  __       _______.#
# /  _____||  |     /       |#
#|  |  __  |  |    |   (----`#
#|  | |_ | |  |     \   \    #
#|  |__| | |  | .----)   |   #
# \______| |__| |_______/    #
##############################                            


def check_field(filename,fieldname):
    verif=False    
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break    
    source_ds.Destroy() 
    return verif


def check_field_EXIST(filename,fieldname):    
    verif=False
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break
    if verif:
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))      
        nbval = np.unique(vals).shape[0]
        if nbval==1:
            verif=False
    source_ds.Destroy() 
    return verif


def generate_HeadText(names,values):    
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    return head_text


def save_raster_info(values,Rspace_c):   
    np.savetxt(Rspace_c+"Area_extent.txt", values, fmt='%f', delimiter=';')


def loadrasterinfo_from_file(Rspace_c):
    values = list(np.loadtxt(Rspace_c+"Area_extent.txt"))
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']    
    ncols = values[0]
    nrows = values[1]
    xmin=values[2]
    ymin = values[3]    
    Csize = values[4] 
    Extent = [xmin,xmin+ncols*Csize,ymin,ymin+nrows*Csize]
    return names,values,Extent


def load_float_raster(raster_file,Dir_temp):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [round(cols,2), round(rows,2), round(xmin,2), round(ymin,2), round(Csize,2),round(nodatavalue,2)]
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    f = open(Dir_temp+'info_extent.txt',"w")
    f.write(head_text)
    f.close()
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array),Extent,Csize,proj 


def load_float_raster_simple(raster_file):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)    
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()    
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array)


def get_source_src(file_name):
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()
    return source_layer.GetSpatialRef()


def shapefile_to_np_array(file_name,Extent,Csize,attribute_name,order_field=None,order=None):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)
    # Get information from source shapefile
    orig_data_source = ogr.Open(file_name)
    source_ds = ogr.GetDriverByName("Memory").CopyDataSource(orig_data_source, "")
    source_layer = source_ds.GetLayer()
    if order:
        source_layer_ordered = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' ORDER BY '+order_field+' '+order)
    else:source_layer_ordered=source_layer
    source_srs = source_layer.GetSpatialRef()
    # Initialize the new memory raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], source_layer_ordered,options=["ATTRIBUTE="+attribute_name,"ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        return mask_arr


def select_in_shapefile(source_shapefile,out_Shape_Path,expression):
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    #Get information from source shapefile
    source_ds = ogr.Open(source_shapefile)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    source_type = source_layer.GetGeomType()
    try: source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' '+expression)   
    except: print("Erreur de syntaxe dans l'expression")
    # Initialize the output shapefile
    if os.path.exists(out_Shape_Path):
        driver.DeleteDataSource(out_Shape_Path)
    target_ds = driver.CreateDataSource(out_Shape_Path)
    layerName = os.path.splitext(os.path.split(out_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    target_ds.Destroy()
    source_ds.Destroy()


def linestring_to_point(Line_shapefile,Point_Shape_Path):
    #Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Get line info
    source_ds = ogr.Open(Line_shapefile)
    source_layer = source_ds.GetLayer()
    source_srs = source_layer.GetSpatialRef()
    geoLocations = []
    ind = 1
    for feat in source_layer:
        geom = feat.GetGeometryRef()
        points = geom.GetPointCount()          
        for p in range(points):
            lon, lat,a = geom.GetPoint(p)
            geoLocations.append([lon,lat,ind])
        ind +=1
    geoLocations = np.array(geoLocations)
    fins_ligne = fin_ligne(geoLocations)
    # Create output point shapefile
    if os.path.exists(Point_Shape_Path):driver.DeleteDataSource(Point_Shape_Path)
    target_ds = driver.CreateDataSource(Point_Shape_Path)
    layerName = os.path.splitext(os.path.split(Point_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('IND_LINE', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('FIN_LIGNE', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind = 0
    for pointIndex, geoLocation in enumerate(geoLocations):
        # Create point
        geometry = ogr.Geometry(ogr.wkbPoint)
        geometry.SetPoint(0, geoLocation[0], geoLocation[1])
        # Create feature
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(pointIndex)
        feature.SetField('IND_LINE',int(geoLocation[2]))
        if pointIndex==fins_ligne[ind]:
            feature.SetField('FIN_LIGNE',1)
            ind +=1
            if ind > len(fins_ligne)-1:
                ind-=1
        else:
            feature.SetField('FIN_LIGNE',0)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        geometry.Destroy()
        feature.Destroy()
    # Cleanup
    target_ds.Destroy()
    return geoLocations,source_srs


def fin_ligne(point_coords):
    fin_ligne = []
    for i in range(point_coords.shape[0]-1):
        ind = np.sum((point_coords[:,0]==point_coords[i,0])*(point_coords[:,1]==point_coords[i,1]))
        if ind ==1:
            if i>0 and i+1<point_coords.shape[0]:
                if point_coords[i-1,2]!=point_coords[i,2] or point_coords[i+1,2]!=point_coords[i,2]:
                    fin_ligne.append(i)
            elif i==0 and point_coords[i+1,2]==point_coords[i,2]:fin_ligne.append(i)
            elif i==point_coords.shape[0]-1 and point_coords[i-1,2]==point_coords[i,2]:fin_ligne.append(i)
    return fin_ligne  


def points_to_lineshape(point_coords,Line_Shape_Path,projection):
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('DIRECTION', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind = 0
    while ind<point_coords.shape[0]-1:        
        if point_coords[ind+1,2]==point_coords[ind,2]:
            line = ogr.Geometry(ogr.wkbLineString)
            line.AddPoint(point_coords[ind,0],point_coords[ind,1])
            line.AddPoint(point_coords[ind+1,0],point_coords[ind+1,1])
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(line)
            feature.SetFID(ind)
            direction = calculate_direction(point_coords[ind,0],point_coords[ind,1], point_coords[ind+1,0],point_coords[ind+1,1])
            if ind+2< point_coords.shape[0] and point_coords[ind+1,2]==point_coords[ind+2,2]:
                feature.SetField('DIRECTION',direction)
            else:
                if direction <0:feature.SetField('DIRECTION',direction%180)
                else:feature.SetField('DIRECTION',direction%(-180))
            layer.CreateFeature(feature)
            ind +=1
            line.Destroy()
            feature.Destroy()
        else:
            ind +=1
    target_ds.Destroy()


def calculate_direction(x1,y1,x2,y2):
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    return int(Angle+0.5)


def get_head_text(ASCII_file):
    names = np.genfromtxt(ASCII_file, dtype=None,usecols=(0))[0:6]
    values = np.genfromtxt(ASCII_file, dtype=np.float,usecols=(1))[0:6]
    Extent = [values[2],values[2]+values[4]*values[0],values[3],values[3]+values[4]*values[1]]
    return names,values,Extent


def generate_head_text(names,values,Csize):
    rap = int(Csize/values[4])
    values[0],values[1],values[4]= int(values[0]/rap+0.5),int(values[1]/rap+0.5),Csize
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    return head_text


def buffer_shp(infile,outfile,buffdist):
    try:
        ds_in=ogr.Open( infile )
        lyr_in=ds_in.GetLayer( 0 )
        drv=ds_in.GetDriver()
        if os.path.exists( outfile ):
            drv.DeleteDataSource(outfile)
        ds_out = drv.CreateDataSource( outfile )
        layer = ds_out.CreateLayer(lyr_in.GetLayerDefn().GetName(),lyr_in.GetSpatialRef(), ogr.wkbPolygon)
        for i in range ( lyr_in.GetLayerDefn().GetFieldCount() ):
            field_in = lyr_in.GetLayerDefn().GetFieldDefn( i )
            fielddef = ogr.FieldDefn( field_in.GetName(), field_in.GetType() )
            layer.CreateField ( fielddef )
        for feat in lyr_in:
            geom = feat.GetGeometryRef()
            feature = feat.Clone()
            feature.SetGeometry(geom.Buffer(float(buffdist)))
            layer.CreateFeature(feature)
            del geom
        ds_out.Destroy()
    except:
        return False
    return True


def shapefile_obs_to_np_array(file_list,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Obstacle = np.zeros((nrows,ncols),dtype=np.int)
    #Loop on all shaefile
    for shp in file_list:        
        # Get shapefile info
        source_ds = ogr.Open(shp)
        source_layer = source_ds.GetLayer()    
        source_srs = source_layer.GetSpatialRef()
        source_type = source_layer.GetGeomType()
        # Create copy
        target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
        layerName = os.path.splitext(os.path.split(shp)[1])[0]
        layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
        layerDefinition = layer.GetLayerDefn()
        new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
        layer.CreateField(new_field)
        ind=0
        for feat in source_layer:
            geometry = feat.GetGeometryRef()
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(ind)
            feature.SetField('Transfo',1)
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            feature.Destroy()
            ind +=1
        # Initialize raster
        maskvalue = 1    
        xres=float(Csize)
        yres=float(Csize)
        geotransform=(xmin,xres,0,ymax,0, -yres)         
        target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
        target_ds.SetGeoTransform(geotransform)
        if source_srs:
            # Make the target raster have the same projection as the source
            target_ds.SetProjection(source_srs.ExportToWkt())
        else:
            # Source has no projection (needs GDAL >= 1.7.0 to work)
            target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        # Rasterize
        err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
        if err != 0:
            raise Exception("error rasterizing layer: %s" % err)
        else:
            target_ds.FlushCache()
            mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        Obstacle = Obstacle + mask_arr
        target_ds1.Destroy()
        source_ds.Destroy()
    Obstacle = np.int8(Obstacle>0)
    return Obstacle


def shapefile_to_int8array(file_name,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Array = np.zeros((nrows,ncols),dtype=np.int8)      
    # Get shapefile info
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    source_type = source_layer.GetGeomType()
    # Create copy
    target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
    layerName = "shp"
    layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Transfo',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Initialize raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)         
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        Array = target_ds.GetRasterBand(1).ReadAsArray()
    target_ds1.Destroy()
    source_ds.Destroy()
    return Array


def raster_to_ASCII_int(raster_name,ascii_name):
    source_ds = gdal.Open(raster_name)
    content = source_ds.GetRasterBand(1).ReadAsArray()
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform() 
    ymin = ymax + Csize_y*source_ds.RasterYSize
    names = ['ncols','nrows','xllcorner','yllcorner','cellsize','NODATA_value']
    values = [source_ds.RasterXSize,source_ds.RasterYSize,xmin,ymin,Csize_x,-9999]
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    content[content==nodata]=-10000
    head_text=generate_head_text(names,values,Csize_x)
    save_integer_ascii(ascii_name,head_text,np.int_(content+0.5))


def raster_to_ASCII(raster_name,ascii_name):
    source_ds = gdal.Open(raster_name)
    content = source_ds.GetRasterBand(1).ReadAsArray()
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform()   
    ymin = ymax + Csize_y*source_ds.RasterYSize
    names = ['ncols','nrows','xllcorner','yllcorner','cellsize','NODATA_value']
    values = [source_ds.RasterXSize,source_ds.RasterYSize,xmin,ymin,Csize_x,-9999]
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    content[content==nodata]=-9999    
    head_text=generate_head_text(names,values,Csize_x)
    save_float_ascii(ascii_name,head_text,content)


def resample_raster(in_file_name,out_file_name,newCsize,methode=gdal.GRA_Bilinear):
    # Get info from source
    source_ds = gdal.Open(in_file_name)    
    driver = source_ds.GetDriver()
    src_proj = source_ds.GetProjection()
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform()
    xmin,ymax = int(xmin+0.5),int(ymax+0.5)    
    Bandnb = source_ds.RasterCount    
    # Create ouptut raster
    xres=float(newCsize)
    yres=float(newCsize)
    xmax,ymin = xmin+int(float(src_ncols)*float(Csize_x)+0.5),ymax+int(float(src_nrows)*float(Csize_y)-0.5)
    nrows,ncols = int((ymax-ymin)/float(newCsize)+0.5),int((xmax-xmin)/float(newCsize)+0.5) 
    geotransform=(xmin,xres,0,ymax,0,-yres)    
    if os.path.exists(out_file_name):driver.Delete(out_file_name)
    target_ds = driver.Create(out_file_name, int(ncols), int(nrows), Bandnb, gdal.GDT_Float32)    
    target_ds.SetGeoTransform(geotransform)
    if src_proj:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(src_proj)
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        src_proj = 'LOCAL_CS["arbitrary"]'    
    gdal.ReprojectImage(source_ds, target_ds, src_proj, src_proj, methode)
    target_ds.GetRasterBand(1).SetNoDataValue(0)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache() # Flush 


def get_proj_from_road_network(road_network_file):
    source_ds = ogr.Open(road_network_file)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    return source_srs.ExportToWkt()


def ArrayToGtiff(Array,file_name,Extent,nrows,ncols,road_network_proj,nodata_value,raster_type='INT32'):
    xmin,xmax,ymin,ymax=Extent[0],Extent[1],Extent[2],Extent[3]
    xres=(xmax-xmin)/float(ncols)
    yres=(ymax-ymin)/float(nrows)
    geotransform=(xmin,xres,0,ymax,0, -yres)
    if raster_type=='INT32':
        #-2147483648 to 2147483647
        DataType = gdal.GDT_Int32    
    elif raster_type=='UINT8':
        #0 to 255
        DataType = gdal.GDT_Byte
    elif raster_type=='UINT16':
        #0 to 65535    
        DataType = gdal.GDT_UInt16
    elif raster_type=='INT16':
        #-32768 to 32767 
        DataType = gdal.GDT_Int16
    elif raster_type=='FLOAT32':
        #Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
        DataType = gdal.GDT_Float32
    elif raster_type=='FLOAT16':
        #Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
        DataType = gdal.GDT_Float16
    target_ds = gdal.GetDriverByName('GTiff').Create(file_name+'.tif', int(ncols), int(nrows), 1, DataType)
    target_ds.SetGeoTransform(geotransform)
    target_ds.SetProjection(road_network_proj)
    target_ds.GetRasterBand(1).WriteArray( Array )
    target_ds.GetRasterBand(1).SetNoDataValue(nodata_value)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache()


def focal_stat(in_file_name,out_file_name,methode='MEAN',nbcell=3):    
    # Get info of the input raster
    source_ds = gdal.Open(in_file_name)
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    driver = source_ds.GetDriver()
    src_proj = source_ds.GetProjection()
    nrows,ncols = source_ds.RasterYSize,source_ds.RasterXSize
    geotransform = source_ds.GetGeoTransform()
    Bandnb = source_ds.RasterCount   
    Data = source_ds.GetRasterBand(1).ReadAsArray()  
    #Make analysis
    if methode=='MEAN':
        outData = fc.focal_stat_mean(np.float_(Data),float(nodata),nbcell)
    elif methode=='MIN':
        outData = fc.focal_stat_min(np.float_(Data),float(nodata),nbcell)
    elif methode=='MAX':
        outData = fc.focal_stat_max(np.float_(Data),float(nodata),nbcell) 
    elif methode=='NB':
        outData = fc.focal_stat_nb(np.float_(Data),float(nodata),nbcell)   
    elif methode=='SUM':
        outData = fc.focal_stat_sum(np.float_(Data),float(nodata),nbcell)   
    #Inititialiaze output raster
    if os.path.exists(out_file_name):driver.Delete(out_file_name)
    target_ds = driver.Create(out_file_name, int(ncols), int(nrows), Bandnb, gdal.GDT_Float32)    
    target_ds.SetGeoTransform(geotransform)
    if src_proj:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(src_proj)
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        src_proj = 'LOCAL_CS["arbitrary"]' 
    target_ds.GetRasterBand(1).WriteArray(outData)
    target_ds.GetRasterBand(1).SetNoDataValue(nodata)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache() # Flush


####################################################
#  ______     ___      .______    __       _______ #
# /      |   /   \     |   _  \  |  |     |   ____|#
#|  ,----'  /  ^  \    |  |_)  | |  |     |  |__   #
#|  |      /  /_\  \   |   _  <  |  |     |   __|  #
#|  `----./  _____  \  |  |_)  | |  `----.|  |____ #
# \______/__/     \__\ |______/  |_______||_______|#
####################################################                                                  
# Fonctions qui gère les calculs liés au cable
def Cable(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,file_Vol_ha,file_Vol_AM,file_Htree,Pente_max_bucheron,
                  Lmax,Lmin,LminSpan,Htower,Hintsup,Hend,Lhor_max,Hline_min,Hline_max,sup_max,Carriage_type,Cable_type,slope_grav,
                  Pchar,slope_Wliner_up,slope_Wliner_down,q1,rupt_res,safe_fact,E,d,Load_max,q2,q3,Max_angle,coeff_frot,language,
                  precision,prelevement,slope_trans,angle_transv,test_cable_optimise,w_list,lim_list,VariaH,Lslope,PropSlope):
    console_info("Cable")
        if language=='FR':
        print("Debut de Sylvaccess-Cable")
    else:
        print("Sylvaccess cable crane starts")
    
    Hdebut = datetime.datetime.now()
    Dir_temp = Wspace+"Temp/"  
    ### Check if temporary files have been generated and have the same extent
    try:
        names,values,proj,Extent = raster_get_info(file_MNT)
        Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    except:
        if language=='EN':  
            print("Error: please define a projection for the DTM raster")
        else:
            print("Erreur: veuillez definir une projection pour le raster MNT")
        return ""
    try: 
        n,v1=read_info(Dir_temp+'info_extent.txt')
        for i,item in enumerate(values):
            if v1[i]!=round(item,2):
                prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,Pente_max_bucheron,language)
            if i+1>4:break
    except:
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,Pente_max_bucheron,language)
    
    # Inputs
    try:
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))                
        MNT= np.load(Dir_temp+"MNT.npy") 
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy") 
        try:
            Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        except:
            Aspect = np.uint16(fc.exposition(MNT,Csize,-9999))    
        try:
            CoordRoute= np.load(Dir_temp+"CoordRoute.npy") 
        except:
            TableX,TableY=create_coord_pixel_center_raster(values,nrows,ncols,Csize,Dir_temp)
            CoordRoute = np.zeros((Lien_RF.shape[0],2),dtype=np.float)
            for i,pixel in enumerate(Lien_RF):
                CoordRoute[i,0]=TableX[pixel[1]]
                CoordRoute[i,1]=TableY[pixel[0]] 
            np.save(Dir_temp+"CoordRoute.npy",CoordRoute) 
            del TableX,TableY
        try:
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
        except:
            Pente = np.uint16(prepa_obstacle_cable(Dir_Obs_cable,file_MNT,Dir_temp))
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
    except: 
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,Pente_max_bucheron,language)
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))
        Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))         
        MNT= np.load(Dir_temp+"MNT.npy") 
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy")  
        CoordRoute= np.load(Dir_temp+"CoordRoute.npy")
        Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)    

    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    
     
    ### Import optional files
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
        Vol_ha[Pente>Pente_max_bucheron]=0 
        test_vp = True
    else:test_vp = False
    if file_Vol_AM != "":
        Vol_AM = load_float_raster_simple(file_Vol_AM) 
        Vol_AM[Pente>Pente_max_bucheron]=0
        test_vam = True
    else:test_vam = False 
    if file_Htree != "":
        Hfor = load_float_raster_simple(file_Htree) 
        test_hfor = True
    else:
        Hfor=0
        test_hfor = False
    if test_vp or test_vam:
        if not test_vp:
            Vol_ha = np.zeros_like(MNT)
        if not test_vam:
            Vol_AM = np.zeros_like(MNT)


    Lmax2 = round(Lmax-(sqrt(2)*(max(np.max(Hfor)*0.6666,Hend)+5)),0) #In order to take into account anchorage
    Row_line,Col_line,D_line,Nbpix_line, Row_ext,Col_ext,D_ext,Dir_list=create_buffer(Csize,Lmax2,Lhor_max)    
    road_network_proj=get_proj_from_road_network(file_shp_Cable_dep)
    Skid_direction = 0
    Rspace_c,filename,slope_min_up,slope_max_up,slope_min_down,slope_max_down=get_cable_configs(Rspace,slope_Wliner_up,
                                                                                       slope_Wliner_down,slope_grav,
                                                                                       Cable_type,Carriage_type,
                                                                                       Skid_direction,language) 
    try:os.mkdir(Rspace_c)
    except:pass
    Rspace_c+="/"
#    f = open(filename, 'w')
#    f.close()
    Rspace_sel = Rspace_c+"FilesForOptimisation"
    try:os.mkdir(Rspace_sel)
    except:pass
    Rspace_sel+="/"
    save_raster_info(values,Rspace_sel)
#    write_file(Rspace_c,Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,file_Vol_ha,
#               file_Vol_AM,Pente_max_bucheron,Lmax,Lmin,LminSpan,Htower,Hintsup,Hend,Lhor_max,Hline_min,
#               Hline_max,sup_max,Carriage_type,Cable_type,slope_grav,Pchar,slope_Wliner_up,slope_Wliner_down,
#               q1,rupt_res,safe_fact,E,d,Load_max,q2,q3,Max_angle,coeff_frot,language,Skid_direction,precision,
#               prelevement,slope_trans,angle_transv)
    ### Calculation of useful variables
    g = 9.80665     # m.s-2
    angle_intsup = radians(Max_angle) 
    Fo =  g*(Load_max+Pchar)
    Lsans_foret = min(Lmax*0.1,Lmin)          # Longueur max contigue sans foret
    Ao = 0.25*pi*(d**2) 
    Tmax = float(rupt_res)*g/float(safe_fact)
    EAo = E*Ao
    idLinemin = np.max([1,int(LminSpan/Csize+1.5),int(10/Csize+0.5)])
    
    # D H diag slope fact indmin indmax LoL ThL TvL TupL TdownL LoUg ThUg TvUg ind_fin_span free xmidL zmidL 
    # 0 1 2    3     4    5      6      7   8   9   10   11     12   13   14   15           16   17    18  
    Span = np.zeros((sup_max+1,16),dtype=np.float)
    rastLosup,rastTh,rastTv= check_tabconv(Dir_temp,d,E,Tmax,Lmax2,Fo,q1,q2,q3,Csize)    
    
    ### Preparation of forest roads
    nbconfig = 5       
    if precision > 1:Dir_list = range(0,360,2)
    if precision == 3:
        step_route = 2
        nbconfig = 1       
    else:
        step_route = 1
    nb_pixel_route = int((Lien_RF.shape[0]-1)/float(step_route))    
    
    Fin_ligne_forcee = np.int8(np.greater(Aerian_obs+(MNT<0),0))
    
    if language=='FR':
        print("    - Initialisation achevee, debut de traitement...")
        str_nb_pixel_route=  " / "+str(nb_pixel_route-1)+ " pixels traites"
    else:
        print("    - Initialization achieved, processing...")
        str_nb_pixel_route=  " / "+str(nb_pixel_route-1)+ " pixels processed"
    
    Tab = np.zeros((min(1000000,int(nb_pixel_route*(360)/step_route)),18+5*sup_max),dtype=np.int)
    File_Tab = []
    Tab_nb=0
    
    testExist = False
    if np.sum(Lien_RF[:,2]==1)>0:
        testExist = True
    
    ##############################################################################################################################################
    ### 2. PROCESSING OF THE AREA: TEST ALL POSSIBLE LINES
    ##############################################################################################################################################
    
    # Loop on forest road pixels
    Route = range(1,Lien_RF.shape[0]-1,step_route)
    id_line = 0
    Rast_couv = np.zeros((nrows,ncols),dtype=np.int8)
    if testExist:
        Rast_couv2 = np.zeros((nrows,ncols),dtype=np.int8)
    test=0
    for idpix,pixel in enumerate(Route):  
        # Print process
        sys.stdout.write("\r%d" % idpix + str_nb_pixel_route)
        sys.stdout.flush()
        #Get point coordinates
        coordY = Lien_RF[pixel,0]
        coordX = Lien_RF[pixel,1]
        direction = Lien_RF[pixel,4]
        if MNT[coordY,coordX]>-9999 and not Aerian_obs[coordY,coordX]:             
            RoadState = Lien_RF[pixel,2]
            posiY = CoordRoute[pixel,1]
            posiX = CoordRoute[pixel,0]   
            for az in Dir_list:                                          
                test,Lline,Line = get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax2,Lmin,Csize,
                                             Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
                                             Fo,Tmax,q1,q2,q3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope)   
                if test==1:           
                    Span*=0    
                    Falt = InterpolatedUnivariateSpline(Line[:,0],Line[:,1])
                    Alts = Falt(np.arange(0.,Lline,0.5))
                    ### Optimize line
                    if Line[0,1]+Htower>=np.max(Line[idLinemin:,1])+Hend:   
                        if direction==2:
                            continue
                        #print az,"up",Line[-1,0] 
                        if VariaH:
                            Span = fc.OptPyl_Up(Line,Alts,Span,Htower,Hintsup,Hend,q1,q2,q3,Fo,Hline_min,Hline_max,
                                                 Csize,angle_intsup,EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                 LminSpan,slope_min_up,slope_max_up,Lmax2,test_hfor,nbconfig)
                        else:
                            Span = fc.OptPyl_Up_NoH(Line,Alts,Span,Htower,Hintsup,Hend,q1,q2,q3,Fo,Hline_min,Hline_max,
                                                     Csize,angle_intsup,EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                     LminSpan,slope_min_up,slope_max_up,Lmax2,test_hfor,nbconfig)
                        config = 1
                    else:    
                        if direction==1:
                            continue
                        #print az,"down",Line[-1,0]
                        if VariaH:
                            Span = fc.OptPyl_Down_init(Line,Alts,Span,Htower,Hintsup, Hend,q1,q2,q3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo, E, d,
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,Lmax2,test_hfor)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = fc.OptPyl_Down(Line2,Alts,Span*0,Htower,Hintsup,Hend,q1,q2,q3,Fo,Hline_min,Hline_max,Csize,angle_intsup,
                                                   EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan, min(-slope_min_down,-slope_max_down),
                                                   max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                        else:
                            Span = fc.OptPyl_Down_init_NoH(Line,Alts,Span,Htower,Hintsup, Hend,q1,q2,q3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo, E, d,
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,Lmax2,test_hfor,nbconfig)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = fc.OptPyl_Down_NoH(Line2,Alts,Span*0,Htower,Hintsup,Hend,q1,q2,q3,Fo,Hline_min,Hline_max,Csize,
                                                       angle_intsup,EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,min(-slope_min_down,-slope_max_down),
                                                       max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                    ind_max_Line = int(np.max(Span[:,15]))                    
                    if Span[0,0]==0 or np.sum(Span[:,2])<Lmin or Line[ind_max_Line,8]==0:
                        test=0
                        continue                    
                    nbintsup = np.sum(Span[:,0]>0)-1
                    ### Save Line carac
                    Line = Line[0:ind_max_Line+1]
                    Lline = Line[ind_max_Line,0]                    
                    if test_vp or test_vam:    
                        if RoadState==2:
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv = fc.get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv,Vol_ha,Vol_AM)
                        else: 
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv2 = fc.get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2,Vol_ha,Vol_AM)
                    else:
                        if RoadState==2:
                            Distance_moyenne,Surface,Rast_couv = fc.get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv)
                        else:
                            Distance_moyenne,Surface,Rast_couv2 = fc.get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2)
                    #pixel, direction
                    Tab[id_line,0],Tab[id_line,1] = pixel,az
                    #Xstart,Ystart,Zstart,Hcable_start
                    Tab[id_line,2],Tab[id_line,3],Tab[id_line,4],Tab[id_line,5]=Line[0,3],Line[0,4],Line[0,1],Htower
                    #Xend,Yend,Zend,Hcable_end
                    Tab[id_line,6],Tab[id_line,7],Tab[id_line,8],Tab[id_line,9] = Line[ind_max_Line,3],Line[ind_max_Line,4],Line[ind_max_Line,1],Span[nbintsup,14]
                    #Road existing or not,Ltot,Config
                    Tab[id_line,10],Tab[id_line,11],Tab[id_line,12] = int(RoadState),int(np.sum(Span[:,2])+0.5),config
                    #Surface foret Dmoy chariot
                    Tab[id_line,13],Tab[id_line,14]=Surface,Distance_moyenne
                    #Vtot IPC
                    if test_vp:
                        Tab[id_line,15]=Vtot
                    #VAM               
                    if test_vam:
                        Tab[id_line,16]=VAM*10
                    #Int sup info  
                    Tab[id_line,17]=nbintsup
                    for pyl in range(0,nbintsup):
                        Tab[id_line,18+5*pyl]=Line[int(Span[pyl,15]),3]#X
                        Tab[id_line,19+5*pyl]=Line[int(Span[pyl,15]),4]#Y
                        Tab[id_line,20+5*pyl]=Line[int(Span[pyl,15]),1]#Alts
                        Tab[id_line,21+5*pyl]=Span[pyl,14]#Hcable
                        Tab[id_line,22+5*pyl]=atan(abs(Span[pyl,3]-Span[pyl+1,3]))*Span[pyl,10]+Fo#Press
                    id_line+=1
                    if id_line == 1000000:                        
                        np.save(Dir_temp+"Tab"+str(Tab_nb)+".npy",Tab[Tab[:,11]>0])
                        File_Tab.append(Dir_temp+"Tab"+str(Tab_nb)+".npy")
                        Tab_nb +=1
                        id_line=0
                        Tab = np.zeros((1000000,18+5*sup_max),dtype=np.int)

   
    if language=='FR':
        print("\n    - Sauvegarde des resultats")
    else:
        print("\n    - Saving the results")
   
    ### Save Forest,Vol_ha,VolAm,Pente
    np.save(Rspace_sel+"Forest.npy",Forest)
    if test_vp:
        np.save(Rspace_sel+"Vol_ha.npy",Vol_ha)
    if test_vam:
        np.save(Rspace_sel+"Vol_AM.npy",Vol_AM)
    np.save(Rspace_sel+"Pente.npy" ,Pente)
    np.save(Rspace_sel+"Lien_RF_c.npy",Lien_RF)
    ### Del useless    
    try:
        del Line2
    except:
        pass
    del rastLosup,rastTh,rastTv,Row_line,Col_line,D_line,Nbpix_line,CoordRoute,Aerian_obs,Lien_RF
    gc.collect()
    ### Save results
    Tab = Tab[Tab[:,11]>0]
    if Tab_nb>0:
        for files in File_Tab:
            Tabbis = np.load(files)
            Tab = np.concatenate((Tab,Tabbis))
    np.save(Rspace_sel+"Tab_all_lines.npy",Tab)    
    
    if testExist :        
        Rast_couv += 10*Rast_couv2
        Rast_couv[Rast_couv==11]=2
        Rast_couv[Rast_couv==1]=2
        Rast_couv[Rast_couv==10]=1
    
    if not test_vp:
        Vol_ha=np.zeros_like(MNT)    
    else:
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
    generate_info_cable_simu(Rspace_c,Tab,language,Rast_couv,Vol_ha,Csize,Forest,Pente,Pente_max_bucheron)
    
    ### Del useless   
    del Forest,Pente,Line,Alts,Span,MNT,Fin_ligne_forcee,Aspect,Falt
    try:
        del Vol_ha,Vol_AM,Rast_couv2 
    except:
        pass
    
    #Save Global res        
    if language=='FR':
        header = 'ID_pixel Azimuth X_debut Y_debut Alt_debut Hcable_debut X_fin Y_fin Alt_fin Hcable_fin '
        header +='Etat_RouteFor Longueur_reelle Configuration '
        header +='Surface_foret Distance_moy_chariot Volume_total VAM NB_int_sup'
        for num in range(1,sup_max+1):
            header +=' '+'Xcoord_intsup'+str(num)+' Ycoord_intsup'+str(num)+' Alt_intsup'+str(num)
            header +=' '+'Hcable_intsup'+str(num)+' Pression_intsup'+str(num)
        filename=Rspace_c+"Database_toutes_lignes.gzip"
        shape_name = Rspace_c+"Toutes_les_lignes.shp"
        rast_name = Rspace_c+'Zone_accessible'
        
    else:
        header = 'ID_pixel Azimuth X_Start Y_Start Elevation_Start Hcable_Start X_End Y_End Elevation_End Hcable_End '
        header +='Existing_road Cable_length Configuration '
        header +='Forest_area Carriage_average_distance Volume_total ATV NB_int_sup'
        for num in range(1,sup_max+1):
            header +=' '+'Xcoord_intsup'+str(num)+' Ycoord_intsup'+str(num)+' Elevation_intsup'+str(num)
            header +=' '+'Hcable_intsup'+str(num)+' Pression_intsup'+str(num)
        filename=Rspace_c+"Database_All_lines.gzip"
        shape_name = Rspace_c+"All_lines.shp"
        rast_name = Rspace_c+'Accessible_area'
            
    
    ArrayToGtiff(Rast_couv,rast_name,Extent,nrows,ncols,road_network_proj,0,'UINT8')
    header+='\n'
    save_integer_ascii(filename,header,Tab)
    source_src=get_source_src(file_shp_Cable_dep) 
    Line_to_shapefile(Tab[0:2],Rspace_sel+"info_proj.shp",source_src,0,language)
    if Tab.shape[0]<1000000:         
        Line_to_shapefile(Tab,shape_name,source_src,prelevement,language)
    
    ##############################################################################################################################################
    ### 3. CREATE SIMULATION PARAMETER FILE
    ##############################################################################################################################################
    str_duree,str_fin,str_debut=heures(Hdebut,language)
    
    if language == 'FR':
        if Carriage_type==1:
            carriage_name = 'Automoteur'
        else:
            carriage_name = 'Classique'
        if Cable_type <3:
            cable_name= 'Cable mat'
        else:
            cable_name= 'Cable long/conventionnel'
        
        file_name = str(Rspace_c)+"Parametre_simulation.txt"
        resume_texte = "SYLVACCESS - CABLE\n\n\n"
        resume_texte = resume_texte+"Version du programme: 3.5.1 de 12/2021\n"
        resume_texte = resume_texte+"Auteur: Sylvain DUPIRE. Irstea\n\n"
        resume_texte = resume_texte+"Date et heure de lancement du script:                                      "+str_debut+"\n"
        resume_texte = resume_texte+"Date et heure a la fin de l'execution du script:                           "+str_fin+"\n"
        resume_texte = resume_texte+"Temps total d'execution du script:                                         "+str_duree+"\n\n"
        resume_texte = resume_texte+"PROPRIETES DU MATERIEL MODELISE:\n"
        resume_texte = resume_texte+"   - Type de machine:                                                      "+str(cable_name)+"\n"
        resume_texte = resume_texte+"   - Hauteur du mat ou du cable porteur au niveau de la place de depot:    "+str(Htower)+" m\n"
        resume_texte = resume_texte+"   - Nombre maximum de support(s) intermediaire(s):                        "+str(sup_max)+"\n"
        resume_texte = resume_texte+"   - Longueur maximale du cable porteur:                                   "+str(Lmax)+" m\n"
        resume_texte = resume_texte+"   - Longueur minimale d'une ligne:                                        "+str(Lmin)+" m\n"
        resume_texte = resume_texte+"   - Longueur minimale entre deux supports:                                "+str(LminSpan)+" m\n"
        resume_texte = resume_texte+"   - Type de chariot:                                                      "+str(carriage_name)+"\n"
        resume_texte = resume_texte+"   - Masse a vide du chariot:                                              "+str(Pchar)+" kg\n"
        resume_texte = resume_texte+"   - Masse maximale de la charge:                                          "+str(Load_max)+" kg\n"
        if Carriage_type==1:   
            resume_texte = resume_texte+"   - Pente max du cable porteur pour un debardage vers l'amont:            "+str(slope_Wliner_up)+" %\n"    
            resume_texte = resume_texte+"   - Pente max du cable porteur pour un debardage vers l'aval:             "+str(slope_Wliner_down)+" %\n"   
        else: 
            resume_texte = resume_texte+"   - Pente min du cable porteur pour que le chariot descende par gravite:  "+str(slope_grav)+" %\n"  
        resume_texte = resume_texte+"\n"
        resume_texte = resume_texte+"PROPRIETES DU CABLE PORTEUR:\n"    
        resume_texte = resume_texte+"   - Diametre du cable porteur:                                            "+str(d)+" mm\n"
        resume_texte = resume_texte+"   - Masse lineique du cable porteur:                                      "+str(q1)+" kg.m-1\n"
        resume_texte = resume_texte+"   - Module de Young (Elasticite):                                         "+str(E)+" N.mm-2\n"
        resume_texte = resume_texte+"   - Tension de rupture du cable porteur                                   "+str(rupt_res)+" kgF\n\n"
        if Carriage_type!=1:
            resume_texte = resume_texte+"PROPRIETES DES CABLES TRACTEUR ET RETOUR:\n"  
            resume_texte = resume_texte+"   - Masse lineique du cable tracteur:                                     "+str(q2)+" kg.m-1\n"
            resume_texte = resume_texte+"   - Masse lineique du cable retour:                                       "+str(q3)+" kg.m-1\n"
            resume_texte = resume_texte+"\n"        
        resume_texte = resume_texte+"PARAMETRES DE MODELISATION:\n"
        resume_texte = resume_texte+"   - Distance laterale de pechage des bois:                                "+str(Lhor_max)+" m\n"
        resume_texte = resume_texte+"   - Hauteur du cable porteur au niveau des pylone intermediaire:          "+str(Hintsup)+" m\n"
        resume_texte = resume_texte+"   - Hauteur du cable porteur en fin de ligne:                             "+str(Hend)+" m\n"
        resume_texte = resume_texte+"   - Hauteur minimale du cable en tout point (en charge):                  "+str(Hline_min)+" m\n"
        resume_texte = resume_texte+"   - Hauteur maximale du cable en tout point:                              "+str(Hline_max)+" m\n"
        resume_texte = resume_texte+"   - Angle maximum du cable porteur au niveau d'un pylone intermediaire:   "+str(Max_angle)+" degres\n"
        resume_texte = resume_texte+"   - Facteur de securite:                                                  "+str(safe_fact)+"\n"
        resume_texte = resume_texte+"   - Valeur de l'angle de frottement:                                      "+str(coeff_frot)+" rad\n\n"
        resume_texte = resume_texte+"   - Resolution du MNT utilise:                                            "+str(Csize)+" m\n"
        resume_texte = resume_texte+"   - Prelevement du volume sur pied applique:                              "+str(prelevement*100)+" %\n"
        try:
            resume_texte = resume_texte+"   - Projection:                                                           "+str(proj.GetAttrValue("PROJCS", 0))+"\n"
        except:
            resume_texte = resume_texte+"   - Projection:                                                           inconnue\n"
        if Dir_Obs_cable=="":
            reponse = "Non"
        else:
            reponse = "Oui"
        resume_texte = resume_texte+"   - Prise en compte d'obstacle pour le cable:                             "+str(reponse)+"\n"
        if file_Vol_ha=="":
            reponse = "Non"
        else:
            reponse = "Oui"
        resume_texte = resume_texte+"   - Information sur le volume de bois fournie en entree:                  "+str(reponse)+"\n"
    
    elif language == 'EN':
        if Carriage_type==1:
            carriage_name = 'Self-motorized'
        else:
            carriage_name = 'Classical'
        if Cable_type <3:
            cable_name= 'Cable tower'
        else:
            cable_name= 'Long/conventional cable'
        
        file_name = str(Rspace_c)+"Parameter_of_simulation.txt"
        resume_texte = "SYLVACCESS - CABLE\n\n\n"
        resume_texte = resume_texte+"Program version: 3.5.1 - 2021/12\n"
        resume_texte = resume_texte+"Author: Sylvain DUPIRE. Irstea\n\n"
        resume_texte = resume_texte+"Date and time when launching the script:                          "+str_debut+"\n"
        resume_texte = resume_texte+"Date and time at the end of execution of the script:              "+str_fin+"\n"
        resume_texte = resume_texte+"Total execution time of the script:                               "+str_duree+"\n\n"
        resume_texte = resume_texte+"TYPE OF MATERIAL MODELED:\n"
        resume_texte = resume_texte+"   - Type of machine:                                             "+str(cable_name)+"\n"
        resume_texte = resume_texte+"   - Height of the skyline at landing place:                      "+str(Htower)+" m\n"
        resume_texte = resume_texte+"   - Maximum number of intermediate support(s):                   "+str(sup_max)+"\n"
        resume_texte = resume_texte+"   - Maximum length of the skyline:                               "+str(Lmax)+" m\n"
        resume_texte = resume_texte+"   - Minimum length of a line:                                    "+str(Lmin)+" m\n"
        resume_texte = resume_texte+"   - Minimal length between two supports:                         "+str(LminSpan)+" m\n"
        resume_texte = resume_texte+"   - Carriage type:                                               "+str(carriage_name)+"\n"
        resume_texte = resume_texte+"   - Carriage weight when empty:                                  "+str(Pchar)+" kg\n"
        resume_texte = resume_texte+"   - Maximum weight of the load:                                  "+str(Load_max)+" kg\n"
        if Carriage_type==1:   
            resume_texte = resume_texte+"   - Maximum slope of the skyline for an uphill yarding:          "+str(slope_Wliner_up)+" %\n"    
            resume_texte = resume_texte+"   - Maximum slope of the skyline for an downhill yarding:        "+str(slope_Wliner_down)+" %\n"   
        else:
            resume_texte = resume_texte+"   - Minimum slope for a gravity descent of the carriage:         "+str(slope_grav)+" %\n"  
        resume_texte = resume_texte+"\n"
        resume_texte = resume_texte+"SKYLINE PROPERTIES:\n"    
        resume_texte = resume_texte+"   - Skyline diameter:                                            "+str(d)+" mm\n"
        resume_texte = resume_texte+"   - Skyline self-weight:                                         "+str(q1)+" kg.m-1\n"
        resume_texte = resume_texte+"   - Young Modulus (Elasticity):                                  "+str(E)+" N.mm-2\n"
        resume_texte = resume_texte+"   - Skyline maximum tensile force                                "+str(rupt_res)+" kgF\n\n"
        if Carriage_type!=1:
            resume_texte = resume_texte+"MAINLINE AND HAULBACK LINE PROPERTIES:\n"  
            resume_texte = resume_texte+"   - Mainline self-weight:                                        "+str(q2)+" kg.m-1\n"
            resume_texte = resume_texte+"   - Haulback line self-weight:                                   "+str(q3)+" kg.m-1\n"
            resume_texte = resume_texte+"\n"        
        resume_texte = resume_texte+"MODELING PARAMETERS:\n"
        resume_texte = resume_texte+"   - Lateral skidding distance:                                   "+str(Lhor_max)+" m\n"
        resume_texte = resume_texte+"   - Skyline height at intermediaite support(s):                  "+str(Hintsup)+" m\n"
        resume_texte = resume_texte+"   - Skyline height at tailspar:                                  "+str(Hend)+" m\n"
        resume_texte = resume_texte+"   - Minimun height of the load along the profile:                "+str(Hline_min)+" m\n"
        resume_texte = resume_texte+"   - Maximun height of the skyline along the profile:             "+str(Hline_max)+" m\n"
        resume_texte = resume_texte+"   - Maximum angle of the skyline at intermediate support level:  "+str(Max_angle)+" degrees\n"
        resume_texte = resume_texte+"   - Safety coefficient:                                          "+str(safe_fact)+"\n"
        resume_texte = resume_texte+"   - Friction angle value:                                        "+str(coeff_frot)+" rad\n\n"
        resume_texte = resume_texte+"   - DTM resolution:                                              "+str(Csize)+" m\n"
        resume_texte = resume_texte+"   - Proportion of wood volume removed:                           "+str(prelevement*100)+" %\n"
        try:
            resume_texte = resume_texte+"   - Projection:                                                  "+str(proj.GetAttrValue("PROJCS", 0))+"\n"
        except:
            resume_texte = resume_texte+"   - Projection:                                                  Unknown\n"
        if Dir_Obs_cable=="":
            reponse = "No"
        else:
            reponse = "Yes"
        resume_texte = resume_texte+"   - Modeling done taking into account cable obstacles:           "+str(reponse)+"\n"
        if file_Vol_ha=="":
            reponse = "No"
        else:
            reponse = "Yes"
        resume_texte = resume_texte+"   - Wood volume information given as input:                      "+str(reponse)+"\n"
    
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    
    file_name = Rspace_sel+"info_Lhormax.txt"
    fichier = open(file_name, "w")
    fichier.write(str(Lhor_max))
    fichier.close()
    
    
    if language=='FR':
        print("\nToutes les lignes possibles ont ete testees.\n")     
    else:
        print("\nAll the possible cable line have been processed.\n")
    ##############################################################################################################################################
    ### 4. SELECTION OF BEST LINE IF CHECKED
    ##############################################################################################################################################
    if test_cable_optimise:
        line_selection(Rspace_c,w_list,lim_list,0,file_shp_Foret,file_Vol_ha,file_Vol_AM,Lhor_max,prelevement,Pente_max_bucheron)



# Fonctions qui gère les calculs liés à l'optimisation des emplacements de cable
def Cable_opti():
    console_info("Cable_opti")


def prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize):
    rastLosup,rastTh,rastTv = fc.Tabmesh(d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize)
    np.save(Dir_temp+"rastLosup.npy",rastLosup)
    np.save(Dir_temp+"rastTh.npy",rastTh)
    np.save(Dir_temp+"rastTv.npy",rastTv)
    text  = "d    "+" "+str(round(d,2))+"\n"
    text += "E    "+" "+str(round(E,2))+"\n"
    text += "Tmax "+" "+str(round(Tmax,2))+"\n"
    text += "Lmax "+" "+str(round(Lmax,2))+"\n"
    text += "Fo   "+" "+str(round(Fo,2))+"\n"
    text += "Csize"+" "+str(round(Csize,2))+"\n"
    text += "q1   "+" "+str(round(q1,2))+"\n"
    text += "q2   "+" "+str(round(q2,2))+"\n"
    text += "q3   "+" "+str(round(q3,2))+"\n"
    f = open(Dir_temp+'info_config.txt',"w")
    f.write(text)
    f.close()
    return rastLosup,rastTh,rastTv


def check_tabconv(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize):
    try:
        a,v1=read_info(Dir_temp+"info_config.txt")
        if np.all(np.array([round(d,2),round(E,2),round(Tmax,2),round(Lmax,2),round(Fo,2),round(Csize,2),round(q1,2),round(q2,2),round(q3,2)])==v1):
            rastLosup = np.load(Dir_temp+"rastLosup.npy")
            rastTh = np.load(Dir_temp+"rastTh.npy")
            rastTv = np.load(Dir_temp+"rastTv.npy")
        else:
            rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize)
    except:
        rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize)        
    return rastLosup,rastTh,rastTv


def check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret):
    indmax = 0
    npix = Line.shape[0]
    test = 1
    i=0
    Lline=Lmin-1
    Dsansforet=0.
    for i in range(0,npix): 
        if Line[i,5]<0:break
        if Line[i,5]>=ncols:break
        if Line[i,6]<0:break
        if Line[i,6]>=nrows:break
        if Line[i,7]==1:break
        if sqrt(Line[i,0]*Line[i,0]+(Line[i,1]-Line[0,1])*(Line[i,1]-Line[0,1]))>Lmax:break        
        if (Line[i,8]+Line[i,9])>0:                 
            if Line[i,2]==1:
                indmax = i 
                Dsansforet=0
            else:
                if i>0: Dsansforet+=Line[i,0]-Line[i-1,0]
                if Dsansforet>=Lsans_foret:break
        else:        
            break
    Lline = Line[indmax,0]
    if Lline <= Lmin:
        test=0
    return test,indmax+1,Lline


def get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
              Fo,Tmax,q1,q2,q3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope):
                  
    npix = Nbpix_line[az]
    npix = fc.get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,11),dtype=np.float)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        ### Check pente en devers
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1 
        if test_hfor:
            Line[:,10]=np.round(np.minimum(np.maximum(-7.76961+0.71858*Hfor[inds],0),26))
        else:
            Line[:,10]=Hintsup
        ####Raccourci pour ne pas depasser Hline_max
        indmax=Line.shape[0]-1
        for i in range(indmax,1,-1):  
            test=1
            D = Line[i,0]
            H = abs(Line[0,1]+Htower-(Line[i,1]+Hend))    
            if Line[0,1]+Htower>=Line[i,1]+Hend:
                Xup,Zup =0,Line[0,1]+Htower
                fact = 1. 
            else:    
                Xup,Zup = Line[i,0],Line[i,1]+Hend
                fact = -1.             
            L=sqrt(H*H+D*D)
            F = 0.5*(0.5*L*q2+0.5*L*q3)*9.80665 + Fo  
            fleche = 1.1*(F*L/(4*Tmax)+q1*9.80665*L*L/(8*Tmax))
            for j in range(1,i-1):
                droite = -fact*H/D*(Line[j,0]-Xup)+Zup-Line[j,1]
                if droite-fleche > Hline_max:
                    test=0
                    break
            if test:
                break
        Line=Line[0:i+1]
        test,indmax,Lline=fc.check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret,Lslope,PropSlope)
        Lline = 2 # A modifier    
        return test,Lline,Line[0:indmax, [0, 1, 2, 3, 4, 5, 6,10,9]]
    else:
        return 0,0,0 


def return_profile(Line):
    Line2 = np.zeros_like(Line)
    indmax = Line.shape[0]-1
    Dmax =Line[indmax,0]
    for i,j in enumerate(range(indmax,-1,-1)):
        Line2[i]=Line[j]
        Line2[i,0]=Dmax-Line[j,0]
    return Line2


def write_file():
    Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP = Sylvaccess_pluginDialog.get_spatial(1,1,1,1,1,1,1,1,1,1,1,1,1,1)
    ski,por,cab,opti,pente = Sylvaccess_pluginDialog.get_general(1,1,1,1,1)
    pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes=Sylvaccess_pluginDialog.get_skidder(1,1,1,1,1,1,1,1)
    pente_max2,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes2=Sylvaccess_pluginDialog.get_porteur(1,1,1,1,1,1,1)
    type_machine,supports_inter,hauteur,longueure_max,longueure_min=Sylvaccess_pluginDialog.get_type_cable(1,1,1,1,1)
    type_chariot,masse,pente_min,pente_max_amont,pente_max_aval = Sylvaccess_pluginDialog.get_type_chariot(1,1,1,1,1,1)
    diamètre,masse_li,tension_rupt,elasticité = Sylvaccess_pluginDialog.get_proprietes_cable(1,1,1,1)
    hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite = Sylvaccess_pluginDialog.get_param_modelisation(1,1,1,1,1,1,1)
    opti2,precision = Sylvaccess_pluginDialog.get_options(1,1)
    prelevement,recalculer,Rspace2,foret2,VBP2,VAM2,pechage2 = Sylvaccess_pluginDialog.get_opti_cable(1,1,1,1,1,1,1)
    surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_pluginDialog.get_crit_opti(1,1,1,1,1,1,1,1)
    var_list= [Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP,ski,por,cab,opti,pente,pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,
               pente_amont_max,pente_aval_max,limite,bornes,pente_max2,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes2,type_machine,supports_inter,hauteur,
               longueure_max,longueure_min,type_chariot,masse,pente_min,pente_max_amont,pente_max_aval,diamètre,masse_li,tension_rupt,elasticité,hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,
               masse_max,securite,opti2,precision,prelevement,recalculer,Rspace2,foret2,VBP2,VAM2,pechage2,surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,
               longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids]
    file_name = Rspace2+"all_param.txt"
    text=var_list[0]
    for var in var_list[1:]:
        text+="\n"
        text+= str(var)
    fichier = open(file_name, "w")
    fichier.write(text)
    fichier.close()


def azimuth(X0,Y0,X1,Y1):
    dX=abs(X0-X1)
    dY=abs(Y0-Y1)
    #cas 1:cadran en haut a droite
    if (X1>X0) and (Y1>Y0):
        az=degrees(atan(dX*1.0/dY))
    #cas 2:cadran en bas a droite
    elif (X1>X0) and (Y1<Y0):
        az=180-degrees(atan(dX*1.0/dY))
    #cas 3:cadran en haut a gauche
    elif (X1<X0) and (Y1>Y0):
        az=360-degrees(atan(dX*1.0/dY)) 
    #cas 4:cadran en bas a gauche
    elif (X1<X0) and (Y1<Y0):
        az=180+degrees(atan(dX*1.0/dY)) 
    #cas 5:horizontal gauche
    elif (dY==0) and (X1>X0):
        az=90
    #cas 6:horizontal droite
    elif (dY==0) and (X1<X0):
        az=90*3
    #cas 7:vertical haut
    elif (Y1>=Y0) and (dX==0):
        az=0
    #cas 8:vertical bas
    elif (Y1<Y0) and (dX==0):
        az=180
    return az


def from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az):    
    X1 = sin(radians(az))*Lmax
    Y1 = cos(radians(az))*Lmax
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    line = ogr.Geometry(ogr.wkbLineString)
    line.AddPoint(0,0)
    line.AddPoint(X1,Y1)
    feature = ogr.Feature(layerDefinition)
    feature.SetGeometry(line)
    feature.SetFID(az)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return X1,Y1,mask_arr


def check_common_line(item,Row_line,Col_line,D_line,nb_pix):
    i=0
    while (Row_line[item-1,i]==Row_line[item,i]) and (Col_line[item-1,i]==Col_line[item,i]) and i<nb_pix:
        i+=1
    return D_line[item,i-1]


def pt_emprise(X0,Y0,X1,Y1,Lhor_max):
    az=azimuth(X0,Y0,X1,Y1)
    #deb + 90
    X = [X0+sin(radians(az+90))*Lhor_max]
    Y = [Y0+cos(radians(az+90))*Lhor_max]
    #deb - 90
    X.append(X0+sin(radians(az-90))*Lhor_max)
    Y.append(Y0+cos(radians(az-90))*Lhor_max)
    #fin - 90
    X.append(X1+sin(radians(az-90))*Lhor_max)
    Y.append(Y1+cos(radians(az-90))*Lhor_max)
    #fin + 90
    X.append(X1+sin(radians(az+90))*Lhor_max)
    Y.append(Y1+cos(radians(az+90))*Lhor_max)
    return [X,Y] 


def point_line_to_line_ext(X0,Y0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize):
    ### Create mask_array
    X,Y = pt_emprise(X0,Y0,X1,Y1,Lhor_max)
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbPolygon)
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    # create polygon object:
    myRing = ogr.Geometry(ogr.wkbLinearRing)
    for i in range(0,len(X)):
        myRing.AddPoint(X[i],Y[i])
    myRing.AddPoint(X[0],Y[0])#close ring
    poly = ogr.Geometry(type=ogr.wkbPolygon)
    poly.AddGeometry(myRing)
    feature = ogr.Feature( layer.GetLayerDefn() )
    feature.SetGeometry(poly)
    feature.SetFID(1)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return mask_arr


def get_car_dist(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        _ ,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
    return mat


def get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        distance,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
        mat[i,3]=distance
    return mat


def ligh_line(mat,Dmin):
    mat[0,3]=1
    for i in range(1,mat.shape[0]):
        if (mat[i,2]-mat[i-1,2])>Dmin:
            mat[i,3]=1
    return mat[mat[:,3]>0]


def create_buffer(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+1))
        mat[:,:-1] = inds
        mat = get_car_dist(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],Dir_list


def create_buffer2(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*-1
    D_lat = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+2))
        mat[:,:-2] = inds
        mat= get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))               
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        D_lat[az,0:nb_pix]=mat[ind,3]*Csize
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],D_lat[:,0:Nbpix_ext],Dir_list


def get_ligne(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret):
    npix = Nbpix_line[az]
    npix = fc.get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,10),dtype=np.float)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1
        test,indmax,Lline=fc.check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret)    
        return test,Lline,Line[0:indmax,0:7]
    else:
        return 0,0,0

def create_az_rules(angle_transv):
    matrice = np.zeros((360,360),dtype=np.int8)
    b1 = 90-angle_transv
    b2 = 90+angle_transv
    b3 = 270-angle_transv
    b4 = 270+angle_transv
    matrice[0,0:b1]=1
    matrice[0,b2:b3]=1
    matrice[0,b4:360]=1
    for expo in range(1,360,1):
        matrice[expo,0]=matrice[expo-1,359]
        for azi in range(1,360,1):
            matrice[expo,azi]=matrice[expo-1,azi-1]
    return matrice 


def Line_to_shapefile(Tab,Cable_line_Path,source_src,prelevement,language):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    fieldvol = 'Volume_'+str(int(100*prelevement))
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xstart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ystart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Yend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Id_route', ogr.OFTInteger)
    layer.CreateField(new_field)
    if language=='FR':
        new_field = ogr.FieldDefn('Desserte', ogr.OFTString) 
        
    else:
        new_field = ogr.FieldDefn('Road', ogr.OFTString)                              
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AzimuthDeg', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Long', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Config', ogr.OFTString)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('NbIntSup', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Surface', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn(fieldvol, ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('IPC', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Dmoy', ogr.OFTInteger)
    layer.CreateField(new_field)
    cneg = "Debardage vers l'aval"
    cpos = "Debardage vers l'amont"
    proj = "En projet"
    exis = "Existant"

    
    for ind,S in enumerate(Tab):
        line = ogr.Geometry(ogr.wkbLineString)
        line.AddPoint(float(S[2]),float(S[3]))
        line.AddPoint(float(S[6]),float(S[7]))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('IdLine',ind+1)
        feature.SetField('Xstart',float(S[2]))
        feature.SetField('Ystart',float(S[3]))
        feature.SetField('Xend',float(S[6]))
        feature.SetField('Yend',float(S[7]))
        if int(S[10])==2: 
            feature.SetField('Desserte',exis)
        else:
            feature.SetField('Desserte',proj)
        feature.SetField('Id_route',int(S[0]))
        feature.SetField('AzimuthDeg',int(S[1]))
        feature.SetField('Long',int(S[11]))
        if int(S[12])>0:
            feature.SetField('Config',cpos)
        else:
            feature.SetField('Config',cneg)
        feature.SetField('NbIntSup',int(S[17]))
        feature.SetField('Surface',S[13]/10000.)
        feature.SetField('Dmoy',int(S[14]))
        feature.SetField(fieldvol,int(S[15]*prelevement))
        feature.SetField('IPC',S[15]*prelevement/float(S[11]))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
    target_ds.Destroy()


def Pylone_in_shapefile(Tab,Cable_line_Path,source_src):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]    
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xpyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ypyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Altitude', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Hcable', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pression', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pyl_pos', ogr.OFTInteger)
    layer.CreateField(new_field)
    idi = 0
    for ind,S in enumerate(Tab):
        nb=1
        for pyl in range(int(S[17])):  
            point = ogr.Geometry(ogr.wkbPoint)
            point.SetPoint(0, float(S[18+5*pyl]),float(S[19+5*pyl]))         
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(point)
            feature.SetFID(idi)
            feature.SetField('IdLine',ind+1)
            feature.SetField('Xpyl',float(S[18+5*pyl]))
            feature.SetField('Ypyl',float(S[19+5*pyl]))
            feature.SetField('Altitude',float(S[20+5*pyl]))
            feature.SetField('Hcable',float(S[21+5*pyl]))
            feature.SetField('Pression',float(S[22+5*pyl]))
            feature.SetField('Pyl_pos',int(nb)             )    
            layer.CreateFeature(feature)
            point.Destroy()
            feature.Destroy()
            idi+=1
            nb+=1
    target_ds.Destroy()


def create_coord_pixel_center_raster(values,nline,ncol,Csize,Dir_temp):
    Xcoord = np.zeros((ncol),dtype=np.float)
    Ycoord = np.zeros((nline),dtype=np.float)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    np.save(Dir_temp+'TableX.npy',Xcoord)
    np.save(Dir_temp+'TableY.npy',Ycoord)
    return Xcoord,Ycoord


def create_coord_pixel_center_raster2(values,nline,ncol,Csize):
    Xcoord = np.zeros((ncol),dtype=np.float)
    Ycoord = np.zeros((nline),dtype=np.float)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    return Xcoord,Ycoord
    

def prepa_desserte_cable(Desserte_shapefile_name,MNT_file_name,Dir_temp,Pond_pente):
    ### Get info on the area
    _,values,_,Extent = raster_get_info(MNT_file_name)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    ### Get id of pixel of road and distance to public network
    Desserte_temp = shapefile_to_np_array(Desserte_shapefile_name,Extent,Csize,"CL_SVAC","CL_SVAC",'ASC')
    # Public network
    Res_pub = (Desserte_temp==3)*1
    # Forest road
    Route = (Desserte_temp==2)*1
    ID_RF = -9999*np.ones((nrows,ncols),dtype=np.int)
    ID_res_pub = -9999*np.ones((nrows,ncols),dtype=np.int)
    indice_forest_road = 0
    indice_public_road = 0
    pixels = np.argwhere(Desserte_temp>1)
    for pixel in pixels:
        if Res_pub[pixel[0],pixel[1]]==1:
            ID_res_pub[pixel[0],pixel[1]] = indice_public_road
            indice_public_road +=1
        elif Route[pixel[0],pixel[1]]==1:
            ID_RF[pixel[0],pixel[1]] = indice_forest_road
            indice_forest_road +=1
    np.save(Dir_temp+"ID_RF.npy",ID_RF)  
    np.save(Dir_temp+"ID_res_pub.npy",ID_res_pub)
    Dtransp_route, Lien_RF_respub = fc.calcul_distance_de_cout(ID_res_pub,Pond_pente,Route,Csize) 
    ### Get only forest roads
    Dir_temp2 = Dir_temp+"Temp/"
    try:os.mkdir(Dir_temp2)
    except:pass 
    Route_shp = Dir_temp2 + "Route.shp"
    select_in_shapefile(Desserte_shapefile_name,Route_shp,'WHERE CL_SVAC=2')
    ### Calculate azimuth and identify lines extremities
    Points_shp = Dir_temp2 + "Route_points.shp"    
    geoLocations,projection = linestring_to_point(Route_shp,Points_shp)
    # lines extremities
    Fin_ligne = np.int8(shapefile_to_np_array(Points_shp,Extent,Csize,'FIN_LIGNE','FIN_LIGNE','DESC'))
    # Azimuth 
    Az_route_shp = Dir_temp2 + "Az_Route.shp"
    points_to_lineshape(geoLocations,Az_route_shp,projection)
    Az_route = shapefile_to_np_array(Az_route_shp,Extent,Csize,'DIRECTION','DIRECTION','DESC')
    ID_routefor = np.unique(ID_RF)[1:]
    Link_RF_Res_pub = np.zeros((ID_routefor.shape[0],7),dtype=np.int)    
    for ind in ID_routefor:
        Temp = np.argwhere(ID_RF==ind)
        Link_RF_Res_pub[ind,0]=ind
        Link_RF_Res_pub[ind,1]=Temp[0,0]
        Link_RF_Res_pub[ind,2]=Temp[0,1]
        Link_RF_Res_pub[ind,3]=Dtransp_route[Temp[0,0],Temp[0,1]]
        Link_RF_Res_pub[ind,4]=Lien_RF_respub[Temp[0,0],Temp[0,1]]  
        Link_RF_Res_pub[ind,5]=Fin_ligne[Temp[0,0],Temp[0,1]]  
        Link_RF_Res_pub[ind,6]=Az_route[Temp[0,0],Temp[0,1]]
    shutil.rmtree(Dir_temp2)
    np.save(Dir_temp+"Link_RF_Res_pub",Link_RF_Res_pub)
    return Link_RF_Res_pub


def read_raster(file_name):
    source_ds = gdal.Open(file_name)
    source_ds.FlushCache() # Flush 
    Array = source_ds.GetRasterBand(1).ReadAsArray()
    Array[Array==0]=-9999
    return Array


# Create raster of obstacles from directory containing shapefiles 
def prepa_obstacle_cable(Obstacles_directory,file_MNT,Dir_temp):
    ### Creation d'un repertoire temporaire       
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize= values[4]
    MNT = read_raster(file_MNT)
    MNT[MNT==values[5]]=-9999
    Pente = fc.pente(np.float_(MNT),Csize,-9999)     
    if Obstacles_directory!="":
        liste_file = os.listdir(Obstacles_directory)
        liste_obs = [] 
        for files in liste_file:
            if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
        if len(liste_obs)>0:
            Obstacles_cable = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)
    else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)    
    Obstacles_cable[MNT==-9999]=1
    values[5]=-9999
    np.save(Dir_temp+'Obstacles_cables.npy',np.int8(Obstacles_cable))
    gc.collect()  
    return Pente


def prepa_pond_pente_cable(MNT,Csize,Direct,head_text):
    Pente = fc.pente(MNT,Csize,-9999)
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    save_float_ascii(Direct+'/pond_pente.asc',head_text,Pond_pente)
    return Pond_pente
    
# Create a pair matrix
def create_pair_matrice(matrice):
    indices = np.indices(matrice.shape)
    pair_l = np.fmod(indices[0],2)
    pair_c = np.fmod(indices[1],2)
    pair = pair_c + pair_l
    pair = np.equal(pair,1)
    return pair

# Make buffer around a pixel
def buffer_emprise(Csize,ct_Lhor_max):
    temp = int(ct_Lhor_max/Csize)
    Ligne_perpendic = np.zeros((360*(1+2*temp),(1+2*temp)),dtype=np.uint8)
    Ind_mask = np.indices(((1+2*temp),(1+2*temp)),dtype=np.int16)
    center_inv = np.ones(((1+2*temp),(1+2*temp)),dtype=np.int16)
    center_inv[temp,temp]=0
    center = np.equal(center_inv,0)*1
    DX = Ind_mask[1]- temp
    DY = temp - Ind_mask[0]
    Dhor_ok = np.less_equal(Csize*np.sqrt(DX**2+DY**2),ct_Lhor_max)
    dmax1,dmin1,dmax2,dmin2 = direction_to_center(DX,DY,Csize,center_inv,center)
    z3_2 = np.less_equal((dmax2-dmin2),120)*1
    z3_1 = np.less_equal((dmax1-dmin1),120)*1
    Direction_list = range(0,360,1)
    for item in Direction_list:
        Dir_value = item+90
        if Dir_value > 359:Dir_value = item-90
        Mask1 = get_dir_area(Dir_value,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1)
        Dir_value1 = Dir_value+180
        if Dir_value1 > 359:Dir_value1 = Dir_value-180
        Mask2 = get_dir_area(Dir_value1,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1)
        Mask = np.greater((Mask1+Mask2),0)*Dhor_ok*1
        h = item*(1+2*temp)
        b = h+(1+2*temp)
        r = (1+2*temp)
        Ligne_perpendic[h:b,0:r]=Mask
    return Ligne_perpendic


def direction_to_center(DX,DY,Csize,center_inv,center):
    corner=[[0.5,0.5],[0.5,-0.5],[-0.5,0.5],[-0.5,0.5]]
    dmax1 = -400*np.ones_like(DX, dtype = np.int16)
    dmax2 = -400*np.ones_like(DX, dtype = np.int16)
    dmin1 = 400*np.ones_like(DX, dtype = np.int16)
    dmin2 = 400*np.ones_like(DX, dtype = np.int16)
    ind_center = np.nonzero(center==1)
    for item in corner:
        X = DX*Csize+item[1]*Csize
        Y = DY*Csize+item[0]*Csize
        D = np.sqrt(X**2+Y**2)
        Temp = np.equal(X,np.abs(X))*1
        Fact = Temp - np.less(Temp, 1)*1        
        D[ind_center] = Csize
        Angle = np.degrees(np.arccos(Y/D))
        Angle[ind_center]=0
        Temp = Angle*Fact
        del (X,Y,D,Fact,Angle)
        direction = 360*np.less(Temp, 0)+np.less(Temp, 0)*Temp+np.greater_equal(Temp, 0)*Temp
        dmax1=np.maximum(direction,dmax1)
        dmin1=np.minimum(direction,dmin1)
        dmax2=np.maximum(Temp,dmax2)
        dmin2=np.minimum(Temp,dmin2)
        del (Temp,direction)
    dmax1=np.float_(dmax1*center_inv+np.equal(center_inv,0)*9999)
    dmax2=np.float_(dmax2*center_inv+np.equal(center_inv,0)*9999)
    dmin1=np.float_(dmin1*center_inv+np.equal(center_inv,0)*9999)
    dmin2=np.float_(dmin2*center_inv+np.equal(center_inv,0)*9999)
    return dmax1,dmin1,dmax2,dmin2


#Get area corresponding to an azimuth
def get_dir_area(dir_value,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1):
    if dir_value < 90:
        z1 = np.greater_equal(dir_value,dmin2)
        z2 = np.less_equal(dir_value,dmax2)
        zone = np.equal((z1*1+z2*1+z3_2*1),3)*1+center
    elif dir_value > 270:
        new_value = dir_value-360
        z1 = np.greater_equal(new_value,dmin2)
        z2 = np.less_equal(new_value,dmax2)
        zone = np.equal((z1*1+z2*1+z3_2*1),3)*1+center
    else:
        z1 = np.greater_equal(dir_value,dmin1)
        z2 = np.less_equal(dir_value,dmax1)
        zone = np.equal((z1*1+z2*1+z3_1*1),3)*1+center
    return zone


# Create useful buffers
def mask_buffers(test_coordY,test_coordX,ind_buffer_center,Buffer_cote,ncol,nline):
    if test_coordX < ind_buffer_center[1][0]: mask_l,buf_l = 0,ind_buffer_center[1][0] - test_coordX
    else: mask_l,buf_l = test_coordX - Buffer_cote,0
    if test_coordX + Buffer_cote + 1 > ncol: mask_r,buf_r = ncol,ncol-test_coordX+ind_buffer_center[1][0]
    else: mask_r,buf_r = test_coordX + Buffer_cote + 1,ind_buffer_center[1][0] + Buffer_cote + 1
    if test_coordY < ind_buffer_center[0][0]: mask_h,buf_h = 0,ind_buffer_center[0][0] - test_coordY
    else: mask_h,buf_h = test_coordY - Buffer_cote,0
    if test_coordY + Buffer_cote + 1 > nline: mask_b,buf_b = nline,nline - test_coordY + ind_buffer_center[0][0]
    else: mask_b,buf_b = test_coordY+Buffer_cote+1,ind_buffer_center[0][0]+Buffer_cote+1
    return mask_h,mask_b,mask_l,mask_r,buf_h,buf_b,buf_l,buf_r


def directions_a_tester(Dir_route,Dir_list,angle_sup,id_fin_ligne):
    # Pixel tout seul
    Dir_list_bis = list(Dir_list)
    # Pixel de route en fin de troncon
    if id_fin_ligne==1:
        D_plus_a = (Dir_route+angle_sup)%360
        D_moins_a = (Dir_route-angle_sup)%360
        if D_moins_a > D_plus_a:valeur_a_suppr = range(D_moins_a,360,1)+range(0,D_plus_a+1,1)
        else:valeur_a_suppr = range(D_moins_a,D_plus_a+1,1)
        for item in valeur_a_suppr:
            try:Dir_list_bis.remove(item)
            except:continue
    # Pixel de route au milieu d'un troncon
    else:
        D_plus_a = (Dir_route+angle_sup)%360
        D_moins_a = (Dir_route-angle_sup)%360
        if D_moins_a > D_plus_a:valeur_a_suppr = range(D_moins_a,360,1)+range(0,D_plus_a+1,1)
        else:valeur_a_suppr = range(D_moins_a,D_plus_a+1,1)
        D_plus_180_moins_a = (Dir_route+180-angle_sup)%360
        D_plus_180_plus_a = (Dir_route+180+angle_sup)%360
        if D_plus_180_plus_a < D_plus_180_moins_a: valeur_a_suppr = valeur_a_suppr + range(D_plus_180_moins_a,360,1)+range(0,D_plus_180_plus_a+1,1)
        else:valeur_a_suppr = valeur_a_suppr + range(D_plus_180_moins_a,D_plus_180_plus_a+1,1)
        for item in valeur_a_suppr:
            try:Dir_list_bis.remove(item)
            except:continue    
    return Dir_list_bis


def get_cable_configs(slope_Wliner_up,slope_Wliner_down,slope_grav,Skid_direction):
    #Get folder
    _,Rspace,_,_,_,_,_,_,_,_,_,_,_ = Sylvaccess_pluginDialog.get_spatial(0,1,0,0,0,0,0,0,0,0,0,0,0)
    dirs = [d for d in os.listdir(Rspace) if os.path.isdir(os.path.join(Rspace, d))]
    list_dir = []
    
    for dire in dirs:
        if dire[:5]=='Cable':
            list_dir.append(dire)

    optnum = len(list_dir)+1
    Rspace_c=Rspace+'Cable_'+str(optnum)        
    filename = Rspace_c+"/"
    Cable_type,_,_,_,_ = Sylvaccess_pluginDialog.get_type_cable(1,0,0,0,0)
    filename += str(Cable_type)
    Carriage_type,_,_,_,_ = Sylvaccess_pluginDialog.get_type_chariot(1,0,0,0,0)
    filename += "_"+str(Carriage_type)
    
    if Skid_direction ==0:
        filename += "_amont&aval"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1        
    
    elif Skid_direction ==1:
        filename += "_amont"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = 0
        slope_min_down = 0
    
    else:
        filename += "_aval"
        slope_min_up = 0
        slope_max_up = 0
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1 
    
    if Cable_type == "Câble long":
        if Skid_direction ==0:
            filename += "_amont&aval"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01) 
   
        elif Skid_direction ==1:
            filename += "_amont"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0
 
        else:
            filename += "_aval"
            slope_min_up = 0
            slope_max_up = 0
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01)             
    else: 
        
        if Skid_direction ==0:
            filename+= "_amont_aval"
            slope_min_up = -1.4
            slope_max_up = 0.1
            slope_min_down = -0.1
            slope_max_down = 1.4
        
        elif Skid_direction ==1:
            filename += "_amont"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0 
        
        else:
            filename += "_aval"
            slope_min_up = 0
            slope_max_up = 0
            slope_min_down = -0.1
            slope_max_down = 1.4             
    
    filename+=".txt"
    
    return Rspace_c,filename,slope_min_up,slope_max_up,slope_min_down,slope_max_down


def gen_sel_table(w_list,lim_list,sup_max):
    col =     np.array([13       ,17     ,12         ,11    ,15    ,18+5*sup_max,16          ,14          ,18+5*sup_max+1])
    sens =    np.array([1        ,-1     ,0          ,1     ,1     ,1           ,1           ,-1          ,-1])
    #sens : 1:maximize,-1 minimize,0 NA
    report =  np.array([10000.   ,1.     ,1.         ,1.    ,1.    ,100.        ,10.         ,1.          ,1.])
    name = np.array(['Surface','NBsup','SensDeb'  ,'Long','Vtot','IPC'       ,'VAM'       ,'Dchar'     ,'Cout'])
    #quant =   np.array[[99,      , 100   , 100       ,99    ,99    ,99          ,99          ,100          ,100]]
    Tab_crit=np.zeros((9,4))
    Tab_crit[:,0]=w_list
    Tab_crit[:,1]=lim_list*report    
    Tab_crit[:,2]=col
    Tab_crit[:,3]=sens
    Name = ""  
    for i,crit in enumerate(Tab_crit):
        if crit[0]>0:
            Name+= '_'+str(name[i])+'('+str(round(crit[0],1))+')'
        
    return Tab_crit[Tab_crit[:,0]>0],Name


def create_best_table(Tab2,w_list,lim_list,sup_max): 
    Tab_crit,name=gen_sel_table(w_list,lim_list,sup_max)
    #Trie en fonction des critere avec un poids et de la limite
    for crit in Tab_crit:
        if crit[3]>0:
            tp = (Tab2[:,int(crit[2])]-crit[1])>=0
        elif crit[3]<0:
            tp = (Tab2[:,int(crit[2])]-crit[1])<=0
        else:
            continue
        Tab2 = Tab2[tp]
        
    #identifier si le sens de debardage a ete choisi dans les criteres   
    liste =range(Tab_crit.shape[0])
    idsensdeb=np.argwhere(Tab_crit[:,2]==12)
    if idsensdeb.shape[0]>0:
        idsensdeb=idsensdeb[0,0]
        liste = [x for x in liste if x != idsensdeb]
    else:
        idsensdeb=-1
    #Transform variable to stick in the range [0-1+]
    nbcol = len(liste)+2    
    Tab = np.zeros((Tab2.shape[0],nbcol))    
    col=1   
    for crit in Tab_crit[liste]:
        if crit[3] < 1 : #all values contribute to transformation
            Tab[:,col]= (1-1.0*Tab2[:,int(crit[2])]/np.max(Tab2[:,int(crit[2])]))*crit[0]
        else:
            Tab[:,col]= (1.0*Tab2[:,int(crit[2])]/np.percentile(Tab2[:,int(crit[2])],98))*crit[0]
        col+=1
    
    for i in range(Tab2.shape[0]):
        Tab[i,0]=i                      #first col is idline of Tab2
        Tab[i,col]=np.sum(Tab[i,1:col]) #last col is the total weight
    #classify
    ordre = np.zeros((Tab2.shape[0],),dtype=np.int)   
    if idsensdeb>0:
        #first the best direction
        tp = Tab2[:,12]==Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[tp][ind][0])
        ligne=i+1
        #then the othe direction
        tp = Tab2[:,12]==-Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i+ligne]=int(Tab[tp][ind][0])
    else:
        inds = np.lexsort((Tab[:,0],-Tab[:,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[ind,0])
    return Tab2[ordre],name


def select_best_lines(w_list,lim_list,Tab2,nrows,ncols,Csize,Row_ext,Col_ext,D_ext,D_lat,Lhor_max,sup_max):        
    # Reorder Tab to fit with criteria
    Tabbis,name=create_best_table(Tab2,w_list,lim_list,sup_max)
    nb_line,nb_cols = Tabbis.shape
    Rast_couv=np.zeros((nrows,ncols),dtype=np.int8)
    vals = range(0,nb_line)
    ### Parameter to validate a line
    recouv = min(0.6*Lhor_max,Lhor_max-Csize) #distance from the axis of the line where crossing is not allowed
    # Select best lines
    vals2 = []
    for id_tab in vals:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        test_free,Rast_couv=fc.Check_line2(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,D_lat,Rast_couv,recouv,0)
        if test_free:
            vals2.append(id_tab)
    # Check taht line contribute to total impacted surface
    Tab_result = np.zeros((len(vals2),2),dtype=np.int)
    id_line = 0    
    for id_tab in vals2:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        prop = fc.get_prop(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,D_lat,Rast_couv)  
        Tab_result[id_line]=id_tab,prop*1000
        id_line+=1
    Tab_result=Tab_result[np.lexsort((Tab_result[:,0],Tab_result[:,1]))]  
    # Remove lines that does not contribute significantly to impacted surface
    nb_line = Tab_result.shape[0]
    Tab_result2 = np.zeros((nb_line,nb_cols-2),dtype=np.int)
    id_line = 0    
    for id_tab in Tab_result[:,0]:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2) 
        test_free,Rast_couv=fc.Check_line3(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,D_lat,Rast_couv,0.6)         
        if test_free:
            Tab_result2[id_line]=Tabbis[id_tab,0:-2]
            id_line+=1    
    Tab_result2=Tab_result2[Tab_result2[:,11]>0]
    return Rast_couv,Tab_result2,name


def return_crit_text(w_list,lim_list,):    
    name =["Surface de forêt impactée [ha] (maximiser)                  Minimum : ", 
              "Nombre de support intermédiaires (minimiser)                Maximum : ",
              "Privilégier le débardage vers ",
              "Longueur de ligne [m] (maximiser)                           Minimum : ", 
              "Volume total par ligne [m3] (maximiser)                     Minimum : ",
              "Indice de prélèvement câble [m3/ml] (maximiser)             Minimum : ",
              "Volume de l\'arbre moyen [m3] (maximiser)                   Minimum : ",
              "Longueur moyenne parcourue par le charriot [m] (minimiser)  Maximum : ",
              "Coût du débardage [€/m3] (minimiser)                        Maximum : "]                    
    units = ["ha","","","m","m3","m3/ml","m3","m","€/m3"]
    namelist=name
    pname = "(Poids: "              
    Tab = np.empty((np.sum(np.array(w_list)>0),2),dtype='|U73')
    j=-1
    for i,w in enumerate(w_list):
        if w!=0:
            j+=1
            if i!=2:
                if round(lim_list[i],0)==lim_list[i]:
                    lim=int(lim_list[i])
                else:
                    lim=round(lim_list[i],1)
                Tab[j]=namelist[i],str(lim)+" "+units[i]+" "+pname+str(w)+')' 
            else:
                if lim_list[i]==-1:
                    Tab[j]= name[i]+"l\'aval",pname+str(w)+')' 
                elif lim_list[i]==1:
                    Tab[j]= name[i]+"l\'amont",pname+str(w)+')'  
                else:
                    continue                    
    return Tab


def generate_info_ligne(Dir_result,w_list,lim_list,Tab,Rast_couv,Vol_ha,Vol_AM,Csize,prelevement,Lhor_max):
    filename = Dir_result+"Bilan_selection.txt"
    pix_area = Csize*Csize/10000.
    Proj = np.copy(Rast_couv)
    Proj[Rast_couv==2]=0
    Rast_couv[Rast_couv==2]=1
    Surface = round(np.sum(Rast_couv)*pix_area,1)
    Surface_proj = round(np.sum(Proj)*pix_area,1)
    if Surface_proj>0:
        testProj=1
    else:
        testProj=0
    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:,12]>0))
    try:
        nb_moy_pyl = round(np.sum(Tab[:,17])/nb_ligne,1)
        long_moy_ligne = int(np.sum(Tab[:,11])/nb_ligne)
    except:
        print("Aucune ligne n'a ete selectionnee")
    Vol_ha[np.isnan(Vol_ha)]=0
    Vol_AM[np.isnan(Vol_AM)]=0
    tp =   Vol_ha>0
    if np.sum(tp)>0:      
        vtot = np.sum(Rast_couv[tp]*Vol_ha[tp])*pix_area*prelevement
    else:
        vtot=0
    tp =   Vol_AM>0 
    if np.sum(tp)>0:
        vam = round(np.mean(Rast_couv[tp]*Vol_AM[tp]),1)
    else:
        vam=0
    if np.sum(Tab[:,11])!=0:
        ipc_moy = round(float(vtot)/np.sum(Tab[:,11]),2)
    else:
        print("Aucune ligne n'a ete selectionnee")
    vtot = int(vtot)
    lim_list[4]=lim_list[4]*prelevement
    
    Table = np.empty((19+np.sum(np.array(w_list)>0),2+testProj),dtype='|U73')
    
    Table[1,0]= "BILAN DE LA SELECTION DE LIGNE"
    Table[3,1]= "\t\t\t\t\t\t\tDepuis tous les départs\t\t"
    if testProj:
        Table[3,2]="Seulement depuis les projets"
    Table[4,0]= "Surface totale de forêt traitée [ha]:\t\t\t"
    Table[5,0]= "Nombre total de ligne:\t\t\t\t\t"
    Table[6,0]= "     + Dont ligne avec débardage vers l'amont:\t\t"
    Table[7,0]= "     + Dont ligne avec débardage vers l'aval:\t\t"
    Table[8,0]= "Nombre moyen de pylône intermédiaire par ligne:\t\t"
    Table[9,0]= "Longueur moyenne des lignes [m]:\t\t\t"
    Table[10,0]="Volume total prélevé (estimation) [m3]:\t\t\t"
    Table[11,0]="Indice de prélevement câble moyen (estimation) [m3/m]:\t"        
    Table[12,0]="Volume de l'arbre moyen (estimation) [m3]:\t\t"
    Table[15,0]="Critère(s) pris en compte dans la sélection des lignes:"
    Table[17,0]="Distance laterale de pechage des bois:                      "
    Table[18,0]="Taux de prelevement du volume sur pied:                     "
        
    Table[4,1]= str(Surface)
    Table[5,1]= str(nb_ligne)
    Table[6,1]= str(nb_ligne_amont)
    Table[7,1]= str(nb_ligne-nb_ligne_amont)
    Table[8,1]= str(nb_moy_pyl)
    Table[9,1]= str(long_moy_ligne)
    Table[10,1]=str(vtot)
    Table[11,1]=str(ipc_moy)
    Table[12,1]=str(vam)
    Table[17,1]=str(int(Lhor_max))+" m"
    Table[18,1]=str(int(prelevement*100))+" %"
    
    Tabcrit = return_crit_text(w_list,lim_list)
    
    for i,crit in enumerate(Tabcrit):
        Table[19+i,0]=crit[0]
        Table[19+i,1]=crit[1]
        
    
    if testProj:
        Tab= Tab[Tab[:,10]==1]
        Rast_couv = Proj
        nb_ligne = Tab.shape[0]
        nb_ligne_amont = int(np.sum(Tab[:,12]>0))
        try:
            nb_moy_pyl = round(np.sum(Tab[:,17])/nb_ligne,1)
            long_moy_ligne = int(np.sum(Tab[:,11])/nb_ligne)
        except:
            print("Aucune ligne n'a ete selectionnee")
        tp =   Vol_ha>0
        if np.sum(tp)>0:      
            vtot = np.sum(Rast_couv[tp]*Vol_ha[tp])*pix_area*prelevement
        else:
            vtot=0
        tp =   Vol_AM>0 
        if np.sum(tp)>0:
            vam = round(np.mean(Rast_couv[tp]*Vol_AM[tp]),1)
        else:
            vam=0
        if np.sum(Tab[:,11])!=0:
            ipc_moy = round(float(vtot)/np.sum(Tab[:,11]),2)
        else:
            print("Aucune ligne n'a ete selectionnee")
        vtot = int(vtot)
        
        Table[4,2]= "\t\t\t\t"+str(Surface_proj)
        Table[5,2]= "\t\t\t\t"+str(nb_ligne)
        Table[6,2]= "\t\t\t\t"+str(nb_ligne_amont)
        Table[7,2]= "\t\t\t\t"+str(nb_ligne-nb_ligne_amont)
        Table[8,2]= "\t\t\t\t"+str(nb_moy_pyl)
        Table[9,2]= "\t\t\t\t"+str(long_moy_ligne)
        Table[10,2]="\t\t\t\t"+str(vtot)
        Table[11,2]="\t\t\t\t"+str(ipc_moy)
        Table[12,2]="\t\t\t\t"+str(vam)
           
    np.savetxt(filename, Table,fmt='%s', delimiter='')


def generate_info_cable_simu(Dir_result,Tab,Rast_couv,Vol_ha,Csize,Forest,Pente,Pente_max_bucheron):
    filename = Dir_result+"Resume_resultat_sylvaccess_cable.txt"
    Pente_max = fc.focal_stat_max(np.float_(Pente),-9999,1)
    Pente_ok_buch = np.int8((Pente_max<=Pente_max_bucheron))
    del Pente_max
    gc.collect()    
    pix_area = Csize*Csize/10000.
    Rast_couv[Forest==0]=0
    Surface_exis = round(np.sum(Rast_couv==2)*pix_area,1)
    Surface_proj = round(np.sum(Rast_couv==1)*pix_area,1)
    Surface_foret = round(np.sum(Forest==1)*pix_area,1)    
    Surface_nonbuch = round(np.sum((Forest==1)*(Pente_ok_buch==0))*pix_area,1)
        
    Vol_ha[np.isnan(Vol_ha)]=0
    Vol_ha[Forest==0]=0
    tp =  Vol_ha>0
    if np.sum(tp)>0:   
        tp2 = (tp*(Rast_couv==2))>0
        vtot_exis = int(np.sum(Vol_ha[tp2])*pix_area+0.5)
        tp2 = (tp*(Rast_couv==1))>0
        vtot_proj = int(np.sum(Vol_ha[tp2])*pix_area+0.5)     
        tp2 = (tp*(Forest==1))>0
        vtot_forest = int(np.sum(Vol_ha[tp2])*pix_area+0.5)   
        tp2 = (tp*(Forest==1)*(Pente>Pente_max_bucheron))>0
        vtot_nonbuch = int(np.sum(Vol_ha[tp2])*pix_area+0.5)   
    else:
        vtot_exis = 0  
        vtot_proj = 0
        vtot_forest = 0
        vtot_nonbuch = 0
        
    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:,12]>0))
    nb_moy_pyl = round(np.sum(Tab[:,17])/nb_ligne,1)
    long_moy_ligne = int(np.sum(Tab[:,11])/nb_ligne)    
                
    Table = np.empty((17,5),dtype='|U39')
    Table[0] = np.array(["","Surface (ha)","Surface (%)","Volume sur pied (m3)","Volume (%)"])
    Table[1,0] = "Depuis les departs de cable existant"
    Table[2,0] = "Depuis les departs de cable en projet"
    Table[4,0] = "Total foret accessible"
    Table[5,0] = "Total foret inaccessible"
    Table[6,0] = "    dont non bucheronnable"
    Table[8,0] = "Superficie totale de la foret"
    Table[11,0] = "Nombre total de ligne"
    Table[12,0] = "    + Dont debardage vers l'amont"
    Table[13,0] = "    + Dont debardage vers l'aval"
    Table[15,0] = "Longueur moyenne des lignes (m)"
    Table[16,0] = "Nombre moyen de pylone intermediaire"
        
    #Create recap per distance class 
    if vtot_forest>0:
        Table[1,1:] = np.array([str(Surface_exis),str(int(Surface_exis/Surface_foret*100+0.5)),
                                str(vtot_exis),str(int(vtot_exis/vtot_forest*100+0.5))])
        Table[2,1:] = np.array([str(Surface_proj),str(int(Surface_proj/Surface_foret*100+0.5)),
                                str(vtot_proj),str(int(vtot_proj/vtot_forest*100+0.5))])
        
        Table[4,1:] = np.array([str(Surface_exis+Surface_proj),str(int((Surface_proj+Surface_exis)/Surface_foret*100+0.5)),
                                str(vtot_proj+vtot_exis),str(int((vtot_exis+vtot_proj)/vtot_forest*100+0.5))])
        Table[5,1:] = np.array([str(round(Surface_foret-(Surface_exis+Surface_proj),1)),str(int((Surface_foret-(Surface_proj+Surface_exis))/Surface_foret*100+0.5)),
                                str(vtot_forest-(vtot_proj+vtot_exis)),str(int((vtot_forest-(vtot_exis+vtot_proj))/vtot_forest*100+0.5))])
        Table[6,1:] = np.array([str(Surface_nonbuch),str(int(Surface_nonbuch/Surface_foret*100+0.5)),
                                str(vtot_nonbuch),str(int(vtot_nonbuch/vtot_forest*100+0.5))])
    else:
        Table[1,1:] = np.array([str(Surface_exis),str(int(Surface_exis/Surface_foret*100+0.5)),'0','0'])
        Table[2,1:] = np.array([str(Surface_proj),str(int(Surface_proj/Surface_foret*100+0.5)),'0','0'])
                            
        
        Table[4,1:] = np.array([str(Surface_exis+Surface_proj),str(int((Surface_proj+Surface_exis)/Surface_foret*100+0.5)),'0','0'])
        Table[5,1:] = np.array([str(round(Surface_foret-(Surface_exis+Surface_proj),1)),str(int((Surface_foret-(Surface_proj+Surface_exis))/Surface_foret*100+0.5)),'0','0'])
        Table[6,1:] = np.array([str(Surface_nonbuch),str(int(Surface_nonbuch/Surface_foret*100+0.5)),'0','0'])
    
    Table[8,1:] = np.array([str(Surface_foret),"",str(vtot_forest),""])
    
    Table[11,1] = str(nb_ligne)
    Table[12,1] = str(nb_ligne_amont)
    Table[13,1] = str(nb_ligne-nb_ligne_amont)
    Table[15,1] = str(long_moy_ligne)
    Table[16,1] = str(nb_moy_pyl)
    
    np.savetxt(filename, Table,fmt='%s', delimiter=';')


def calculate_azimut(x1,y1,x2,y2):
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    return Angle%360   


def create_rast_couv(Tab_result,Dir_result,source_src,Extent,Csize,Lhor_max):
    drv = ogr.GetDriverByName("ESRI Shapefile")    
    layer_name = "Extent"
    dst_ds = drv.CreateDataSource( Dir_result+layer_name+".shp" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('EXIST', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    layerDefinition = dst_layer.GetLayerDefn()  
    for idi,line in enumerate(Tab_result):
        Xstart,Ystart,Xend,Yend = line[2],line[3],line[6],line[7]
        az = calculate_azimut(Xstart,Ystart,Xend,Yend)
        conv = radians(90)
        ring = ogr.Geometry(ogr.wkbLinearRing)
        ring.AddPoint(Xstart+Lhor_max*cos(az-conv), Ystart+Lhor_max*sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*cos(az-conv), Yend+Lhor_max*sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*cos(az+conv), Yend+Lhor_max*sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*cos(az+conv), Ystart+Lhor_max*sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*cos(az-conv), Ystart+Lhor_max*sin(az-conv))
        poly = ogr.Geometry(ogr.wkbPolygon)
        poly.AddGeometry(ring)
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(poly)
        feature.SetFID(idi)        
        feature.SetField('EXIST',int(line[10]))
        dst_layer.CreateFeature(feature)
        ring.Destroy()
        poly.Destroy()
        feature.Destroy()
    dst_ds.Destroy()
    Rast_couv = np.int8(shapefile_to_np_array(Dir_result+layer_name+".shp",Extent,Csize,"EXIST","EXIST",'ASC') )
    for extension in [".shp",".prj",".shx",".dbf"]:
        os.remove(Dir_result+layer_name+extension)
    return Rast_couv


def prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_Dep,Dir_Obs_cable):
    print("Pre-traitement des entrees pour le modele cable\n")
    ### Make directory for temporary files
    Dir_temp = Wspace+"Temp/"
    try:os.mkdir(Dir_temp)
    except:pass     
    ###########################################################################
    ### __         __ __   __         __ __               __   __              
    ###|__|.-----.|__|  |_|__|.---.-.|  |__|.-----.---.-.|  |_|__|.-----.-----.
    ###|  ||     ||  |   _|  ||  _  ||  |  ||__ --|  _  ||   _|  ||  _  |     |
    ###|__||__|__||__|____|__||___._||__|__||_____|___._||____|__||_____|__|__|
                                                                        
    MNT,Extent,Csize,proj = load_float_raster(file_MNT,Dir_temp)
    np.save(Dir_temp+"MNT",MNT)
    
    #############################################################################################################
    ###        __                       ___ __ __             __                                __              
    ###.-----.|  |--.---.-.-----.-----.'  _|__|  |.-----.    |  |_.-----.    .----.---.-.-----.|  |_.-----.----.
    ###|__ --||     |  _  |  _  |  -__|   _|  |  ||  -__|    |   _|  _  |    |   _|  _  |__ --||   _|  -__|   _|
    ###|_____||__|__|___._|   __|_____|__| |__|__||_____|    |____|_____|    |__| |___._|_____||____|_____|__|  
    ###                   |__|                                                                                  
    Foret = shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET")
    np.save(Dir_temp+"Foret",np.int8(Foret))    
    del Foret
    print("    - Raster de foret termine")    
    ### Forest : shapefile to raster 
    Exposition = fc.exposition(MNT,Csize,-9999)
    np.save(Dir_temp+"Aspect",np.uint16(Exposition+0.5))
    Pente = prepa_obstacle_cable(Dir_Obs_cable,file_MNT,Dir_temp)
    np.save(Dir_temp+"Pente",Pente)    
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    np.save(Dir_temp+"Pond_pente",Pond_pente)
    del Pente,MNT  
    print("    - Obstacles pour le cable traites")

    #################################################################################################################################
    ###             __     __                    __               __                                                 __              
    ###.----.---.-.|  |--.|  |.-----.    .-----.|  |_.---.-.----.|  |_     .-----.----.-----.----.-----.-----.-----.|__|.-----.-----.
    ###|  __|  _  ||  _  ||  ||  -__|    |__ --||   _|  _  |   _||   _|    |  _  |   _|  _  |  __|  -__|__ --|__ --||  ||     |  _  |
    ###|____|___._||_____||__||_____|    |_____||____|___._|__|  |____|    |   __|__| |_____|____|_____|_____|_____||__||__|__|___  |
    ###                                                                    |__|                                               |_____|
    Cable_start = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"CABLE","CABLE",'ASC') 
    testExist = check_field(file_shp_Cable_Dep,"EXIST") 
    if testExist:    
        Existing = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"EXIST","EXIST",'ASC') 
    else:
        Existing = np.ones_like(Cable_start,dtype=np.int8)*2

    pixels = np.argwhere(Cable_start>0)
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.int) 
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        Lien_RF[ID,4]=Cable_start[pixel[0],pixel[1]]
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=Existing[pixel[0],pixel[1]]
        ID +=1         
    # Link RF with res_pub and calculate transportation distance
#    Lien_RF=fc.Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for, Lien_RF,Csize) 
#    Lien_RF=Lien_RF[Lien_RF[:,4]>0]
    Lien_RF=Lien_RF[Lien_RF[:,2]>-1]
    np.save(Dir_temp+"Lien_RF_c",Lien_RF)    
    print("    - Departs de cables potentiels identifies")    

    ###################################################################################################################################################################################
    ###                                 __                                     __                      __                                      __                                      
    ###.----.----.-----.-----.----.    |  |.-----.-----.    .----.---.-.-----.|  |_.-----.----.    .--|  |.-----.    .----.-----.-----.----.--|  |.-----.-----.-----.-----.-----.-----.
    ###|  __|   _|  -__|  -__|   _|    |  ||  -__|__ --|    |   _|  _  |__ --||   _|  -__|   _|    |  _  ||  -__|    |  __|  _  |  _  |   _|  _  ||  _  |     |     |  -__|  -__|__ --|
    ###|____|__| |_____|_____|__|      |__||_____|_____|    |__| |___._|_____||____|_____|__|      |_____||_____|    |____|_____|_____|__| |_____||_____|__|__|__|__|_____|_____|_____|
                                                                                                                                                                                
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    TableX,TableY=create_coord_pixel_center_raster(values,nrows,ncols,Csize,Dir_temp)
    CoordRoute = np.zeros((Lien_RF.shape[0],2),dtype=np.float)
    for i,pixel in enumerate(Lien_RF):
        CoordRoute[i,0]=TableX[pixel[1]]
        CoordRoute[i,1]=TableY[pixel[0]] 
    np.save(Dir_temp+"CoordRoute.npy",CoordRoute)  
    print("    - Table des coordonnees creee")  
    ##############################################################################################################################################
    ###       __                         __   __                                __         __   
    ###.----.|  |.-----.-----.-----.    |  |_|  |--.-----.    .-----.----.----.|__|.-----.|  |_ 
    ###|  __||  ||  _  |__ --|  -__|    |   _|     |  -__|    |__ --|  __|   _||  ||  _  ||   _|
    ###|____||__||_____|_____|_____|    |____|__|__|_____|    |_____|____|__|  |__||   __||____|
    ###                                                                            |__|         
    print("\nPre-traitement des entrees pour le cable termine\n")
    clear_big_nparray()


def line_selection(Rspace_c,w_list,lim_list,new_calc,file_shp_Foret,file_Vol_ha,file_Vol_AM,Lhor_max,prelevement,Pente_max_bucheron):
    print("Selection des meilleures lignes en fonction des criteres de l'utilisateur.")
    ### Check if temporary files have been generated and have the same extent
    Rspace_sel = Rspace_c+"FilesForOptimisation/"
    try: 
        Tab = np.load(Rspace_sel+"Tab_all_lines.npy") 
    except:
        print("Veuillez d'abord faire tourner le modele cable.")
        return ""
    Lmax = np.max(Tab[:,11])    
    _,values,Extent=loadrasterinfo_from_file(Rspace_sel)
    Csize,nrows,ncols=values[4],int(values[1]),int(values[0]) 
    if not new_calc:
        f = open(Rspace_sel+"info_Lhormax.txt","r")
        Lhor_max=f.readlines(0)
        f.close()
        Lhor_max= float(Lhor_max[0])
    
    _,_,_,_,Row_ext,Col_ext,D_ext,D_lat,_=create_buffer2(Csize,Lmax,Lhor_max)        
    Lien_RF = np.load(Rspace_sel+"Lien_RF_c.npy")
    ############################################
    ### Recompute cable line stats if necessary
    ############################################
    if new_calc:
        print("    - Recalcule les caracteristiques des lignes avec les nouvelles couches...") 
        #Couche foret
        if file_shp_Foret != "":
            Forest = np.int8(shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET"))
        else:
            Forest=np.load(Rspace_sel+"Forest.npy")
        #Couche vol_ha
        if file_Vol_ha != "":
            Vol_ha = load_float_raster_simple(file_Vol_ha) 
            Vol_ha[Vol_ha<0]=0
            Vol_ha[np.isnan(Vol_ha)]=0
            test_vp = True
        else:
            test_vp = False            
            if file_Vol_AM != "":
                Vol_ha = np.zeros((Forest.shape),dtype=np.float)
            else:
                Vol_ha = np.zeros_like(Forest,dtype=np.int8)
        #Couche vol_am
        if file_Vol_AM != "":
            Vol_AM = load_float_raster_simple(file_Vol_AM) 
            Vol_AM[Vol_AM<0]=0
            Vol_AM[np.isnan(Vol_AM)]=0
            test_vam = True
        else:
            test_vam = False  
            if file_Vol_ha != "":
                Vol_AM = np.zeros((Forest.shape),dtype=np.float)   
            else:
                Vol_AM = np.zeros_like(Forest,dtype=np.int8)   
       
        if test_vp or test_vam:             
            Pente = np.load(Rspace_sel+"Pente.npy")
            Vol_AM[Pente>Pente_max_bucheron]=0
            Vol_ha[Pente>Pente_max_bucheron]=0
        nbline = Tab.shape[0]        
        Rast_couv = np.zeros_like(Forest,dtype=np.int8)
        for i in range(0,nbline):
            coordX=Lien_RF[Tab[i,0],1]
            coordY=Lien_RF[Tab[i,0],0]       
            az=Tab[i,1]
            Lline=sqrt((Tab[i,2]-Tab[i,6])**2+(Tab[i,3]-Tab[i,7])**2)                                                      
            if test_vp or test_vam:
                Distance_moyenne,Surface,Vtot,VAM,Rast_couv = fc.get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv,Vol_ha,Vol_AM)
            else:
                Distance_moyenne,Surface,Rast_couv = fc.get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv)
            #Surface foret Dmoy chariot
            Tab[i,13],Tab[i,14]=Surface,Distance_moyenne
            #Vtot IPC
            if test_vp:
                Tab[i,15]=Vtot
            #VAM               
            if test_vam:
                Tab[i,16]=VAM*10
   
    
    ############################################
    ### Calc IPC according to prelevement
    ############################################
    
    Tab2 = np.zeros((Tab.shape[0],Tab.shape[1]+4),dtype=np.int)
    Tab2[:,0:-4]=Tab
    Tab2[:,-4]=np.int_(100.0*Tab[:,15]*prelevement/Tab[:,11])
    del Tab
    gc.collect()    
    Tab2[:,-1]= Lien_RF[Tab2[:,0],0]
    Tab2[:,-2]= Lien_RF[Tab2[:,0],1]     
    del Lien_RF
    gc.collect()
    sup_max=np.max(Tab2[:,17])    
    
    
    lim_list[4]=lim_list[4]/prelevement #in order to account for prelevement in line selection
    
    #Modify selection criteria in case of no volume or vam        
    if np.max(Tab2[:,15])==0:        
        if w_list[4]>0:
            print("Optimisation impossible sur le volume/ipc car aucune information disponible.")   
        w_list[4],lim_list[4]=0,0
        w_list[5],lim_list[5]=0,0
        
    if np.max(Tab2[:,16])==0:
        if w_list[6]>0:
            print("Optimisation impossible sur le volume de l'arbre moyen car aucune information disponible.")
        w_list[6],lim_list[6]=0,0
        
    Rast_couv,Tab_result,Tab_name=select_best_lines(w_list,lim_list,Tab2,
                                                                   nrows,ncols,Csize,
                                                                   Row_ext,Col_ext,D_ext,
                                                                   D_lat,Lhor_max,sup_max)
    del Tab2  
    gc.collect()
    #Get folder
    dirs = [d for d in os.listdir(Rspace_c) if os.path.isdir(os.path.join(Rspace_c, d))]
    list_dir = []
    for dire in dirs:
        if dire[:12]=='Optimisation':
            list_dir.append(dire)
    optnum = len(list_dir)+1
    Dir_result = Rspace_c+'Optimisation'+str(optnum) 
    ### Get best volume
    header = 'ID_pixel Azimuth_deg X_debut Y_debut Alt_debut Hcable_debut X_fin Y_fin Alt_fin Hcable_fin '
    header +='Etat_RouteFor Longueur_reelle Configuration '
    header +='Surface_foret Distance_moy_chariot Volume_total VAM NB_int_sup'
    for num in range(1,sup_max+1):
        header +=' '+'Xcoord_intsup'+str(num)+' Ycoord_intsup'+str(num)+' Alt_intsup'+str(num)
        header +=' '+'Hcable_intsup'+str(num)+' Pression_intsup'+str(num)
    header +='IPC cout'
    Dir_result +=Tab_name  
    header +='\n'
    try:os.mkdir(Dir_result)
    except:pass
    Dir_result+="/"
    filename = Dir_result+"Database_Optim_"+str(optnum)+".gzip" 
    shape_name = Dir_result+"CableLines_Optim_"+str(optnum)+".shp"
    rast_name = Dir_result+"CableArea_Optim_"+str(optnum)
    pyl_name = Dir_result+"Int_sup_Optim_"+str(optnum)+".shp"
    
    save_integer_ascii(filename,header,Tab_result)
    source_src=get_source_src(Rspace_sel+"info_proj.shp")  
    road_network_proj=get_proj_from_road_network(Rspace_sel+"info_proj.shp")
    Line_to_shapefile(Tab_result,shape_name,source_src,prelevement) 
    #New rast_couv to take into account project of cable start
    Rast_couv=create_rast_couv(Tab_result,Dir_result,source_src,Extent,Csize,Lhor_max)
    #Rast_couv[Rast_couv>0]=1
    if not new_calc:
        Forest=np.load(Rspace_sel+"Forest.npy")
        try:         
            Vol_ha=np.load(Rspace_sel+"Vol_ha.npy")
        except:
            Vol_ha=np.zeros_like(Forest)
        try:
            Vol_AM=np.load(Rspace_sel+"Vol_AM.npy")
        except:
            Vol_AM=np.zeros_like(Forest)    
    Rast_couv[Forest==0]=0
    ArrayToGtiff(Rast_couv,rast_name,Extent,nrows,ncols,road_network_proj,0,'UINT8')    
    Pylone_in_shapefile(Tab_result,pyl_name,source_src)
    ### Summary of the choice
    generate_info_ligne(Dir_result,w_list,lim_list,Tab_result,Rast_couv,Vol_ha,Vol_AM,Csize,prelevement,Lhor_max) 
    print("Selection des meilleures lignes de cable terminee.")
 
def process_cable():



#######################################################################
#    _______. __  ___  __   _______   _______   _______ .______       #
#    /       ||  |/  / |  | |       \ |       \ |   ____||   _  \     #
#   |   (----`|  '  /  |  | |  .--.  ||  .--.  ||  |__   |  |_)  |    #
##   \   \    |    <   |  | |  |  |  ||  |  |  ||   __|  |      /     #
#.----)   |   |  .  \  |  | |  '--'  ||  '--'  ||  |____ |  |\  \----.#
#|_______/    |__|\__\ |__| |_______/ |_______/ |_______|| _| `._____|#
#######################################################################
# Fonctions qui gère les calculs liés au skidder
def Skidder():
    console_info("Skidder")


def create_new_road_network(file_shp_Desserte,Wspace):
    Dir_temp = Wspace+"Temp/"    
    try:os.mkdir(Dir_temp)
    except:pass 
    File_fin = Dir_temp+"Existing_roads.shp"    
    source_ds = ogr.Open(file_shp_Desserte)
    source_layer = source_ds.GetLayer()
    source_src = source_layer.GetSpatialRef()
    driver = ogr.GetDriverByName('ESRI Shapefile')
    target_ds = driver.CreateDataSource(File_fin)
    layerName = os.path.splitext(os.path.split(File_fin)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn("CL_SVAC", ogr.OFTInteger)
    layer.CreateField(new_field)
    for feat in source_layer:
        geometry = feat.GetGeometryRef()
        label = feat.GetField('EXIST')
        if label == 2:
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetField("CL_SVAC",feat.GetField("CL_SVAC"))
            layer.CreateFeature(feature)
            feature.Destroy()
    source_ds.Destroy()
    target_ds.Destroy()
    return File_fin


def make_summary_surface_vol(Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,Dtotal,Vtot,Vtot_non_buch,Rspace_s,modele_name):
    Skid_list = Debclass.split(";")
    nbclass = len(Skid_list)
            
    Table = np.empty((nbclass+7,9),dtype='|U39')
    Table[0] = np.array(["Distance totale de debardage",
                         "Surface (ha)","Surface par classe (%)","Surface cumulee (ha)","Surface cumulee (%)",
                         "Volume (m3)","Volume par classe (%)","Volume cumule (m3)","Volume cumule (%)"])    
    Table[nbclass+2:nbclass+7,0]=["Total foret accessible","Total foret inaccessible",
                                  "    dont non bucheronnable","",
                                  "Superficie totale de la foret"]
    file_name = str(Rspace_s)+"Resume_resultats_Sylvaccess_"+modele_name+".txt"  
        
    #SURFACE
    Surf_Cum = 0 
    for i in range(1,nbclass):
        dmin,dmax = int(Skid_list[i-1]),int(Skid_list[i])
        class_text = str(Skid_list[i-1])+" - "+str(Skid_list[i])+" m"
        Temp = np.sum((Dtotal>=dmin)*(Dtotal<dmax)*Csize*Csize*0.0001)
        Table[i,0:5] = np.array([class_text,str(round(Temp,1)),
                                str(round(Temp/Surf_foret*100,1)),
                                str(round((Temp+Surf_Cum),1)),
                                str(round((Temp+Surf_Cum)/Surf_foret*100,1))])
        Surf_Cum += Temp
    #add infinite distance class 
    dmin = int(Skid_list[nbclass-1])
    Temp = np.sum((Dtotal>=dmin)*Csize*Csize*0.0001)
    Table[nbclass,0:5] = np.array(["> "+str(dmin)+" m",str(round(Temp,1)),
                                   str(round(Temp/Surf_foret*100,1)),
                                   str(round((Temp+Surf_Cum),1)),
                                   str(round((Temp+Surf_Cum)/Surf_foret*100,1))])
    Surf_Cum += Temp  
         
    Table[-5,1] = str(round(Surf_Cum,1))+" ha"
    Table[-5,2] = str(round(Surf_Cum/Surf_foret*100,1))+" %"
    Table[-4,1] = str(round(Surf_foret-Surf_Cum,1))+" ha"
    Table[-4,2] = str(round((Surf_foret-Surf_Cum)/Surf_foret*100,1))+" %"
    Table[-3,1] = str(round(Surf_foret_non_access,1))+" ha"
    Table[-3,2] = str(round(Surf_foret_non_access/Surf_foret*100,1))+" %"        
    Table[-1,1] = str(round(Surf_foret,1))+" ha"
        
    #VOLUME            
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)]=0
                
        #Create recap per distance class 
        Vol_Cum = 0
        for i in range(1,nbclass):
            dmin,dmax = int(Skid_list[i-1]),int(Skid_list[i])            
            Temp = ((Dtotal>=dmin)*(Dtotal<dmax)*(Vol_ha>=0))>0
            if np.sum(Temp>0):
                Vclass = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
            else:
                Vclass = 0
            Table[i,5:9] = np.array([str(int(Vclass+0.5)),str(round(Vclass/Vtot*100,1)),
                                    str(int(Vclass+Vol_Cum+0.5)),
                                    str(round(100*(Vclass+Vol_Cum)/Vtot,1))])
            Vol_Cum +=Vclass
        #add infinite distance class 
        dmin = int(Skid_list[nbclass-1])
        Temp = ((Dtotal>=dmin)*(Vol_ha>=0))>0
        if np.sum(Temp>0):
            Vclass = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        else:
            Vclass = 0
        Table[nbclass,5:9] = np.array([str(int(Vclass+0.5)),str(round(Vclass/Vtot*100,1)),
                                    str(int(Vclass+Vol_Cum+0.5)),
                                    str(round(100*(Vclass+Vol_Cum)/Vtot,1))])
          
        Vol_Cum +=Vclass        
        Table[-5,5] = str(int(Vol_Cum+0.5))+" m3"
        Table[-5,6] = str(round(100*Vol_Cum/Vtot,1))+" %"
        Table[-4,5] = str(int(Vtot-Vol_Cum+0.5))+" m3"
        Table[-4,6] = str(round(100*(Vtot-Vol_Cum)/Vtot,1))+" %"
        Table[-3,5] = str(int(Vtot_non_buch+0.5))+" m3"
        Table[-3,6] = str(round(100*(Vtot_non_buch)/Vtot,1))+" %"  
        Table[-1,5] = str(int(Vtot+0.5))+" m3"
      
        np.savetxt(file_name, Table,fmt='%s', delimiter=';')
        
    else:
        np.savetxt(file_name, Table[:,0:5],fmt='%s', delimiter=';')


def make_dif_files(Rspace,idmod):#idmod 0 : Skidder, 1 : Porteur
    Modele = ["Skidder","Porteur"]
    Rspace_s = Rspace+Modele[idmod]+"/"
    filename = "Resume_resultats_Sylvaccess_"+Modele[idmod]+".txt"
    rastname = "Distance_totale_foret_route_forestiere.tif"
    foldExist = Rspace_s+"1_Existant/"
    foldProj = Rspace_s+"2_Projet/"
    txtname = Rspace_s+"Comparaison_avant_apres_projet.txt"
    shpname = "Surface_impactee"

        
        
    #Shapefile des differences
    _,values,_,Extent = raster_get_info(foldExist+rastname)
    Csize = values[4]
    DExist =  load_float_raster_simple(foldExist+rastname)
    DProj =  load_float_raster_simple(foldProj+rastname)
    nrows,ncols = DProj.shape
    Diff2 = DExist-DProj
    Diff2[DExist==-9999]=0
    Diff2[DProj==-9999]=0
    Diff = np.zeros_like(DExist,dtype=np.int8)
    Diff[((DExist==-9999)*(DProj>=0))>0] = 1 #Nouvel accessible
    Diff[((Diff2>0)*(Diff2<500))>0] = 2 
    Diff[((Diff2>500)*(Diff2<1000))>0] = 3
    Diff[((Diff2>1000)*(Diff2<1500))>0] = 4
    Diff[Diff2>1500] = 5
    Surf_impact = round(np.sum(Diff>0)*Csize*Csize/10000,1)
    road_network_proj=get_proj_from_road_network(foldExist+ModeleFr[idmod]+"_recap_accessibilite.shp")
    source_src=get_source_src(foldExist+ModeleFr[idmod]+"_recap_accessibilite.shp") 

       
    ArrayToGtiff(Diff,Rspace_s+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    del DExist,DProj,Diff2,Diff
    gc.collect()
    
    label = ["","0_Nouvellement accessible","4_Distance raccourcie de 1 a 500m",
               "3_Distance raccourcie de 500 a 999m", "2_Distance raccourcie de 1000 a 1499m",
               "1_Distance raccourcie d'au moins 1500m"]

    
    ds = gdal.Open(Rspace_s+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("ESRI Shapefile")
    dst_ds = drv.CreateDataSource( Rspace_s+shpname+".shp")
    dst_layer = dst_ds.CreateLayer(shpname, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds = None
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
            feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()    
    
    os.remove(Rspace_s+"Recap.tif")
    
    
    #Tableau des differences   
    TabExist = np.loadtxt(foldExist+filename,dtype='|U39',delimiter=";")
    TabProj = np.loadtxt(foldProj+filename,dtype='|U39',delimiter=";")
    if TabExist.shape[1]<6:        
        colrecap=[1,2]       
    else:        
        colrecap=[1,2,5,6] 
    Table = np.empty((TabExist.shape[0]-3,TabExist.shape[1]),dtype='|U39')    
    Table[0:-3,0]=TabExist[0:-6,0]
    for i in range(1,Table.shape[1]):
        Table[0,i]=str("Diff. ")+TabExist[0,i]
    
    for i in range(1,TabExist.shape[0]-6):
        for j in range(1,Table.shape[1]):
            Table[i,j]=round(float(TabProj[i,j])-float(TabExist[i,j]),1)
    
    Table[-2,0]="Total foret accessible supplementaire"
    Table[-1,0]="Surface de foret impactee"
            
    for i in colrecap:
        Table[-2,i]=round(np.sum(np.float32(Table[1:-3,i])),1)
        
    Table[-1,1:3]=Surf_impact,round(Surf_impact/float(TabExist[-1,1][:-3])*100,1)   
    np.savetxt(txtname, Table,fmt='%s', delimiter=';') 


def prepa_obstacle_skidder(Obstacles_directory,Extent,Csize,ncols,nrows,Rast_desserte_ok):
    liste_file = os.listdir(Obstacles_directory)
    liste_obs = []
    for files in liste_file:
        if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
    if len(liste_obs)>0:
        Obstacles_skidder = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        Temp = (Rast_desserte_ok>0)
        Obstacles_skidder[Temp] = 0
    else: Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    return Obstacles_skidder


def create_buffer_skidder(Csize,Dtreuil_max_up,Dtreuil_max_down):
    Lcote = max(Dtreuil_max_up,Dtreuil_max_down)+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((max(Dtreuil_max_up,Dtreuil_max_down)/Csize+1.5))
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)    
    for az in Dir_list:
        #Fill line info
        _,_,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lcote,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],3))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix        
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line


def create_access_shapefile(Dtotal,Rspace_s,Foret,HarvClass_list,road_network_proj,source_src,Dir_temp,Extent,nrows,ncols,layer_name):
    Recap = np.copy(Foret)
    #0: no Forest
    #1: inaccessible forest
    #2: Non_buch
    #Then harvesting classes
    label = ["Zone hors foret","Inaccessible","Zone non exploitable (pente trop elevee)"]
    nbclass = len(HarvClass_list)    
    for i in range(1,nbclass):
        dmin,dmax = int(HarvClass_list[i-1]),int(HarvClass_list[i])
        label.append("Accessible - Classe de debardage "+str(i)+' : '+str(HarvClass_list[i-1])+" - "+str(HarvClass_list[i])+" m")
        Temp = ((Dtotal>=dmin)*(Dtotal<dmax)*(Foret==1))>0
        Recap[Temp]=2+i
    #add infinite distance class 
    dmin = int(HarvClass_list[nbclass-1])
    label.append("Accessible - Classe de debardage "+str(nbclass)+" : > "+str(dmin)+" m")
    Temp = ((Dtotal>=dmin)*(Foret==1))>0
    Recap[Temp]=2+nbclass
    #Get area too slopy for harvesting
    Temp = load_float_raster_simple(Rspace_s+'Pente_ok_buch.tif')
    Temp = ((Temp!=1)*(Foret==1))>0
    Recap[Temp]=2
    #Save as Gtiff
    ArrayToGtiff(Recap,Dir_temp+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    #Convert to shape
    type_mapping = { gdal.GDT_Byte: ogr.OFTInteger,
                 gdal.GDT_UInt16: ogr.OFTInteger,   
                 gdal.GDT_Int16: ogr.OFTInteger,    
                 gdal.GDT_UInt32: ogr.OFTInteger,
                 gdal.GDT_Int32: ogr.OFTInteger,
                 gdal.GDT_Float32: ogr.OFTReal,
                 gdal.GDT_Float64: ogr.OFTReal,
                 gdal.GDT_CInt16: ogr.OFTInteger,
                 gdal.GDT_CInt32: ogr.OFTInteger,
                 gdal.GDT_CFloat32: ogr.OFTReal,
                 gdal.GDT_CFloat64: ogr.OFTReal}

    ds = gdal.Open(Dir_temp+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("ESRI Shapefile")
    dst_ds = drv.CreateDataSource( Rspace_s+layer_name+".shp" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', type_mapping[srcband.DataType])
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds.FlushCache()
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
        feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()


def create_arrays_from_roads(source_shapefile,Extent,Csize):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #Recupere le driver
    #Get information from source shapefile
    source_ds = ogr.Open(source_shapefile)
    source_layer = source_ds.GetLayer()    
    source_type = source_layer.GetGeomType()
    source_srs = source_layer.GetSpatialRef()
    ###################################################
    ###                                                      __     __ __       
    ###.----.-----.-----.-----.---.-.--.--.    .-----.--.--.|  |--.|  |__|.----.
    ###|   _|  -__|__ --|  -__|  _  |  |  |    |  _  |  |  ||  _  ||  |  ||  __|
    ###|__| |_____|_____|_____|___._|_____|    |   __|_____||_____||__|__||____|
    ###                                        |__|                                 
    expression = '"CL_SVAC" = 3'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Res_pub = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###                   __               ___                          __   __                   
    ###.----.-----.--.--.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|   _|  _  |  |  ||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|__| |_____|_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
                                                                                           
    expression = '"CL_SVAC" = 2'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Route_For = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###        __         __               ___                          __   __                   
    ###.-----.|__|.-----.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|  _  ||  ||__ --||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|   __||__||_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
    ###|__|                                                                                       
    expression = '"CL_SVAC" = 1'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Piste = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    source_ds.Destroy()    
    return Res_pub,Route_For,Piste
