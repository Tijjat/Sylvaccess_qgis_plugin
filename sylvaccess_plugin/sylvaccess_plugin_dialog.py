# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Sylvaccess_pluginDialog
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5 import QtWidgets, uic
from PyQt5.QtWidgets import QFileDialog
import os
from qgis.core import *
from scipy import spatial
import numpy as np
from osgeo import gdal, osr, ogr
import math
#from cython import pyximport
#pyximport.install()
#import sylvaccess_cython3 as fc
from math import sqrt,degrees,atan,cos,sin,radians
import shutil
import gc
import datetime


# Chargement de l'interface utilisateur depuis le fichier .ui
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'sylvaccess_plugin_dialog_base.ui'))

class Sylvaccess_pluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        super(Sylvaccess_pluginDialog, self).__init__(parent)
        self.setupUi(self)

        # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
        for i in range(1, 14):
            button = getattr(self, f"pushButton_{i}")
            button.clicked.connect(lambda _, num=i: self.open_folder(num))

        # Connexion des signaux des checkbox
        for i in range(1, 5):
            checkbox = getattr(self, f"checkBox_{i}")
            checkbox.stateChanged.connect(lambda _, num=i: self.checkbox_state_changed(num))

        # Connexion des signaux des boutons OK et Annuler
        self.button_box.accepted.connect(self.launch)
        self.button_box.rejected.connect(self.reject)
        self.spinBox_40.valueChanged.connect(self.spinBox_40_changed)

    # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
    def open_folder(self, button_number):
        # Définit les filtres génériques pour Shapefiles et fichiers raster
        shapefile_filter = "Shapefiles (*.shp);;All files (*)"
        raster_filter = "Raster files (*.tif *.asc *.txt);;All files (*)"

        # Définit les options de la boîte de dialogue
        options = QFileDialog.Options()
        #options |= QFileDialog.DontUseNativeDialog

        # Affiche le dialogue de sélection de fichier avec les filtres appropriés
        if button_number in [4, 5, 6]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, "Choisir un fichier", filter=shapefile_filter, options=options)
        elif button_number in [3, 11, 12, 13]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, "Choisir un fichier", filter=raster_filter, options=options)
        elif button_number in [1, 2, 7, 8, 9, 10]:  # Pour le bouton qui doit ouvrir un dossier
            selected_file = QFileDialog.getExistingDirectory(
                None, "Choisir un dossier", options=options)

        if selected_file:
            # Mise à jour du champ de texte approprié
            if button_number == 2:
                text_edit = getattr(self, f"lineEdit_2")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_17")
                text_edit.setText(selected_file)
            elif button_number == 4 :
                text_edit = getattr(self, f"lineEdit_4")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_14")
                text_edit.setText(selected_file)
            elif button_number == 13:
                text_edit = getattr(self, f"lineEdit_13")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_15")
                text_edit.setText(selected_file)
            elif button_number == 12 :
                text_edit = getattr(self, f"lineEdit_12")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_16")
                text_edit.setText(selected_file)
            else:
                text_edit = getattr(self, f"lineEdit_{button_number}")
                text_edit.setText(selected_file)

    # Fonction appelée lorsqu'une checkbox est cochée ou décochée
    def checkbox_state_changed(self, checkbox_number):
        # Récupère l'état de la checkbox
        checkbox = getattr(self, f"checkBox_{checkbox_number}")
        checkbox_state = checkbox.isChecked()

        if checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(True)
                # désactive les lineEdit pour éviter les erreurs
                self.lineEdit_14.setEnabled(False)
                self.lineEdit_15.setEnabled(False)
                self.lineEdit_16.setEnabled(False)
                self.lineEdit_17.setEnabled(False)
                self.spinBox_49.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(True)
            if checkbox_number == 3:
                self.porteur.setEnabled(True) 
            if checkbox_number == 4:
                self.skidder.setEnabled(True)
        elif not checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(False)
            if checkbox_number == 3:
                self.porteur.setEnabled(False) 
            if checkbox_number == 4:
                self.skidder.setEnabled(False)


    def spinBox_40_changed(self):
        value = self.spinBox_40.value()
        self.spinBox_49.setValue(value)

    # Fonction appelée lorsqu'on clique sur le bouton OK
    def launch(self):
        a = self.spinBox_1.value()
        b = self.plainTextEdit_1.toPlainText()
        console_info(a)
        console_info(b)
        for i in range (1,5):
            if not getattr(self, f"lineEdit_{i}").text():
                console_warning("Veuillez remplir tous les champs")
                return
        if self.checkBox_4.isChecked():
            Skidder()
        if self.checkBox_3.isChecked():
            Porteur()
        if self.checkBox_2.isChecked() or self.checkBox_1.isChecked():
            if not getattr(self, f"lineEdit_6".text()):
                console_warning("Veuillez remplir les Départs potentiels de câble")
                return
                if self.checkBox_2.isChecked():
                    Cable()
                if self.checkBox_1.isChecked():
                    Cable_opti()
        else:
            console_warning("Veuillez choisir au moins un type de machine")
            return

    # Fonction qui vérifie que tous les fichiers nécessaires sont bien présents
    def check_files(self):
        verif=True
        test_Skidder = self.checkBox_4.isChecked()
        test_Porteur = self.checkBox_3.isChecked()
        test_cable_optim = self.checkBox_1.isChecked()
        test_Cable = self.checkBox_2.isChecked()
        file_MNT = getattr(self, f"lineEdit_3".text())
        file_shp_Desserte = getattr(self, f"lineEdit_5".text())
        file_shp_Foret = getattr(self, f"lineEdit_4".text())
        file_vol_BP = getattr(self, f"lineEdit_13".text())
        file_vol_AM = getattr(self, f"lineEdit_12".text())
        file_HA = getattr(self, f"lineEdit_14".text())
        new_calc = self.checkBox_6.isChecked()
        file_shp_Cable_dep = getattr(self, f"lineEdit_6".text())

        msg="\nLES PROBLEMES SUIVANTS ONT ETE IDENTIFIES CONCERNANT LES ENTREES SPATIALES: \n"
        #Check MNT
        if test_Skidder+test_Porteur+test_Cable>0:
            try:
                _,values,_,Extent = raster_get_info(file_MNT)   
                if values[5]==None:
                    verif=False
                    msg+=" -   Raster MNT: Aucune valeur de NoData definie\n" 
            except:
                msg+=" -   Raster MNT:  Le chemin d'acces est manquant ou incorrect. Ce raster est obligatoire pour lancer Sylvaccess\n" 
                
        #Check file_shp_Desserte   
        if test_Skidder+test_Porteur>0:
            try:    
                if not check_field(file_shp_Desserte,"CL_SVAC"):
                    verif=False
                    msg+=" -   Couche desserte: Le champs 'CL_SVAC' est manquant\n"  
            except:
                verif=False
                msg+=" -   Couche desserte: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour les modules skidder et porteur\n" 
            

        #Check file_shp_Cable_Dep    
        if test_Cable:   
            try: 
                if not check_field(file_shp_Cable_dep,"CABLE"):
                    verif=False
                    msg+=" -   Couche desserte: Le champs 'CABLE' est manquant\n"  
            except:
                verif=False
                msg+=" -   Couche départs de cable potentiels: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour le module cable\n" 

            
        #Check file_shp_Foret   
        if test_Skidder+test_Porteur+test_Cable>0:    
            try:     
                if not check_field(file_shp_Foret,"FORET"):
                    verif=False
                    msg+=" -   Couche foret: Le champs 'FORET' est manquant\n" 
            except:
                verif=False
                msg+=" -   Couche foret: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour lancer Sylvaccess\n"     
                    
        #Check file_shp_Foret for cable optim
        if not test_Cable and test_cable_optim and new_calc and file_shp_Foret!="":
            try:     
                if not check_field(file_shp_Foret,"FORET"):
                    verif=False
                    msg+=" -   Couche foret (onglet optimisation cable): Le champs 'FORET' est manquant\n" 
            except:
                verif=False
                msg+=" -   Couche foret (onglet optimisation cable): Le chemin d'acces est manquant ou incorrect. \n"     
            
        #Check file_vol_BP,file_vol_AM,file_HA
        FR_name = ["Raster Volume/ha","Raster volume arbre moyen","Raster hauteur des arbres"]
        for i,f in enumerate([file_vol_BP,file_vol_AM,file_HA]):
            if f!="":
                try:
                    _,values2,_,Extent2 = raster_get_info(f)    
                    if values2[5]==None:
                        verif=False
                        msg+=" -   "+FR_name[i]+": Aucune valeur de NoData definie\n" 
                    if not values[4]==values2[4]:
                        verif=False
                        msg+=" -   "+FR_name[i]+": La taille de cellules du raster doit etre la meme que celle du MNT\n" 
                    if not np.all(Extent==Extent2):
                        verif=False
                        msg+=" -   "+FR_name[i]+": L'etendue du raster doit etre la meme que celle du MNT\n" 
                except:
                    verif=False
                    msg+=" -   "+FR_name[i]+": Le chemin d'access est incorrect\n"     

        if not verif:
            msg+="\n"
            msg+="MERCI DE CORRIGER AVANT DE RELANCER SYLVACCESS\n"
            console_warning(msg)
        return verif


    def get_general(self,ski,por,cab,opti,pente):
        if ski:
            ski = getattr(self, f"checkBox_4").isChecked()
        if por:
            por = getattr(self, f"checkBox_3").isChecked()
        if cab:
            cab = getattr(self, f"checkBox_2").isChecked()
        if opti:
            opti = getattr(self, f"checkBox_1").isChecked()
        if pente:
            pente = self.spinBox_1.value()


    def get_spatial(self,Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP):
        if Wspace: 
            Wspace = getattr(self, f"lineEdit_1").text()
        if Rspace:
            Rspace = getattr(self, f"lineEdit_2").text()
        if mnt:
            mnt = getattr(self, f"lineEdit_3").text()
        if foret:
            foret = getattr(self, f"lineEdit_4").text()
        if desserte:
            desserte = getattr(self, f"lineEdit_5").text()
        if dep_cable:
            dep_cable = getattr(self, f"lineEdit_6").text()
        if ski_no_t_d:
            ski_no_t_d = getattr(self, f"lineEdit_7").text()
        if ski_no_t:
            ski_no_t = getattr(self, f"lineEdit_8").text()
        if por_obstacle:
            por_obstacle = getattr(self, f"lineEdit_9").text()
        if cab_obstacle:
            cab_obstacle = getattr(self, f"lineEdit_10").text()
        if HA:
            HA = getattr(self, f"lineEdit_11").text()
        if VAM:
            VAM = getattr(self, f"lineEdit_12").text()
        if VBP:
            VBP = getattr(self, f"lineEdit_13").text()

        return Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP


    def get_skidder(self,pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes_s):
        if pente_max:
            pente_max = self.spinBox_3.value()
        if distance_max_amont:
            distance_max_amont = self.spinBox_4.value()
        if distance_max_aval:
            distance_max_aval = self.spinBox_5.value()
        if distance_max_hors_frt_dsrt:
            distance_max_hors_frt_dsrt = self.spinBox_6.value() 
        if pente_amont_max:
            pente_amont_max = self.spinBox_7.value()
        if pente_aval_max:
            pente_aval_max = self.spinBox_1.value()
        if limite:
            if self.radioButton_1.isChecked():
                limite = True
            else:
                limite = False
        if bornes_s:
            bornes_s = self.plainTextEdit_1.toPlainText()
            if not bornes_s:
                console_warning("Veuillez remplir les bornes minimales des classes de débardages pour le skidder")
                return
        return pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes_s   


    def get_porteur(self,pente_max,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes_p):
        if pente_max:
            pente_max = self.spinBox_8.value()
        if pente_max_remonant:
            pente_max_remonant = self.spinBox_9.value()
        if pente_max_descendant:
            pente_max_descendant = self.spinBox_12.value()
        if distance_max_pente_sup:
            distance_max_pente_sup = self.spinBox_10.value()
        if distance_max_hors_frt:
            distance_max_hors_frt = self.spinBox_11.value()
        if taille_grue:
            taille_grue = self.doublespinBox_1.value()
        if bornes_p:
            bornes_p = self.plainTextEdit_2.toPlainText()
            if not bornes_p:
                console_warning("Veuillez remplir les bornes minimales des classes de débardages pour le porteur")
                return
        return pente_max,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes_p


    def get_type_cable(self, type_machine,supports_inter,hauteur,longueure_max,longueure_min):
        if type_machine:
            type_machine = self.comboBox_1.currentText()
        if supports_inter:
            supports_inter = self.spinBox_14.value()
        if hauteur:
            hauteur = self.doublespinBox_2.value()
        if longueure_max:
            longueure_max = self.spinBox_16.value()
        if longueure_min:
            longueure_min = self.spinBox_17.value()
        return type_machine,supports_inter,hauteur,longueure_max,longueure_min


    def get_type_chariot(self, type_chariot,masse,pente_min,pente_max_amont,pente_max_aval):
        if type_chariot:
            type_chariot = self.comboBox_2.currentText()
        if masse:
            masse = self.spinBox_22.value()
        if pente_min:
            pente_min = self.spinBox_23.value()
        if pente_max_amont:
            pente_max_amont = self.spinBox_24.value()
        if pente_max_aval:
            pente_max_aval = self.spinBox_25.value()
        return type_chariot,masse,pente_min,pente_max_amont,pente_max_aval      


    def get_proprietes_cable(self,diamètre,masse_li,tension_rupt,elasticité):
        if diamètre:
            diamètre = self.doublespinBox_3.value()
        if masse_li:
            masse_li = self.doublespinBox_4.value()
        if tension_rupt:
            tension_rupt = self.spinBox_26.value()
        if elasticité:
            elasticité = self.spinBox_27.value()
        return diamètre,masse_li,tension_rupt,elasticité


    def get_param_modelisation(self,hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite):
        if hauteur_sup:
            hauteur_sup = self.doublespinBox_5.value()
        if hauteur_mat:
            hauteur_mat = self.doublespinBox_8.value()
        if hauteur_min_cable:
            hauteur_min_cable = self.doublespinBox_6.value()
        if hauteur_max_cable:
            hauteur_max_cable = self.doublespinBox_9.value()
        if pechage:
            pechage = self.spinBox_40.value()
        if masse_max:
            masse_max = self.spinBox_39.value()
        if securite:
            securite = self.doublespinBox_10.value()
        return hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite


    def get_options(self,opti,precision):
        if opti:
            opti = self.checkBox_5.isChecked()
        if precision:
            precision = self.spinBox_41.value()
        return opti,precision


    def get_opti_cable(self,prelevement,recalculer,Rspace_c,foret_c,VBP_c,VAM_c,pechage_c):
        if prelevement:
            prelevement = self.spinBox_48.value()
        if recalculer:
            recalculer = self.checkBox_6.isChecked()
        if Rspace_c:
            Rspace_c = getattr(self, f"lineEdit_17").text()
        if foret_c:
            foret_c = getattr(self, f"lineEdit_14").text()
        if VBP_c:
            VBP_c = getattr(self, f"lineEdit_15").text()
        if VAM_c:
            VAM_c = getattr(self, f"lineEdit_16").text()
        if pechage_c:
            pechage_c = self.spinBox_49.value()
        return prelevement,recalculer,Rspace_c,foret_c,VBP_c,VAM_c,pechage_c


    def get_crit_opti(self,surface,nbr_sup_int,sens_debardage,longueure_ligne,vol_ligne,indice_prelev,VAM,dist_chariot):
        surface_poids,nbr_sup_int_poids,sens_debardage_poids,longueure_ligne_poids,vol_ligne_poids,indice_prelev_poids,VAM_poids,dist_chariot_poids = 0,0,0,0,0,0,0,0   
        if surface and self.checkBox_7.isChecked():
            surface = self.doublespinBox_11.value()
            surface_poids = self.spinBox_18.value()
        else:
            surface = 0
        if nbr_sup_int and self.checkBox_8.isChecked():
            nbr_sup_int = self.spinBox_46.value()
            nbr_sup_int_poids = self.spinBox_19.value()
        else:
            nbr_sup_int = 0
        if sens_debardage and self.checkBox_9.isChecked():
            sens_debardage = self.spinBox_45.value()
            sens_debardage_poids = self.spinBox_20.value()
        else:
            sens_debardage = 0
        if longueure_ligne and self.checkBox_10.isChecked():
            longueure_ligne = self.spinBox_44.value()
            longueure_ligne_poids = self.spinBox_21.value()
        else:
            longueure_ligne = 0
        if vol_ligne and self.checkBox_11.isChecked():
            vol_ligne = self.spinBox_43.value()
            vol_ligne_poids = self.spinBox_31.value()
        else:
            vol_ligne = 0
        if indice_prelev and self.checkBox_12.isChecked():
            indice_prelev = self.doublespinBox_12.value()
            indice_prelev_poids = self.spinBox_32.value()
        else:
            indice_prelev = 0
        if VAM and self.checkBox_13.isChecked():
            VAM = self.doublespinBox_13.value()
            VAM_poids = self.spinBox_33.value()
        else:
            VAM = 0
        if dist_chariot and self.checkBox_14.isChecked():
            dist_chariot = self.spinBox_50.value()
            dist_chariot_poids = self.spinBox_51.value()
        else:
            dist_chariot = 0
        return surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM,VAM_poids,dist_chariot,dist_chariot_poids


# Fonctions qui fait tout les calculs liés au skidder
def Skidder():
    console_info("Skidder")

# Fonctions qui fait tout les calculs liés au porteur
def Porteur():
    console_info("Porteur")

# Fonctions qui fait tout les calculs liés au cable
def Cable():
    console_info("Cable")

# Fonctions qui fait tout les calculs liés à l'optimisation des emplacement des lignes de cable
def Cable_opti():
    console_info("Cable_opti")

# Fonctions qui affiche un message d'erreur dans la console
def console_warning(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Warning)

# Fonctions qui affiche un message d'information dans la console
def console_info(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Info)


def heures(Hdebut):
    Hfin = datetime.datetime.now()
    duree = Hfin - Hdebut
    ts = duree.seconds
    nb_days = int(ts/3600./24.)
    ts -= nb_days*3600*24
    nb_hours = int(ts/3600)
    ts -= nb_hours*3600
    nb_minutes = int(ts/60)
    ts -= nb_minutes*60  
    if nb_days>0:
        str_duree = str(nb_days)+'j '+str(nb_hours)+'h '+str(nb_minutes)+'min '+str(ts)+'s'
    elif nb_hours >0:
        str_duree = str(nb_hours)+'h '+str(nb_minutes)+'min '+str(ts)+'s'
    elif nb_minutes>0:
        str_duree = str(nb_minutes)+'min '+str(ts)+'s'
    else:
        str_duree = str(ts)+'s'        
        str_debut = str(Hdebut.day)+'/'+str(Hdebut.month)+'/'+str(Hdebut.year)+' '+str(Hdebut.hour)+':'+str(Hdebut.minute)+':'+str(Hdebut.second)
        str_fin = str(Hfin.day)+'/'+str(Hfin.month)+'/'+str(Hfin.year)+' '+str(Hfin.hour)+':'+str(Hfin.minute)+':'+str(Hfin.second)

    return str_duree,str_fin,str_debut


def get_info_ascii(file_name):
    fs = open(file_name, 'r')
    head_text=''
    line = 1
    while line<7:
        head_text = head_text+fs.readline()
        line=line+1
    fs.close()
    Csize = np.genfromtxt(file_name, dtype=None,usecols=(1))[4]
    return head_text, Csize


def save_integer_ascii(file_name,head_text,data):
    np.savetxt(file_name, data, fmt='%i', delimiter=' ')
    with open(file_name, "r+") as f:
        old = f.read()
        f.seek(0)
        f.write(head_text + old)
        f.close()


def save_float_ascii(file_name,head_text,data):
    np.savetxt(file_name, data, fmt='%f', delimiter=' ')
    with open(file_name, "r+") as f:
        old = f.read()
        f.seek(0)
        f.write(head_text + old)
        f.close()


def replace_all(text, dic):
    for i, j in dic.iteritems(): text = text.replace(i, j)
    return text


def read_info(info_file):
    names = np.genfromtxt(info_file, dtype=None,usecols=(0),encoding ='latin1')
    values = np.genfromtxt(info_file, dtype=None,usecols=(1),encoding ='latin1')  
    return list(names),list(values)


def raster_get_info(in_file_name):
    source_ds = gdal.Open(in_file_name)    
    src_proj = osr.SpatialReference(wkt=source_ds.GetProjection())
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform()
    ymin = ymax+src_nrows*Csize_y
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [src_ncols,src_nrows,xmin,ymin,Csize_x,nodata]
    Extent = [xmin,xmin+src_ncols*Csize_x,ymin,ymax]
    return names,values,src_proj,Extent


def check_field(filename,fieldname):
    verif=False    
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break    
    source_ds.Destroy() 
    return verif


def check_field_EXIST(filename,fieldname):    
    verif=False
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break
    if verif:
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))      
        nbval = np.unique(vals).shape[0]
        if nbval==1:
            verif=False
    source_ds.Destroy() 
    return verif


def generate_HeadText(names,values):    
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    return head_text


def save_raster_info(values,Rspace_c):   
    np.savetxt(Rspace_c+"Area_extent.txt", values, fmt='%f', delimiter=';')


def loadrasterinfo_from_file(Rspace_c):
    values = list(np.loadtxt(Rspace_c+"Area_extent.txt"))
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']    
    ncols = values[0]
    nrows = values[1]
    xmin=values[2]
    ymin = values[3]    
    Csize = values[4] 
    Extent = [xmin,xmin+ncols*Csize,ymin,ymin+nrows*Csize]
    return names,values,Extent


def load_float_raster(raster_file,Dir_temp):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [round(cols,2), round(rows,2), round(xmin,2), round(ymin,2), round(Csize,2),round(nodatavalue,2)]
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    f = open(Dir_temp+'info_extent.txt',"w")
    f.write(head_text)
    f.close()
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array),Extent,Csize,proj 


def load_float_raster_simple(raster_file):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)    
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()    
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array)


def get_source_src(file_name):
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()
    return source_layer.GetSpatialRef()


def shapefile_to_np_array(file_name,Extent,Csize,attribute_name,order_field=None,order=None):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)
    # Get information from source shapefile
    orig_data_source = ogr.Open(file_name)
    source_ds = ogr.GetDriverByName("Memory").CopyDataSource(orig_data_source, "")
    source_layer = source_ds.GetLayer()
    if order:
        source_layer_ordered = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' ORDER BY '+order_field+' '+order)
    else:source_layer_ordered=source_layer
    source_srs = source_layer.GetSpatialRef()
    # Initialize the new memory raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], source_layer_ordered,options=["ATTRIBUTE="+attribute_name,"ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        return mask_arr


def select_in_shapefile(source_shapefile,out_Shape_Path,expression):
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    #Get information from source shapefile
    source_ds = ogr.Open(source_shapefile)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    source_type = source_layer.GetGeomType()
    try: source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' '+expression)   
    except: print("Erreur de syntaxe dans l'expression")
    # Initialize the output shapefile
    if os.path.exists(out_Shape_Path):
        driver.DeleteDataSource(out_Shape_Path)
    target_ds = driver.CreateDataSource(out_Shape_Path)
    layerName = os.path.splitext(os.path.split(out_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    target_ds.Destroy()
    source_ds.Destroy()


def linestring_to_point(Line_shapefile,Point_Shape_Path):
    #Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Get line info
    source_ds = ogr.Open(Line_shapefile)
    source_layer = source_ds.GetLayer()
    source_srs = source_layer.GetSpatialRef()
    geoLocations = []
    ind = 1
    for feat in source_layer:
        geom = feat.GetGeometryRef()
        points = geom.GetPointCount()          
        for p in range(points):
            lon, lat,a = geom.GetPoint(p)
            geoLocations.append([lon,lat,ind])
        ind +=1
    geoLocations = np.array(geoLocations)
    fins_ligne = fin_ligne(geoLocations)
    # Create output point shapefile
    if os.path.exists(Point_Shape_Path):driver.DeleteDataSource(Point_Shape_Path)
    target_ds = driver.CreateDataSource(Point_Shape_Path)
    layerName = os.path.splitext(os.path.split(Point_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('IND_LINE', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('FIN_LIGNE', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind = 0
    for pointIndex, geoLocation in enumerate(geoLocations):
        # Create point
        geometry = ogr.Geometry(ogr.wkbPoint)
        geometry.SetPoint(0, geoLocation[0], geoLocation[1])
        # Create feature
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(pointIndex)
        feature.SetField('IND_LINE',int(geoLocation[2]))
        if pointIndex==fins_ligne[ind]:
            feature.SetField('FIN_LIGNE',1)
            ind +=1
            if ind > len(fins_ligne)-1:
                ind-=1
        else:
            feature.SetField('FIN_LIGNE',0)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        geometry.Destroy()
        feature.Destroy()
    # Cleanup
    target_ds.Destroy()
    return geoLocations,source_srs


def fin_ligne(point_coords):
    fin_ligne = []
    for i in range(point_coords.shape[0]-1):
        ind = np.sum((point_coords[:,0]==point_coords[i,0])*(point_coords[:,1]==point_coords[i,1]))
        if ind ==1:
            if i>0 and i+1<point_coords.shape[0]:
                if point_coords[i-1,2]!=point_coords[i,2] or point_coords[i+1,2]!=point_coords[i,2]:
                    fin_ligne.append(i)
            elif i==0 and point_coords[i+1,2]==point_coords[i,2]:fin_ligne.append(i)
            elif i==point_coords.shape[0]-1 and point_coords[i-1,2]==point_coords[i,2]:fin_ligne.append(i)
    return fin_ligne  


def points_to_lineshape(point_coords,Line_Shape_Path,projection):
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('DIRECTION', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind = 0
    while ind<point_coords.shape[0]-1:        
        if point_coords[ind+1,2]==point_coords[ind,2]:
            line = ogr.Geometry(ogr.wkbLineString)
            line.AddPoint(point_coords[ind,0],point_coords[ind,1])
            line.AddPoint(point_coords[ind+1,0],point_coords[ind+1,1])
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(line)
            feature.SetFID(ind)
            direction = calculate_direction(point_coords[ind,0],point_coords[ind,1], point_coords[ind+1,0],point_coords[ind+1,1])
            if ind+2< point_coords.shape[0] and point_coords[ind+1,2]==point_coords[ind+2,2]:
                feature.SetField('DIRECTION',direction)
            else:
                if direction <0:feature.SetField('DIRECTION',direction%180)
                else:feature.SetField('DIRECTION',direction%(-180))
            layer.CreateFeature(feature)
            ind +=1
            line.Destroy()
            feature.Destroy()
        else:
            ind +=1
    target_ds.Destroy()


def calculate_direction(x1,y1,x2,y2):
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    return int(Angle+0.5)


def get_head_text(ASCII_file):
    names = np.genfromtxt(ASCII_file, dtype=None,usecols=(0))[0:6]
    values = np.genfromtxt(ASCII_file, dtype=np.float,usecols=(1))[0:6]
    Extent = [values[2],values[2]+values[4]*values[0],values[3],values[3]+values[4]*values[1]]
    return names,values,Extent


def generate_head_text(names,values,Csize):
    rap = int(Csize/values[4])
    values[0],values[1],values[4]= int(values[0]/rap+0.5),int(values[1]/rap+0.5),Csize
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    return head_text


def buffer_shp(infile,outfile,buffdist):
    try:
        ds_in=ogr.Open( infile )
        lyr_in=ds_in.GetLayer( 0 )
        drv=ds_in.GetDriver()
        if os.path.exists( outfile ):
            drv.DeleteDataSource(outfile)
        ds_out = drv.CreateDataSource( outfile )
        layer = ds_out.CreateLayer(lyr_in.GetLayerDefn().GetName(),lyr_in.GetSpatialRef(), ogr.wkbPolygon)
        for i in range ( lyr_in.GetLayerDefn().GetFieldCount() ):
            field_in = lyr_in.GetLayerDefn().GetFieldDefn( i )
            fielddef = ogr.FieldDefn( field_in.GetName(), field_in.GetType() )
            layer.CreateField ( fielddef )
        for feat in lyr_in:
            geom = feat.GetGeometryRef()
            feature = feat.Clone()
            feature.SetGeometry(geom.Buffer(float(buffdist)))
            layer.CreateFeature(feature)
            del geom
        ds_out.Destroy()
    except:
        return False
    return True


def shapefile_obs_to_np_array(file_list,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Obstacle = np.zeros((nrows,ncols),dtype=np.int)
    #Loop on all shaefile
    for shp in file_list:        
        # Get shapefile info
        source_ds = ogr.Open(shp)
        source_layer = source_ds.GetLayer()    
        source_srs = source_layer.GetSpatialRef()
        source_type = source_layer.GetGeomType()
        # Create copy
        target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
        layerName = os.path.splitext(os.path.split(shp)[1])[0]
        layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
        layerDefinition = layer.GetLayerDefn()
        new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
        layer.CreateField(new_field)
        ind=0
        for feat in source_layer:
            geometry = feat.GetGeometryRef()
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(ind)
            feature.SetField('Transfo',1)
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            feature.Destroy()
            ind +=1
        # Initialize raster
        maskvalue = 1    
        xres=float(Csize)
        yres=float(Csize)
        geotransform=(xmin,xres,0,ymax,0, -yres)         
        target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
        target_ds.SetGeoTransform(geotransform)
        if source_srs:
            # Make the target raster have the same projection as the source
            target_ds.SetProjection(source_srs.ExportToWkt())
        else:
            # Source has no projection (needs GDAL >= 1.7.0 to work)
            target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        # Rasterize
        err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
        if err != 0:
            raise Exception("error rasterizing layer: %s" % err)
        else:
            target_ds.FlushCache()
            mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        Obstacle = Obstacle + mask_arr
        target_ds1.Destroy()
        source_ds.Destroy()
    Obstacle = np.int8(Obstacle>0)
    return Obstacle


def shapefile_to_int8array(file_name,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Array = np.zeros((nrows,ncols),dtype=np.int8)      
    # Get shapefile info
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    source_type = source_layer.GetGeomType()
    # Create copy
    target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
    layerName = "shp"
    layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Transfo',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Initialize raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)         
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        Array = target_ds.GetRasterBand(1).ReadAsArray()
    target_ds1.Destroy()
    source_ds.Destroy()
    return Array


def raster_to_ASCII_int(raster_name,ascii_name):
    source_ds = gdal.Open(raster_name)
    content = source_ds.GetRasterBand(1).ReadAsArray()
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform() 
    ymin = ymax + Csize_y*source_ds.RasterYSize
    names = ['ncols','nrows','xllcorner','yllcorner','cellsize','NODATA_value']
    values = [source_ds.RasterXSize,source_ds.RasterYSize,xmin,ymin,Csize_x,-9999]
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    content[content==nodata]=-10000
    head_text=generate_head_text(names,values,Csize_x)
    save_integer_ascii(ascii_name,head_text,np.int_(content+0.5))


def raster_to_ASCII(raster_name,ascii_name):
    source_ds = gdal.Open(raster_name)
    content = source_ds.GetRasterBand(1).ReadAsArray()
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform()   
    ymin = ymax + Csize_y*source_ds.RasterYSize
    names = ['ncols','nrows','xllcorner','yllcorner','cellsize','NODATA_value']
    values = [source_ds.RasterXSize,source_ds.RasterYSize,xmin,ymin,Csize_x,-9999]
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    content[content==nodata]=-9999    
    head_text=generate_head_text(names,values,Csize_x)
    save_float_ascii(ascii_name,head_text,content)


def resample_raster(in_file_name,out_file_name,newCsize,methode=gdal.GRA_Bilinear):
    # Get info from source
    source_ds = gdal.Open(in_file_name)    
    driver = source_ds.GetDriver()
    src_proj = source_ds.GetProjection()
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,a,ymax,b,Csize_y = source_ds.GetGeoTransform()
    xmin,ymax = int(xmin+0.5),int(ymax+0.5)    
    Bandnb = source_ds.RasterCount    
    # Create ouptut raster
    xres=float(newCsize)
    yres=float(newCsize)
    xmax,ymin = xmin+int(float(src_ncols)*float(Csize_x)+0.5),ymax+int(float(src_nrows)*float(Csize_y)-0.5)
    nrows,ncols = int((ymax-ymin)/float(newCsize)+0.5),int((xmax-xmin)/float(newCsize)+0.5) 
    geotransform=(xmin,xres,0,ymax,0,-yres)    
    if os.path.exists(out_file_name):driver.Delete(out_file_name)
    target_ds = driver.Create(out_file_name, int(ncols), int(nrows), Bandnb, gdal.GDT_Float32)    
    target_ds.SetGeoTransform(geotransform)
    if src_proj:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(src_proj)
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        src_proj = 'LOCAL_CS["arbitrary"]'    
    gdal.ReprojectImage(source_ds, target_ds, src_proj, src_proj, methode)
    target_ds.GetRasterBand(1).SetNoDataValue(0)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache() # Flush 


def get_proj_from_road_network(road_network_file):
    source_ds = ogr.Open(road_network_file)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    return source_srs.ExportToWkt()


def ArrayToGtiff(Array,file_name,Extent,nrows,ncols,road_network_proj,nodata_value,raster_type='INT32'):
    xmin,xmax,ymin,ymax=Extent[0],Extent[1],Extent[2],Extent[3]
    xres=(xmax-xmin)/float(ncols)
    yres=(ymax-ymin)/float(nrows)
    geotransform=(xmin,xres,0,ymax,0, -yres)
    if raster_type=='INT32':
        #-2147483648 to 2147483647
        DataType = gdal.GDT_Int32    
    elif raster_type=='UINT8':
        #0 to 255
        DataType = gdal.GDT_Byte
    elif raster_type=='UINT16':
        #0 to 65535    
        DataType = gdal.GDT_UInt16
    elif raster_type=='INT16':
        #-32768 to 32767 
        DataType = gdal.GDT_Int16
    elif raster_type=='FLOAT32':
        #Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
        DataType = gdal.GDT_Float32
    elif raster_type=='FLOAT16':
        #Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
        DataType = gdal.GDT_Float16
    target_ds = gdal.GetDriverByName('GTiff').Create(file_name+'.tif', int(ncols), int(nrows), 1, DataType)
    target_ds.SetGeoTransform(geotransform)
    target_ds.SetProjection(road_network_proj)
    target_ds.GetRasterBand(1).WriteArray( Array )
    target_ds.GetRasterBand(1).SetNoDataValue(nodata_value)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache()


def focal_stat(in_file_name,out_file_name,methode='MEAN',nbcell=3):    
    # Get info of the input raster
    source_ds = gdal.Open(in_file_name)
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    driver = source_ds.GetDriver()
    src_proj = source_ds.GetProjection()
    nrows,ncols = source_ds.RasterYSize,source_ds.RasterXSize
    geotransform = source_ds.GetGeoTransform()
    Bandnb = source_ds.RasterCount   
    Data = source_ds.GetRasterBand(1).ReadAsArray()  
    #Make analysis
    if methode=='MEAN':
        outData = fc.focal_stat_mean(np.float_(Data),float(nodata),nbcell)
    elif methode=='MIN':
        outData = fc.focal_stat_min(np.float_(Data),float(nodata),nbcell)
    elif methode=='MAX':
        outData = fc.focal_stat_max(np.float_(Data),float(nodata),nbcell) 
    elif methode=='NB':
        outData = fc.focal_stat_nb(np.float_(Data),float(nodata),nbcell)   
    elif methode=='SUM':
        outData = fc.focal_stat_sum(np.float_(Data),float(nodata),nbcell)   
    #Inititialiaze output raster
    if os.path.exists(out_file_name):driver.Delete(out_file_name)
    target_ds = driver.Create(out_file_name, int(ncols), int(nrows), Bandnb, gdal.GDT_Float32)    
    target_ds.SetGeoTransform(geotransform)
    if src_proj:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(src_proj)
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        src_proj = 'LOCAL_CS["arbitrary"]' 
    target_ds.GetRasterBand(1).WriteArray(outData)
    target_ds.GetRasterBand(1).SetNoDataValue(nodata)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache() # Flush


def prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize):
    rastLosup,rastTh,rastTv = fc.Tabmesh(d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize)
    np.save(Dir_temp+"rastLosup.npy",rastLosup)
    np.save(Dir_temp+"rastTh.npy",rastTh)
    np.save(Dir_temp+"rastTv.npy",rastTv)
    text  = "d    "+" "+str(round(d,2))+"\n"
    text += "E    "+" "+str(round(E,2))+"\n"
    text += "Tmax "+" "+str(round(Tmax,2))+"\n"
    text += "Lmax "+" "+str(round(Lmax,2))+"\n"
    text += "Fo   "+" "+str(round(Fo,2))+"\n"
    text += "Csize"+" "+str(round(Csize,2))+"\n"
    text += "q1   "+" "+str(round(q1,2))+"\n"
    text += "q2   "+" "+str(round(q2,2))+"\n"
    text += "q3   "+" "+str(round(q3,2))+"\n"
    f = open(Dir_temp+'info_config.txt',"w")
    f.write(text)
    f.close()
    return rastLosup,rastTh,rastTv


def check_tabconv(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize):
    try:
        a,v1=read_info(Dir_temp+"info_config.txt")
        if np.all(np.array([round(d,2),round(E,2),round(Tmax,2),round(Lmax,2),round(Fo,2),round(Csize,2),round(q1,2),round(q2,2),round(q3,2)])==v1):
            rastLosup = np.load(Dir_temp+"rastLosup.npy")
            rastTh = np.load(Dir_temp+"rastTh.npy")
            rastTv = np.load(Dir_temp+"rastTv.npy")
        else:
            rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize)
    except:
        rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,q1,q2,q3,Csize)        
    return rastLosup,rastTh,rastTv


def check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret):
    indmax = 0
    npix = Line.shape[0]
    test = 1
    i=0
    Lline=Lmin-1
    Dsansforet=0.
    for i in range(0,npix): 
        if Line[i,5]<0:break
        if Line[i,5]>=ncols:break
        if Line[i,6]<0:break
        if Line[i,6]>=nrows:break
        if Line[i,7]==1:break
        if sqrt(Line[i,0]*Line[i,0]+(Line[i,1]-Line[0,1])*(Line[i,1]-Line[0,1]))>Lmax:break        
        if (Line[i,8]+Line[i,9])>0:                 
            if Line[i,2]==1:
                indmax = i 
                Dsansforet=0
            else:
                if i>0: Dsansforet+=Line[i,0]-Line[i-1,0]
                if Dsansforet>=Lsans_foret:break
        else:        
            break
    Lline = Line[indmax,0]
    if Lline <= Lmin:
        test=0
    return test,indmax+1,Lline


def get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
              Fo,Tmax,q1,q2,q3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope):
                  
    npix = Nbpix_line[az]
    npix = fc.get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,11),dtype=np.float)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        ### Check pente en devers
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1 
        if test_hfor:
            Line[:,10]=np.round(np.minimum(np.maximum(-7.76961+0.71858*Hfor[inds],0),26))
        else:
            Line[:,10]=Hintsup
        ####Raccourci pour ne pas depasser Hline_max
        indmax=Line.shape[0]-1
        for i in range(indmax,1,-1):  
            test=1
            D = Line[i,0]
            H = abs(Line[0,1]+Htower-(Line[i,1]+Hend))    
            if Line[0,1]+Htower>=Line[i,1]+Hend:
                Xup,Zup =0,Line[0,1]+Htower
                fact = 1. 
            else:    
                Xup,Zup = Line[i,0],Line[i,1]+Hend
                fact = -1.             
            L=sqrt(H*H+D*D)
            F = 0.5*(0.5*L*q2+0.5*L*q3)*9.80665 + Fo  
            fleche = 1.1*(F*L/(4*Tmax)+q1*9.80665*L*L/(8*Tmax))
            for j in range(1,i-1):
                droite = -fact*H/D*(Line[j,0]-Xup)+Zup-Line[j,1]
                if droite-fleche > Hline_max:
                    test=0
                    break
            if test:
                break
        Line=Line[0:i+1]
        test,indmax,Lline=fc.check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret,Lslope,PropSlope)
        Lline = 2 # A modifier    
        return test,Lline,Line[0:indmax, [0, 1, 2, 3, 4, 5, 6,10,9]]
    else:
        return 0,0,0 


def return_profile(Line):
    Line2 = np.zeros_like(Line)
    indmax = Line.shape[0]-1
    Dmax =Line[indmax,0]
    for i,j in enumerate(range(indmax,-1,-1)):
        Line2[i]=Line[j]
        Line2[i,0]=Dmax-Line[j,0]
    return Line2


def write_file():
    Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP = Sylvaccess_pluginDialog.get_spatial(1,1,1,1,1,1,1,1,1,1,1,1,1,1)
    ski,por,cab,opti,pente = Sylvaccess_pluginDialog.get_general(1,1,1,1,1)
    pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes=Sylvaccess_pluginDialog.get_skidder(1,1,1,1,1,1,1,1)
    pente_max2,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes2=Sylvaccess_pluginDialog.get_porteur(1,1,1,1,1,1,1)
    type_machine,supports_inter,hauteur,longueure_max,longueure_min=Sylvaccess_pluginDialog.get_type_cable(1,1,1,1,1)
    type_chariot,masse,pente_min,pente_max_amont,pente_max_aval = Sylvaccess_pluginDialog.get_type_chariot(1,1,1,1,1,1)
    diamètre,masse_li,tension_rupt,elasticité = Sylvaccess_pluginDialog.get_proprietes_cable(1,1,1,1)
    hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite = Sylvaccess_pluginDialog.get_param_modelisation(1,1,1,1,1,1,1)
    opti2,precision = Sylvaccess_pluginDialog.get_options(1,1)
    prelevement,recalculer,Rspace2,foret2,VBP2,VAM2,pechage2 = Sylvaccess_pluginDialog.get_opti_cable(1,1,1,1,1,1,1)
    surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_pluginDialog.get_crit_opti(1,1,1,1,1,1,1,1)
    var_list= [Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP,ski,por,cab,opti,pente,pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,
               pente_amont_max,pente_aval_max,limite,bornes,pente_max2,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes2,type_machine,supports_inter,hauteur,
               longueure_max,longueure_min,type_chariot,masse,pente_min,pente_max_amont,pente_max_aval,diamètre,masse_li,tension_rupt,elasticité,hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,
               masse_max,securite,opti2,precision,prelevement,recalculer,Rspace2,foret2,VBP2,VAM2,pechage2,surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,
               longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids]
    file_name = Rspace2+"all_param.txt"
    text=var_list[0]
    for var in var_list[1:]:
        text+="\n"
        text+= str(var)
    fichier = open(file_name, "w")
    fichier.write(text)
    fichier.close()


def azimuth(X0,Y0,X1,Y1):
    dX=abs(X0-X1)
    dY=abs(Y0-Y1)
    #cas 1:cadran en haut a droite
    if (X1>X0) and (Y1>Y0):
        az=degrees(atan(dX*1.0/dY))
    #cas 2:cadran en bas a droite
    elif (X1>X0) and (Y1<Y0):
        az=180-degrees(atan(dX*1.0/dY))
    #cas 3:cadran en haut a gauche
    elif (X1<X0) and (Y1>Y0):
        az=360-degrees(atan(dX*1.0/dY)) 
    #cas 4:cadran en bas a gauche
    elif (X1<X0) and (Y1<Y0):
        az=180+degrees(atan(dX*1.0/dY)) 
    #cas 5:horizontal gauche
    elif (dY==0) and (X1>X0):
        az=90
    #cas 6:horizontal droite
    elif (dY==0) and (X1<X0):
        az=90*3
    #cas 7:vertical haut
    elif (Y1>=Y0) and (dX==0):
        az=0
    #cas 8:vertical bas
    elif (Y1<Y0) and (dX==0):
        az=180
    return az


def from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az):    
    X1 = sin(radians(az))*Lmax
    Y1 = cos(radians(az))*Lmax
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    line = ogr.Geometry(ogr.wkbLineString)
    line.AddPoint(0,0)
    line.AddPoint(X1,Y1)
    feature = ogr.Feature(layerDefinition)
    feature.SetGeometry(line)
    feature.SetFID(az)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return X1,Y1,mask_arr


def check_common_line(item,Row_line,Col_line,D_line,nb_pix):
    i=0
    while (Row_line[item-1,i]==Row_line[item,i]) and (Col_line[item-1,i]==Col_line[item,i]) and i<nb_pix:
        i+=1
    return D_line[item,i-1]


def pt_emprise(X0,Y0,X1,Y1,Lhor_max):
    az=azimuth(X0,Y0,X1,Y1)
    #deb + 90
    X = [X0+sin(radians(az+90))*Lhor_max]
    Y = [Y0+cos(radians(az+90))*Lhor_max]
    #deb - 90
    X.append(X0+sin(radians(az-90))*Lhor_max)
    Y.append(Y0+cos(radians(az-90))*Lhor_max)
    #fin - 90
    X.append(X1+sin(radians(az-90))*Lhor_max)
    Y.append(Y1+cos(radians(az-90))*Lhor_max)
    #fin + 90
    X.append(X1+sin(radians(az+90))*Lhor_max)
    Y.append(Y1+cos(radians(az+90))*Lhor_max)
    return [X,Y] 


def point_line_to_line_ext(X0,Y0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize):
    ### Create mask_array
    X,Y = pt_emprise(X0,Y0,X1,Y1,Lhor_max)
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbPolygon)
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    # create polygon object:
    myRing = ogr.Geometry(ogr.wkbLinearRing)
    for i in range(0,len(X)):
        myRing.AddPoint(X[i],Y[i])
    myRing.AddPoint(X[0],Y[0])#close ring
    poly = ogr.Geometry(type=ogr.wkbPolygon)
    poly.AddGeometry(myRing)
    feature = ogr.Feature( layer.GetLayerDefn() )
    feature.SetGeometry(poly)
    feature.SetFID(1)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return mask_arr


def get_car_dist(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        _ ,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
    return mat


def get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        distance,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
        mat[i,3]=distance
    return mat


def ligh_line(mat,Dmin):
    mat[0,3]=1
    for i in range(1,mat.shape[0]):
        if (mat[i,2]-mat[i-1,2])>Dmin:
            mat[i,3]=1
    return mat[mat[:,3]>0]


def create_buffer(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+1))
        mat[:,:-1] = inds
        mat = get_car_dist(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],Dir_list


def create_buffer2(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*-1
    D_lat = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+2))
        mat[:,:-2] = inds
        mat= get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))               
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        D_lat[az,0:nb_pix]=mat[ind,3]*Csize
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],D_lat[:,0:Nbpix_ext],Dir_list


def get_ligne(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret):
    npix = Nbpix_line[az]
    npix = fc.get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,10),dtype=np.float)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1
        test,indmax,Lline=fc.check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret)    
        return test,Lline,Line[0:indmax,0:7]
    else:
        return 0,0,0

def create_az_rules(angle_transv):
    matrice = np.zeros((360,360),dtype=np.int8)
    b1 = 90-angle_transv
    b2 = 90+angle_transv
    b3 = 270-angle_transv
    b4 = 270+angle_transv
    matrice[0,0:b1]=1
    matrice[0,b2:b3]=1
    matrice[0,b4:360]=1
    for expo in range(1,360,1):
        matrice[expo,0]=matrice[expo-1,359]
        for azi in range(1,360,1):
            matrice[expo,azi]=matrice[expo-1,azi-1]
    return matrice 


def Line_to_shapefile(Tab,Cable_line_Path,source_src,prelevement,language):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    fieldvol = 'Volume_'+str(int(100*prelevement))
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xstart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ystart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Yend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Id_route', ogr.OFTInteger)
    layer.CreateField(new_field)
    if language=='FR':
        new_field = ogr.FieldDefn('Desserte', ogr.OFTString) 
        
    else:
        new_field = ogr.FieldDefn('Road', ogr.OFTString)                              
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AzimuthDeg', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Long', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Config', ogr.OFTString)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('NbIntSup', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Surface', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn(fieldvol, ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('IPC', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Dmoy', ogr.OFTInteger)
    layer.CreateField(new_field)
    cneg = "Debardage vers l'aval"
    cpos = "Debardage vers l'amont"
    proj = "En projet"
    exis = "Existant"

    
    for ind,S in enumerate(Tab):
        line = ogr.Geometry(ogr.wkbLineString)
        line.AddPoint(float(S[2]),float(S[3]))
        line.AddPoint(float(S[6]),float(S[7]))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('IdLine',ind+1)
        feature.SetField('Xstart',float(S[2]))
        feature.SetField('Ystart',float(S[3]))
        feature.SetField('Xend',float(S[6]))
        feature.SetField('Yend',float(S[7]))
        if int(S[10])==2: 
            feature.SetField('Desserte',exis)
        else:
            feature.SetField('Desserte',proj)
        feature.SetField('Id_route',int(S[0]))
        feature.SetField('AzimuthDeg',int(S[1]))
        feature.SetField('Long',int(S[11]))
        if int(S[12])>0:
            feature.SetField('Config',cpos)
        else:
            feature.SetField('Config',cneg)
        feature.SetField('NbIntSup',int(S[17]))
        feature.SetField('Surface',S[13]/10000.)
        feature.SetField('Dmoy',int(S[14]))
        feature.SetField(fieldvol,int(S[15]*prelevement))
        feature.SetField('IPC',S[15]*prelevement/float(S[11]))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
    target_ds.Destroy()


def Pylone_in_shapefile(Tab,Cable_line_Path,source_src):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]    
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xpyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ypyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Altitude', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Hcable', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pression', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pyl_pos', ogr.OFTInteger)
    layer.CreateField(new_field)
    idi = 0
    for ind,S in enumerate(Tab):
        nb=1
        for pyl in range(int(S[17])):  
            point = ogr.Geometry(ogr.wkbPoint)
            point.SetPoint(0, float(S[18+5*pyl]),float(S[19+5*pyl]))         
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(point)
            feature.SetFID(idi)
            feature.SetField('IdLine',ind+1)
            feature.SetField('Xpyl',float(S[18+5*pyl]))
            feature.SetField('Ypyl',float(S[19+5*pyl]))
            feature.SetField('Altitude',float(S[20+5*pyl]))
            feature.SetField('Hcable',float(S[21+5*pyl]))
            feature.SetField('Pression',float(S[22+5*pyl]))
            feature.SetField('Pyl_pos',int(nb)             )    
            layer.CreateFeature(feature)
            point.Destroy()
            feature.Destroy()
            idi+=1
            nb+=1
    target_ds.Destroy()


def create_coord_pixel_center_raster(values,nline,ncol,Csize,Dir_temp):
    Xcoord = np.zeros((ncol),dtype=np.float)
    Ycoord = np.zeros((nline),dtype=np.float)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    np.save(Dir_temp+'TableX.npy',Xcoord)
    np.save(Dir_temp+'TableY.npy',Ycoord)
    return Xcoord,Ycoord


def create_coord_pixel_center_raster2(values,nline,ncol,Csize):
    Xcoord = np.zeros((ncol),dtype=np.float)
    Ycoord = np.zeros((nline),dtype=np.float)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    return Xcoord,Ycoord
    

def prepa_desserte_cable(Desserte_shapefile_name,MNT_file_name,Dir_temp,Pond_pente):
    ### Get info on the area
    _,values,_,Extent = raster_get_info(MNT_file_name)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    ### Get id of pixel of road and distance to public network
    Desserte_temp = shapefile_to_np_array(Desserte_shapefile_name,Extent,Csize,"CL_SVAC","CL_SVAC",'ASC')
    # Public network
    Res_pub = (Desserte_temp==3)*1
    # Forest road
    Route = (Desserte_temp==2)*1
    ID_RF = -9999*np.ones((nrows,ncols),dtype=np.int)
    ID_res_pub = -9999*np.ones((nrows,ncols),dtype=np.int)
    indice_forest_road = 0
    indice_public_road = 0
    pixels = np.argwhere(Desserte_temp>1)
    for pixel in pixels:
        if Res_pub[pixel[0],pixel[1]]==1:
            ID_res_pub[pixel[0],pixel[1]] = indice_public_road
            indice_public_road +=1
        elif Route[pixel[0],pixel[1]]==1:
            ID_RF[pixel[0],pixel[1]] = indice_forest_road
            indice_forest_road +=1
    np.save(Dir_temp+"ID_RF.npy",ID_RF)  
    np.save(Dir_temp+"ID_res_pub.npy",ID_res_pub)
    Dtransp_route, Lien_RF_respub = fc.calcul_distance_de_cout(ID_res_pub,Pond_pente,Route,Csize) 
    ### Get only forest roads
    Dir_temp2 = Dir_temp+"Temp/"
    try:os.mkdir(Dir_temp2)
    except:pass 
    Route_shp = Dir_temp2 + "Route.shp"
    select_in_shapefile(Desserte_shapefile_name,Route_shp,'WHERE CL_SVAC=2')
    ### Calculate azimuth and identify lines extremities
    Points_shp = Dir_temp2 + "Route_points.shp"    
    geoLocations,projection = linestring_to_point(Route_shp,Points_shp)
    # lines extremities
    Fin_ligne = np.int8(shapefile_to_np_array(Points_shp,Extent,Csize,'FIN_LIGNE','FIN_LIGNE','DESC'))
    # Azimuth 
    Az_route_shp = Dir_temp2 + "Az_Route.shp"
    points_to_lineshape(geoLocations,Az_route_shp,projection)
    Az_route = shapefile_to_np_array(Az_route_shp,Extent,Csize,'DIRECTION','DIRECTION','DESC')
    ID_routefor = np.unique(ID_RF)[1:]
    Link_RF_Res_pub = np.zeros((ID_routefor.shape[0],7),dtype=np.int)    
    for ind in ID_routefor:
        Temp = np.argwhere(ID_RF==ind)
        Link_RF_Res_pub[ind,0]=ind
        Link_RF_Res_pub[ind,1]=Temp[0,0]
        Link_RF_Res_pub[ind,2]=Temp[0,1]
        Link_RF_Res_pub[ind,3]=Dtransp_route[Temp[0,0],Temp[0,1]]
        Link_RF_Res_pub[ind,4]=Lien_RF_respub[Temp[0,0],Temp[0,1]]  
        Link_RF_Res_pub[ind,5]=Fin_ligne[Temp[0,0],Temp[0,1]]  
        Link_RF_Res_pub[ind,6]=Az_route[Temp[0,0],Temp[0,1]]
    shutil.rmtree(Dir_temp2)
    np.save(Dir_temp+"Link_RF_Res_pub",Link_RF_Res_pub)
    return Link_RF_Res_pub


def read_raster(file_name):
    source_ds = gdal.Open(file_name)
    source_ds.FlushCache() # Flush 
    Array = source_ds.GetRasterBand(1).ReadAsArray()
    Array[Array==0]=-9999
    return Array


# Create raster of obstacles from directory containing shapefiles 
def prepa_obstacle_cable(Obstacles_directory,file_MNT,Dir_temp):
    ### Creation d'un repertoire temporaire       
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize= values[4]
    MNT = read_raster(file_MNT)
    MNT[MNT==values[5]]=-9999
    Pente = fc.pente(np.float_(MNT),Csize,-9999)     
    if Obstacles_directory!="":
        liste_file = os.listdir(Obstacles_directory)
        liste_obs = [] 
        for files in liste_file:
            if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
        if len(liste_obs)>0:
            Obstacles_cable = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)
    else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)    
    Obstacles_cable[MNT==-9999]=1
    values[5]=-9999
    np.save(Dir_temp+'Obstacles_cables.npy',np.int8(Obstacles_cable))
    gc.collect()  
    return Pente


def prepa_pond_pente_cable(MNT,Csize,Direct,head_text):
    Pente = fc.pente(MNT,Csize,-9999)
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    save_float_ascii(Direct+'/pond_pente.asc',head_text,Pond_pente)
    return Pond_pente
    
# Create a pair matrix
def create_pair_matrice(matrice):
    indices = np.indices(matrice.shape)
    pair_l = np.fmod(indices[0],2)
    pair_c = np.fmod(indices[1],2)
    pair = pair_c + pair_l
    pair = np.equal(pair,1)
    return pair

# Make buffer around a pixel
def buffer_emprise(Csize,ct_Lhor_max):
    temp = int(ct_Lhor_max/Csize)
    Ligne_perpendic = np.zeros((360*(1+2*temp),(1+2*temp)),dtype=np.uint8)
    Ind_mask = np.indices(((1+2*temp),(1+2*temp)),dtype=np.int16)
    center_inv = np.ones(((1+2*temp),(1+2*temp)),dtype=np.int16)
    center_inv[temp,temp]=0
    center = np.equal(center_inv,0)*1
    DX = Ind_mask[1]- temp
    DY = temp - Ind_mask[0]
    Dhor_ok = np.less_equal(Csize*np.sqrt(DX**2+DY**2),ct_Lhor_max)
    dmax1,dmin1,dmax2,dmin2 = direction_to_center(DX,DY,Csize,center_inv,center)
    z3_2 = np.less_equal((dmax2-dmin2),120)*1
    z3_1 = np.less_equal((dmax1-dmin1),120)*1
    Direction_list = range(0,360,1)
    for item in Direction_list:
        Dir_value = item+90
        if Dir_value > 359:Dir_value = item-90
        Mask1 = get_dir_area(Dir_value,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1)
        Dir_value1 = Dir_value+180
        if Dir_value1 > 359:Dir_value1 = Dir_value-180
        Mask2 = get_dir_area(Dir_value1,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1)
        Mask = np.greater((Mask1+Mask2),0)*Dhor_ok*1
        h = item*(1+2*temp)
        b = h+(1+2*temp)
        r = (1+2*temp)
        Ligne_perpendic[h:b,0:r]=Mask
    return Ligne_perpendic


def direction_to_center(DX,DY,Csize,center_inv,center):
    corner=[[0.5,0.5],[0.5,-0.5],[-0.5,0.5],[-0.5,0.5]]
    dmax1 = -400*np.ones_like(DX, dtype = np.int16)
    dmax2 = -400*np.ones_like(DX, dtype = np.int16)
    dmin1 = 400*np.ones_like(DX, dtype = np.int16)
    dmin2 = 400*np.ones_like(DX, dtype = np.int16)
    ind_center = np.nonzero(center==1)
    for item in corner:
        X = DX*Csize+item[1]*Csize
        Y = DY*Csize+item[0]*Csize
        D = np.sqrt(X**2+Y**2)
        Temp = np.equal(X,np.abs(X))*1
        Fact = Temp - np.less(Temp, 1)*1        
        D[ind_center] = Csize
        Angle = np.degrees(np.arccos(Y/D))
        Angle[ind_center]=0
        Temp = Angle*Fact
        del (X,Y,D,Fact,Angle)
        direction = 360*np.less(Temp, 0)+np.less(Temp, 0)*Temp+np.greater_equal(Temp, 0)*Temp
        dmax1=np.maximum(direction,dmax1)
        dmin1=np.minimum(direction,dmin1)
        dmax2=np.maximum(Temp,dmax2)
        dmin2=np.minimum(Temp,dmin2)
        del (Temp,direction)
    dmax1=np.float_(dmax1*center_inv+np.equal(center_inv,0)*9999)
    dmax2=np.float_(dmax2*center_inv+np.equal(center_inv,0)*9999)
    dmin1=np.float_(dmin1*center_inv+np.equal(center_inv,0)*9999)
    dmin2=np.float_(dmin2*center_inv+np.equal(center_inv,0)*9999)
    return dmax1,dmin1,dmax2,dmin2


#Get area corresponding to an azimuth
def get_dir_area(dir_value,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1):
    if dir_value < 90:
        z1 = np.greater_equal(dir_value,dmin2)
        z2 = np.less_equal(dir_value,dmax2)
        zone = np.equal((z1*1+z2*1+z3_2*1),3)*1+center
    elif dir_value > 270:
        new_value = dir_value-360
        z1 = np.greater_equal(new_value,dmin2)
        z2 = np.less_equal(new_value,dmax2)
        zone = np.equal((z1*1+z2*1+z3_2*1),3)*1+center
    else:
        z1 = np.greater_equal(dir_value,dmin1)
        z2 = np.less_equal(dir_value,dmax1)
        zone = np.equal((z1*1+z2*1+z3_1*1),3)*1+center
    return zone


# Create useful buffers
def mask_buffers(test_coordY,test_coordX,ind_buffer_center,Buffer_cote,ncol,nline):
    if test_coordX < ind_buffer_center[1][0]: mask_l,buf_l = 0,ind_buffer_center[1][0] - test_coordX
    else: mask_l,buf_l = test_coordX - Buffer_cote,0
    if test_coordX + Buffer_cote + 1 > ncol: mask_r,buf_r = ncol,ncol-test_coordX+ind_buffer_center[1][0]
    else: mask_r,buf_r = test_coordX + Buffer_cote + 1,ind_buffer_center[1][0] + Buffer_cote + 1
    if test_coordY < ind_buffer_center[0][0]: mask_h,buf_h = 0,ind_buffer_center[0][0] - test_coordY
    else: mask_h,buf_h = test_coordY - Buffer_cote,0
    if test_coordY + Buffer_cote + 1 > nline: mask_b,buf_b = nline,nline - test_coordY + ind_buffer_center[0][0]
    else: mask_b,buf_b = test_coordY+Buffer_cote+1,ind_buffer_center[0][0]+Buffer_cote+1
    return mask_h,mask_b,mask_l,mask_r,buf_h,buf_b,buf_l,buf_r


def directions_a_tester(Dir_route,Dir_list,angle_sup,id_fin_ligne):
    # Pixel tout seul
    Dir_list_bis = list(Dir_list)
    # Pixel de route en fin de troncon
    if id_fin_ligne==1:
        D_plus_a = (Dir_route+angle_sup)%360
        D_moins_a = (Dir_route-angle_sup)%360
        if D_moins_a > D_plus_a:valeur_a_suppr = range(D_moins_a,360,1)+range(0,D_plus_a+1,1)
        else:valeur_a_suppr = range(D_moins_a,D_plus_a+1,1)
        for item in valeur_a_suppr:
            try:Dir_list_bis.remove(item)
            except:continue
    # Pixel de route au milieu d'un troncon
    else:
        D_plus_a = (Dir_route+angle_sup)%360
        D_moins_a = (Dir_route-angle_sup)%360
        if D_moins_a > D_plus_a:valeur_a_suppr = range(D_moins_a,360,1)+range(0,D_plus_a+1,1)
        else:valeur_a_suppr = range(D_moins_a,D_plus_a+1,1)
        D_plus_180_moins_a = (Dir_route+180-angle_sup)%360
        D_plus_180_plus_a = (Dir_route+180+angle_sup)%360
        if D_plus_180_plus_a < D_plus_180_moins_a: valeur_a_suppr = valeur_a_suppr + range(D_plus_180_moins_a,360,1)+range(0,D_plus_180_plus_a+1,1)
        else:valeur_a_suppr = valeur_a_suppr + range(D_plus_180_moins_a,D_plus_180_plus_a+1,1)
        for item in valeur_a_suppr:
            try:Dir_list_bis.remove(item)
            except:continue    
    return Dir_list_bis


def get_cable_configs(slope_Wliner_up,slope_Wliner_down,slope_grav,Skid_direction):
    #Get folder
    _,Rspace,_,_,_,_,_,_,_,_,_,_,_ = Sylvaccess_pluginDialog.get_spatial(0,1,0,0,0,0,0,0,0,0,0,0,0)
    dirs = [d for d in os.listdir(Rspace) if os.path.isdir(os.path.join(Rspace, d))]
    list_dir = []
    
    for dire in dirs:
        if dire[:5]=='Cable':
            list_dir.append(dire)
            
    optnum = len(list_dir)+1
    Rspace_c=Rspace+'Cable_'+str(optnum)        
    filename = Rspace_c+"/"
    Cable_type,_,_,_,_ = Sylvaccess_pluginDialog.get_type_cable(1,0,0,0,0)
    filename += str(Cable_type)
    Carriage_type,_,_,_,_ = Sylvaccess_pluginDialog.get_type_chariot(1,0,0,0,0)
    filename += "_"+str(Carriage_type)
    
    if Skid_direction ==0:
        filename += "_amont&aval"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1        
    
    elif Skid_direction ==1:
        filename += "_amont"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = 0
        slope_min_down = 0
    
    else:
        filename += "_aval"
        slope_min_up = 0
        slope_max_up = 0
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1 
    
    if Cable_type == "Câble long":
        if Skid_direction ==0:
            filename += "_amont&aval"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01) 
   
        elif Skid_direction ==1:
            filename += "_amont"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0
 
        else:
            filename += "_aval"
            slope_min_up = 0
            slope_max_up = 0
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01)             
    else: 
        
        if Skid_direction ==0:
            filename+= "_amont_aval"
            slope_min_up = -1.4
            slope_max_up = 0.1
            slope_min_down = -0.1
            slope_max_down = 1.4
        
        elif Skid_direction ==1:
            filename += "_amont"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0 
        
        else:
            filename += "_aval"
            slope_min_up = 0
            slope_max_up = 0
            slope_min_down = -0.1
            slope_max_down = 1.4             
    
    filename+=".txt"
    
    return Rspace_c,filename,slope_min_up,slope_max_up,slope_min_down,slope_max_down







