# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Sylvaccess_plugin_dialog
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Importation des bibliothèques 
from PyQt5 import QtWidgets, uic
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtCore import QCoreApplication
import os, shutil, gc
import numpy as np
from .resources import *
from .console import console_info, console_warning
from .skidder import Skidder, create_new_road_network, make_dif_files
from .forwarder import process_forwarder
from .cable import Cable, line_selection
from .gis import check_field, check_field_EXIST, crop_to_main_dtm_size
from .general import  raster_get_info

Sylvaccess_UI = None


# Chargement de l'interface utilisateur depuis le fichier .ui
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'sylvaccess_plugin_dialog_base.ui'))

class Sylvaccess_pluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self,iface=None, parent=None):
        super(Sylvaccess_pluginDialog, self).__init__(parent)
        self.setupUi(self)
        self.setWindowTitle("Sylvaccess")
#self.setWindowIcon(QIcon(':/plugins/sylvaccess_plugin/icon.png'))
        self.iface = iface
        global Sylvaccess_UI
        Sylvaccess_UI = self
        Sylvaccess_UI.general.setEnabled(True)
        Sylvaccess_UI.donnees_spatiale.setEnabled(True)


##################################################################
#.______     ______    __    __  .__________.  ______   .__   __.# 
#|   _  \   /  __  \  |  |  |  | |          | /  __  \  |  \ |  |# 
#|  |_)  | |  |  |  | |  |  |  | `---|  |---`|  |  |  | |   \|  |# 
#|   _  <  |  |  |  | |  |  |  |     |  |    |  |  |  | |  . `  |# 
#|  |_)  | |  `--'  | |  `--'  |     |  |    |  `--'  | |  |\   |# 
#|______/   \______/   \______/      |__|     \______/  |__| \__|# 
##################################################################        
        # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
        for i in range(1, 14):
            button = getattr(self, f"pushButton_{i}")
            button.clicked.connect(lambda _, num=i: self.open_folder(num))

        # Connexion des signaux des checkbox
        for i in range(1, 5):
            checkbox = getattr(self, f"checkBox_{i}")
            checkbox.stateChanged.connect(lambda _, num=i: self.checkbox_state_changed(num))


        for i in range(101,109):
            checkbox = getattr(self, f"checkBox_{i}")
            checkbox.stateChanged.connect(lambda _, num=i: self.checkbox_state_changed_opti(num))

        # Connexion des signaux des boutons OK et Annuler()
        self.button_box.accepted.connect(self.launch)
        self.button_box.rejected.connect(self.abort)
        self.spinBox_40.valueChanged.connect(self.spinBox_40_changed)
        self.comboBox_1.currentIndexChanged.connect(self.comboBox_1_changed)
        self.comboBox_3.currentIndexChanged.connect(self.comboBox_3_changed)

    # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
    def open_folder(self, button_number):
        # Définit les filtres génériques pour Shapefiles et fichiers raster
        shapefile_filter = "Shapefiles (*.shp );;Geopackage(*.gpkg);;All files (*)"
        raster_filter = "Raster files (*.tif *.asc *.txt);;All files (*)"

        # Définit les options de la boîte de dialogue
        options = QFileDialog.Options()
        #options |= QFileDialog.DontUseNativeDialog

        # Affiche le dialogue de sélection de fichier avec les filtres appropriés
        if button_number in [4, 5, 6]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, QCoreApplication.translate("MainWindow","Select a file"), filter=shapefile_filter, options=options)
        elif button_number in [3, 11, 12, 13]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, QCoreApplication.translate("MainWindow","Select a file"), filter=raster_filter, options=options)
        elif button_number in [1, 2, 7, 8, 9, 10]:  # Pour le bouton qui doit ouvrir un dossier
            selected_file = QFileDialog.getExistingDirectory(
                None, QCoreApplication.translate("MainWindow","Select a folder"), options=options)

        if selected_file:
            # Mise à jour du champ de texte approprié
            if button_number == 2:
                text_edit = getattr(self, f"lineEdit_2")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_17")
                text_edit.setText(selected_file)
            elif button_number == 4 :
                text_edit = getattr(self, f"lineEdit_4")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_14")
                text_edit.setText(selected_file)
            elif button_number == 13:
                text_edit = getattr(self, f"lineEdit_13")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_15")
                text_edit.setText(selected_file)
            elif button_number == 12 :
                text_edit = getattr(self, f"lineEdit_12")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_16")
                text_edit.setText(selected_file)
            else:
                text_edit = getattr(self, f"lineEdit_{button_number}")
                text_edit.setText(selected_file)

    # Fonction appelée lorsqu'une checkbox est cochée ou décochée
    def checkbox_state_changed(self, checkbox_number):
        # Récupère l'état de la checkbox
        ##for testing
        self.lineEdit_1.setText("C:/Users/yoann/Downloads/meisenthal2")
        self.lineEdit_2.setText("C:/Users/yoann/Downloads/meisenthal2/results")
        self.lineEdit_3.setText("C:/Users/yoann/Downloads/meisenthal2/mnt_rgealti_5m.tif")
        self.lineEdit_4.setText("C:/Users/yoann/Downloads/meisenthal2/frt.shp")
        self.lineEdit_5.setText("C:/Users/yoann/Downloads/meisenthal2/desserte.shp")
        self.lineEdit_6.setText("C:/Users/yoann/Downloads/meisenthal2/piste.shp")
        self.lineEdit_11.setText("C:/Users/yoann/Downloads/meisenthal2/plugin_arbremoy.tif")
        ##
        checkbox = getattr(self, f"checkBox_{checkbox_number}")
        checkbox_state = checkbox.isChecked()

        if checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(True)
                # désactive les lineEdit pour éviter les erreurs
                self.lineEdit_14.setEnabled(False)
                self.lineEdit_15.setEnabled(False)
                self.lineEdit_16.setEnabled(False)
                self.lineEdit_17.setEnabled(False)
                self.spinBox_49.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(True)
            if checkbox_number == 3:
                self.Forwarder.setEnabled(True)
            if checkbox_number == 4:
                self.skidder.setEnabled(True)
        elif not checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(False)
            if checkbox_number == 3:
                self.Forwarder.setEnabled(False)
 
            if checkbox_number == 4:
                self.skidder.setEnabled(False)


    def spinBox_40_changed(self):
        value = self.spinBox_40.value()
        self.spinBox_49.setValue(value)
        ##test
        console_info(f"spinBox_40_changed: value={value}")


    def comboBox_1_changed(self):
        value = self.comboBox_1.currentText()
        if value == QCoreApplication.translate("MainWindow", "Cable crane mounted on agricultural tractor"):
            self.spinBox_14.setValue(2)
            self.doubleSpinBox_2.setValue(8.5)
            self.spinBox_16.setValue(500)
            self.spinBox_17.setValue(125)
            self.doubleSpinBox_3.setValue(16.0)
            self.doubleSpinBox_4.setValue(1.4)
            self.spinBox_26.setValue(25000)
            self.spinBox_40.setValue(35)
        elif value == QCoreApplication.translate("MainWindow", "Cable crane mounted on trailer"):
            self.spinBox_14.setValue(3)
            self.doubleSpinBox_2.setValue(10.5)
            self.spinBox_16.setValue(780)
            self.spinBox_17.setValue(150)
            self.doubleSpinBox_3.setValue(18.0)
            self.doubleSpinBox_4.setValue(1.9)
            self.spinBox_26.setValue(35000)
            self.spinBox_40.setValue(35)
        elif value == QCoreApplication.translate("MainWindow", "Cable crane mounted on truck"):
            self.spinBox_14.setValue(3)
            self.doubleSpinBox_2.setValue(14)
            self.spinBox_16.setValue(1200)
            self.spinBox_17.setValue(200)
            self.doubleSpinBox_3.setValue(22.0)
            self.doubleSpinBox_4.setValue(2.6)
            self.spinBox_26.setValue(48000)
            self.spinBox_40.setValue(40)
        elif value == QCoreApplication.translate("MainWindow", "Long cable"):
            self.spinBox_14.setValue(3)
            self.doubleSpinBox_2.setValue(8.0)
            self.spinBox_16.setValue(1500)
            self.spinBox_17.setValue(300)
            self.doubleSpinBox_3.setValue(22.0)
            self.doubleSpinBox_4.setValue(2.6)
            self.spinBox_26.setValue(48000)
            self.spinBox_40.setValue(40)


    def comboBox_3_changed(self):
        value = self.comboBox_3.currentText()
        if value == QCoreApplication.translate("MainWindow", "Classical carriage"):
            self.spinBox_22.setValue(500)
            self.spinBox_23.setValue(15)
            self.spinBox_24.setValue(15)
            self.spinBox_25.setValue(100)
            self.spinBox_39.setValue(2500)
            self.spinBox_23.setEnabled(True)
            self.spinBox_24.setEnabled(False)
            self.spinBox_25.setEnabled(False)
        elif value == QCoreApplication.translate("MainWindow", "self-motorized carriage"):
            self.spinBox_22.setValue(1200)
            self.spinBox_23.setValue(15)
            self.spinBox_24.setValue(15)
            self.spinBox_25.setValue(100)
            self.spinBox_39.setValue(1800)
            self.spinBox_23.setEnabled(False)
            self.spinBox_24.setEnabled(True)
            self.spinBox_25.setEnabled(True)

  
    def checkbox_state_changed_opti(self, checkbox_number):
        # Récupère l'état de la checkbox
        checkbox = getattr(self, f"checkBox_{checkbox_number}")
        checkbox_state = checkbox.isChecked()

        if checkbox_state:
            if checkbox_number == 101:
                self.spinBox_101.setMinimum(1)
            if checkbox_number == 102:
                self.spinBox_102.setMinimum(1)
                self.spinBox_102.setValue(2)
            if checkbox_number == 103:
                self.spinBox_103.setMinimum(1)
            if checkbox_number == 104:
                self.spinBox_104.setMinimum(1)
            if checkbox_number == 105:
                self.spinBox_105.setMinimum(1)
            if checkbox_number == 106:
                self.spinBox_106.setMinimum(1)
                self.spinBox_106.setValue(4)
            if checkbox_number == 107:
                self.spinBox_107.setMinimum(1)
                self.spinBox_107.setValue(3)
            if checkbox_number == 108:
                self.spinBox_108.setMinimum(1)
        elif not checkbox_state:
            if checkbox_number == 101:
                self.spinBox_101.setMinimum(0)
                self.spinBox_101.setMaximum(0)
            if checkbox_number == 102:
                self.spinBox_102.setMinimum(0)
                self.spinBox_102.setMaximum(0)
            if checkbox_number == 103:
                self.spinBox_103.setMinimum(0)
                self.spinBox_103.setMaximum(0)
            if checkbox_number == 104:
                self.spinBox_104.setMinimum(0)
                self.spinBox_104.setMaximum(0)
            if checkbox_number == 105:
                self.spinBox_105.setMinimum(0)
                self.spinBox_105.setMaximum(0)
            if checkbox_number == 106:
                self.spinBox_106.setMinimum(0)  
                self.spinBox_106.setMaximum(0)
            if checkbox_number == 107:
                self.spinBox_107.setMinimum(0)
                self.spinBox_107.setMaximum(0)
            if checkbox_number == 108:
                self.spinBox_108.setMinimum(0)
                self.spinBox_108.setMaximum(0)


    def abort(self):
        self.close()


###############################################################################################
# __          ___      .__   __.   ______  _______ .___  ___.  _______ .__   __. .___________.#
#|  |        /   \     |  \ |  |  /      ||   ____||   \/   | |   ____||  \ |  | |           |#
#|  |       /  ^  \    |   \|  | |  ,----'|  |__   |  \  /  | |  |__   |   \|  | `---|  |----`#
#|  |      /  /_\  \   |  . `  | |  |     |   __|  |  |\/|  | |   __|  |  . `  |     |  |     #
#|  `----./  _____  \  |  |\   | |  `----.|  |____ |  |  |  | |  |____ |  |\   |     |  |     #
#|_______/__/     \__\ |__| \__|  \______||_______||__|  |__| |_______||__| \__|     |__|     #
###############################################################################################  


    def launch(self):
        
        Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, dep_cable,  Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder,por_obstacle, cab_obstacle, file_Vol_ha, file_Vol_AM, file_Htree = Sylvaccess_UI.get_spatial()
        test_Skidder,test_Forwarder,test_Cable,test_cable_optimise,pente = Sylvaccess_UI.get_general()
        pente_max_s, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max, limite, bornes_s = Sylvaccess_UI.get_skidder()
        Forw_angle_incl, Forw_angle_up, Forw_angle_down, Forw_portee, Forw_Dmax_out_for, Forw_Lmax, Forw_Debclass = Sylvaccess_UI.get_Forwarder()
        prelevement,recalculer,_,foret2,VBP2,VAM2,pechage2 = Sylvaccess_UI.get_opti_cable()
        surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_UI.get_crit_opti()
        Cable_type,sup_max,Htower,Lmax,Lmin=Sylvaccess_UI.get_type_cable()
        Carriage_type,Pchar,slope_grav,slope_Wliner_up,slope_Wliner_down = Sylvaccess_UI.get_type_chariot()
        d,masse_li,rupt_res,E = Sylvaccess_UI.get_proprietes_cable()
        Hintsup,Hend,Hline_min,Hline_max,Lhor_max,Load_max,safe_fact = Sylvaccess_UI.get_param_modelisation()
        test_cable_optimise,precision = Sylvaccess_UI.get_options()

        w_list = [surface, nbr_sup_int, sens_debardage, longueure_ligne, vol_ligne, indice_prelev, VAM3, dist_chariot]
        lim_list = [surface_poids, nbr_sup_int_poids, sens_debardage_poids, longueure_ligne_poids, vol_ligne_poids, indice_prelev_poids, VAM_poids, dist_chariot_poids] 

        try:os.mkdir(Rspace)
        except:pass
        for i in range (1,5):   
            if not getattr(self, f"lineEdit_{i}").text():
                txt = QCoreApplication.translate("MainWindow", "Please fill in all required fields")
                console_warning(txt)
                Sylvaccess_UI.abort()
                return
        Sylvaccess_UI.check_files()
        Sylvaccess_UI.write_file()
        if (test_Skidder + test_Forwarder) > 0:
            # Check if part of the service corresponds to a project
            testExist = check_field_EXIST(file_shp_Desserte,"EXIST") 
            
            ###################################################################################################################
            ### If no service project
            ###################################################################################################################
            if not testExist: 
                if test_Skidder:  
                    Skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder, file_Vol_ha,
                                pente, pente_max_s, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max,
                                limite, bornes_s)                    
                    gc.collect()
                
                if test_Forwarder:
                    process_forwarder(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte_Exist,por_obstacle,file_Vol_ha,pente,
                                        Forw_angle_incl,Forw_angle_up,Forw_angle_down,Forw_Lmax,Forw_Dmax_out_for,Forw_portee,Forw_Debclass)
                    gc.collect()
            
            ###################################################################################################################
            ### If service project exists
            ###################################################################################################################
            else:                        
                file_shp_Desserte_Exist = create_new_road_network(file_shp_Desserte,Wspace)
                
                # First simulation without project
                console_info(QCoreApplication.translate("MainWindow","\nSIMULATION FROM EXISTING SERVICE"))
                if test_Skidder:   
                    try:os.mkdir(Rspace+"Skidder/")
                    except:pass
                    Skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte_Exist, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder, file_Vol_ha,
                                pente, pente_max_s, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max,
                                limite, bornes_s )                    
                    gc.collect()
                    projdir = Rspace+"Skidder/1_Existant/"
                    os.rename(Rspace+"Skidder/Skidder/",projdir)
                
                if test_Forwarder:
                    Rspace_f = Rspace+"Forwarder/"
                    old=Rspace+"Forwarder/Forwarder/"
                    new= Rspace+"Forwarder/1_Existant/"  
                    try:os.mkdir(Rspace_f)
                    except:pass
                    process_forwarder(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte_Exist,por_obstacle,file_Vol_ha,pente,
                                        Forw_angle_incl,Forw_angle_up,Forw_angle_down,Forw_Lmax,Forw_Dmax_out_for,Forw_portee,Forw_Debclass)
                    gc.collect()
                    os.rename(old,new)  
                    
                os.remove(Wspace+"Temp/Link_track.npy")
                os.remove(Wspace+"Temp/Link_RF.npy")
                os.remove(Wspace+"Temp/Tab_res_pub.npy")
                os.remove(Wspace+"Temp/Road_for.npy")
                os.remove(Wspace+"Temp/Track.npy")
                
                # Second simulation with project
                console_info(QCoreApplication.translate("MainWindow","\nSIMULATION INCLUDING THE SERVICE PROJECT"))
                if test_Skidder: 
                    Skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder, file_Vol_ha,
                                pente, pente_max_s, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max,
                                limite, bornes_s)                    
                    gc.collect()
                    projdir = Rspace+"Skidder/2_Project/"
                    os.rename(Rspace+"Skidder/Skidder/",projdir)
                    make_dif_files(Rspace,0)     
                    
                if test_Forwarder:
                    Rspace_f = Rspace+"Forwarder/"
                    old=Rspace+"Forwarder/Forwarder/"
                    new= Rspace+"Forwarder/2_Project/"                                
                    process_forwarder(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,por_obstacle,file_Vol_ha,pente,
                                        Forw_angle_incl,Forw_angle_up,Forw_angle_down,Forw_Lmax,Forw_Dmax_out_for,Forw_portee,Forw_Debclass)
                    gc.collect()         
                    os.rename(old,new)   
                    make_dif_files(Rspace,1)                       
        
        if test_Cable:
            Cable(Wspace,Rspace,file_MNT,file_shp_Foret,dep_cable,cab_obstacle,file_Htree,file_Vol_AM,file_Vol_ha,pente,
                    Cable_type,sup_max,Htower,Lmax,Lmin,Carriage_type,Pchar,slope_grav,slope_Wliner_up,slope_Wliner_down,d,masse_li,
                    rupt_res,E,Hintsup,Hend,Hline_min,Hline_max,Lhor_max,Load_max,safe_fact,test_cable_optimise,precision,prelevement,
                    lim_list,w_list)
            test_cable_optimise=0
            gc.collect()
        if test_cable_optimise:
            line_selection(Wspace,w_list,lim_list,recalculer,foret2,VBP2,VAM2,pechage2,prelevement,pente) 
            gc.collect()  
        try:
            shutil.rmtree(Wspace+"Temp")
        except:
            pass
        Sylvaccess_UI.close()


    def check_files(self):
        verif = True
        test_Skidder,test_Forwarder,test_Cable,test_cable_optim,_ = Sylvaccess_UI.get_general()
        _,_,file_MNT, file_shp_Foret, file_shp_Desserte, dep_cable,_,_,_,_, file_vol_AM, file_HA, file_vol_BP = Sylvaccess_UI.get_spatial()
        _,new_calc,_,_,_,_,_ = Sylvaccess_UI.get_opti_cable()

        msg = QCoreApplication.translate("MainWindow", "\nTHE FOLLOWING PROBLEMS HAVE BEEN IDENTIFIED WITH REGARD TO SPATIAL ENTRY: \n")
        # Check MNT
        if test_Skidder + test_Forwarder + test_Cable > 0:
            try:
                _, values, _, Extent = raster_get_info(file_MNT)
                if values[5] is None:
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Raster DTM: No value of NoData defined\n")
            except:
                msg += QCoreApplication.translate("MainWindow", " -   Raster DTM:  Path is missing or incorrect. This raster is required to run Sylvaccess\n")
                verif = False

        # Check file_shp_Desserte
        if test_Skidder + test_Forwarder > 0:
            try:
                if not check_field(file_shp_Desserte, "CL_SVAC"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Service layer: The 'CL_SVAC' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Service layer: Path is missing or incorrect. This layer is required for skidder and forwarder modules\n")

        # Check dep_cable
            try:
                if not check_field(dep_cable, "CABLE"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Service layer: The 'CABLE' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Potential cable departures layer: The access path is missing or incorrect. This layer is mandatory for the cable module\n")

        # Check file_shp_Foret
        if test_Skidder + test_Forwarder + test_Cable > 0:
            try:
                if not check_field(file_shp_Foret, "FORET"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Forest layer: The 'FOREST' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer: Path is missing or incorrect. This layer is required to run Sylvaccess\n")
            if not file_shp_Foret.endswith(".shp") or not file_shp_Foret.endswith(".gpkg"):
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer: The file must be a shapefile or a geopackage !NOT ALWAYS TRUE,KINDA BUGGED\n")

        # Check file_shp_Foret for cable optim
        if not test_Cable and test_cable_optim and new_calc and file_shp_Foret != "":
            try:
                if not check_field(file_shp_Foret, "FORET"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Forest layer (optimization cable tab): The 'FOREST' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer (optimization cable tab): The path is missing or incorrect. \n")
            if not file_shp_Foret.endswith(".shp") or not file_shp_Foret.endswith(".gpkg"):
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer (optimization cable tab): The file must be a shapefile or a geopackage\n")

        # Check file_vol_BP, file_vol_AM, file_HA
        name = [QCoreApplication.translate("MainWindow", "Raster Volume/ha"), QCoreApplication.translate("MainWindow", "Raster medium tree volume"), QCoreApplication.translate("MainWindow", "Raster tree height")]
        for i, f in enumerate([file_vol_BP, file_vol_AM, file_HA]):
            if f != "":
                try:
                    _, values2, _, Extent2 = raster_get_info(f)
                    if values2[5] is None:
                        verif = False
                        msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": No value of NoData defined\n")
                    if not values[4] == values2[4]:
                        verif = False
                        msg += " -   " + name[i] + QCoreApplication.translate("MainWindow", ": Raster cell size should be the same as DTM\n")
                    if not np.all(Extent == Extent2):
                        msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The extent of the raster must be the same as that of the DTM\n")
                        try : 
                            crop_to_main_dtm_size(f, file_MNT)
                            msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The raster was oversized but it was cropped to the right size \n")
                        except:
                            verif = False
                            msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The raster size is undersized compared to the main DTM\n")
                        
                except:
                    verif = False
                    msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The access path is incorrect\n")
                if not f.endswith(".tif") or not f.endswith(".asc") or not f.endswith(".txt"):
                    verif = False
                    msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The file must be a tif, asc or txt file\n")

        if not verif:
            msg += QCoreApplication.translate("MainWindow", "\nPLEASE CORRECT BEFORE RELAUNCHING SYLVACCESS\n")
            console_warning(msg)
            Sylvaccess_UI.abort()
        return verif


    def write_file(self):
        # Récupération des valeurs des variables
        Wspace, Rspace, mnt, foret, desserte, dep_cable, ski_no_t_d, ski_no_t, por_obstacle, cab_obstacle, HA, VAM, VBP = Sylvaccess_UI.get_spatial()
        spatial_data = [Wspace, Rspace, mnt, foret, desserte, dep_cable, ski_no_t_d, ski_no_t, por_obstacle, cab_obstacle, HA, VAM, VBP]

        ski, por, cab, opti, pente = Sylvaccess_UI.get_general()
        pente = str(pente) + " %"
        general_data = [ski, por, cab, opti, pente]

        pente_max, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max, limite, bornes = Sylvaccess_UI.get_skidder()
        if limite == 1:
            limite = QCoreApplication.translate("MainWindow","1-Limit soil damages: force the skidder to proceed from the forest road network")
        else:
            limite = QCoreApplication.translate("MainWindow","2-Limit winching operations: force the skidder to get as close as possible from logs")
        skidder_data = [pente_max, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max, limite, bornes]
        for i in (0, 4, 5):
            skidder_data[i] = str(skidder_data[i]) + " %"
        for i in (1, 2, 3):
            skidder_data[i] = str(skidder_data[i]) + " m"

        pente_max2, pente_max_remonant, pente_max_descendant, distance_max_pente_sup, distance_max_hors_frt, taille_grue, bornes2 = Sylvaccess_UI.get_Forwarder()
        forwarder_data = [pente_max2, pente_max_remonant, pente_max_descendant, distance_max_pente_sup, distance_max_hors_frt, taille_grue, bornes2]
        for i in (0, 1, 2):
            forwarder_data[i] = str(forwarder_data[i]) + " %"
        for i in (3, 4, 5):
            forwarder_data[i] = str(forwarder_data[i]) + " m"

        type_machine, supports_inter, hauteur, longueur_max, longueur_min = Sylvaccess_UI.get_type_cable()
        type_cable_data = [type_machine, supports_inter, hauteur, longueur_max, longueur_min]
        for i in (2, 3, 4): 
            type_cable_data[i] = str(type_cable_data[i]) + " m"

        type_chariot, masse, pente_min, pente_max_amont, pente_max_aval = Sylvaccess_UI.get_type_chariot()
        type_chariot_data = [type_chariot, masse, pente_min, pente_max_amont, pente_max_aval]
        masse = str(masse) + " kg"
        for i in (2, 3, 4):
            type_chariot_data[i] = str(type_chariot_data[i]) + " %"

        diamètre, masse_li, tension_rupt, elasticité = Sylvaccess_UI.get_proprietes_cable()
        propriete_cable_data = [diamètre, masse_li, tension_rupt, elasticité]
        diamètre = str(diamètre) + " mm"
        masse_li = str(masse_li) + " kg/mm"
        tension_rupt = str(tension_rupt) + " N"
        elasticité = str(elasticité) + " N/mm²"

        hauteur_sup, hauteur_mat, hauteur_min_cable, hauteur_max_cable, pechage, masse_max, securite = Sylvaccess_UI.get_param_modelisation()
        param_modelisation_data = [hauteur_sup, hauteur_mat, hauteur_min_cable, hauteur_max_cable, pechage, masse_max, securite]
        for i in (0, 1, 2, 3, 4):
            param_modelisation_data[i] = str(param_modelisation_data[i]) + " m"
        masse_max = str(masse_max) + " kg"

        opti2, precision = Sylvaccess_UI.get_options()
        options_data = [opti2, precision]

        prelevement, recalculer, Rspace2, foret2, VBP2, VAM2, pechage2 = Sylvaccess_UI.get_opti_cable()
        opti_cable_data = [prelevement, recalculer, Rspace2, foret2, VBP2, VAM2, pechage2]

        surface, surface_poids, nbr_sup_int, nbr_sup_int_poids, sens_debardage, sens_debardage_poids, longueur_ligne, longueur_ligne_poids, vol_ligne, vol_ligne_poids, indice_prelev, indice_prelev_poids, VAM3, VAM_poids, dist_chariot, dist_chariot_poids = Sylvaccess_UI.get_crit_opti()
        crit_opti_data = [surface, surface_poids, nbr_sup_int, nbr_sup_int_poids, sens_debardage, sens_debardage_poids, longueur_ligne, longueur_ligne_poids, vol_ligne, vol_ligne_poids, indice_prelev, indice_prelev_poids, VAM3, VAM_poids, dist_chariot, dist_chariot_poids]

        # Wrap all strings with tr() function
        file_name = Rspace + "_all_param.txt"
        with open(file_name, 'w') as fichier:
            
            fichier.write(QCoreApplication.translate("MainWindow","General data :\n\n"))
            zip1 = [QCoreApplication.translate("MainWindow", "skidder Analysis"), QCoreApplication.translate("MainWindow", "Forwarder Analysis"), QCoreApplication.translate("MainWindow", "Cable Yarding Analysis"), QCoreApplication.translate("MainWindow", "Optimize Cable Line"), QCoreApplication.translate("MainWindow", "Maximum slope for manual harvesting")]
            for var_name, var_value in zip(zip1, general_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nSpatial data :\n\n"))
            zip1 = [QCoreApplication.translate("MainWindow", "Workspace"), QCoreApplication.translate("MainWindow", "Result Space"), QCoreApplication.translate("MainWindow", "DTM file"), QCoreApplication.translate("MainWindow", "Forest area file"), QCoreApplication.translate("MainWindow", "Forest road network"), QCoreApplication.translate("MainWindow", "Cable Crane start point"), QCoreApplication.translate("MainWindow", "Skidder, area where winching and skidding are forbidden"), QCoreApplication.translate("MainWindow", "Skidder, area where skidding is forbidden"), QCoreApplication.translate("MainWindow", "Forwarder, obstacles for the free movement of the machine"), QCoreApplication.translate("MainWindow", "Cable yarding, obstacles for the set-up of cable line"), QCoreApplication.translate("MainWindow", "Height of the trees"), QCoreApplication.translate("MainWindow", "Average tree volume"), QCoreApplication.translate("MainWindow", "Volume per hectare")]
            for var_name, var_value in zip(zip1, spatial_data):
                if var_value == "":
                    print = QCoreApplication.translate("MainWindow", "No data")
                    fichier.write(f"{var_name}: {print} \n")
                else:
                    fichier.write(f"{var_name}: {var_value}  \n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nParameters for skidder processing:\n\n"))
            zip1 =  [QCoreApplication.translate("MainWindow", "Maximal slope outside forest network for the skidder"), QCoreApplication.translate("MainWindow", "Maximum uphill winching distance"), QCoreApplication.translate("MainWindow", "Maximum downhill winching distance"), QCoreApplication.translate("MainWindow", "Maximal distance outside forest"), QCoreApplication.translate("MainWindow", "Slope from which uphill winching reaches maximum distance"), QCoreApplication.translate("MainWindow", "Slope from which downhill winching reaches maximum distance"), QCoreApplication.translate("MainWindow", "Simulation option"), QCoreApplication.translate("MainWindow", "Classes of skidding distance (Total distance in meters)")]
            for var_name, var_value in zip(zip1, skidder_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nParameters for forwarder processing :\n\n"))
            zip1 =  [QCoreApplication.translate("MainWindow", "Maximum lateral inclination of the machine"), QCoreApplication.translate("MainWindow", "Maximum slope for a uphill yarding"), QCoreApplication.translate("MainWindow", "Maximum slope for a downhill yarding"), QCoreApplication.translate("MainWindow", "Maximum yarding distance when slope is greater than the maximum lateral inclination of the machine"), QCoreApplication.translate("MainWindow", "Maximum distance outside forest"), QCoreApplication.translate("MainWindow", "Length of the hoist"), QCoreApplication.translate("MainWindow", "Classes of skidding distance (Total distance in meters)")]
            for var_name, var_value in zip(zip1, forwarder_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nCable machine properties :\n\n"))
            zip1 =  [QCoreApplication.translate("MainWindow", "Type of material"), QCoreApplication.translate("MainWindow", "Maximum number of intermediate supports"), QCoreApplication.translate("MainWindow", "Crane height"), QCoreApplication.translate("MainWindow", "Maximum skyline length"), QCoreApplication.translate("MainWindow", "Minimum skyline length")]
            for var_name, var_value in zip(zip1, type_cable_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nCarriage properties :\n\n"))
            zip1 =  [QCoreApplication.translate("MainWindow", "Carriage type"), QCoreApplication.translate("MainWindow", "Empty weigth"), QCoreApplication.translate("MainWindow", "Minimum slope for a gravity descent of the carriage"), QCoreApplication.translate("MainWindow", "Maximum slope of the skyline for an uphill yarding"), QCoreApplication.translate("MainWindow", "Maximum slope of the skyline for an downhill yarding")]
            for var_name, var_value in zip(zip1, type_chariot_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nSkyline porperties :\n\n"))
            zip1 = [QCoreApplication.translate("MainWindow", "Diameter"), QCoreApplication.translate("MainWindow", "Skyline self-weight"), QCoreApplication.translate("MainWindow", "Breakdown tensile force"), QCoreApplication.translate("MainWindow", "Young Modulus ( Elasticity)")]
            for var_name, var_value in zip(zip1, propriete_cable_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            zip1 =  [QCoreApplication.translate("MainWindow", "Modeling parameters"), QCoreApplication.translate("MainWindow", "Options"), QCoreApplication.translate("MainWindow", "Cable yarding - Optimization of cable parameters"), QCoreApplication.translate("MainWindow", "Criteria used for optimization")]
            fichier.write(QCoreApplication.translate("MainWindow","\nModeling parameters :\n\n"))
            for var_name, var_value in zip(zip1, param_modelisation_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nOptions :\n\n"))
            zip1 = [QCoreApplication.translate("MainWindow", "Optimize skyline height at intermediate supports and tailspar"), QCoreApplication.translate("MainWindow", "Precision of the modeling")]
            for var_name, var_value in zip(zip1, options_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nCable yarding - Optimization of cable parameters :\n\n"))
            zip1 = [QCoreApplication.translate("MainWindow", "Percentage of volume per hectare taken off"), QCoreApplication.translate("MainWindow", "Re-compute"), QCoreApplication.translate("MainWindow", "Result folder"), QCoreApplication.translate("MainWindow", "Forest file"), QCoreApplication.translate("MainWindow", "Volume per hectare"), QCoreApplication.translate("MainWindow", "Average tree volume"), QCoreApplication.translate("MainWindow", "Lateral yarding distance")]
            for var_name, var_value in zip(zip1, opti_cable_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.write("\n______________________________________________________________________________________")
            fichier.write(QCoreApplication.translate("MainWindow","\nCriteria used for optimization :\n\n"))
            zip1 = [QCoreApplication.translate("MainWindow", "Forest area impacted"), QCoreApplication.translate("MainWindow", "-->Forest area impacted weight"), QCoreApplication.translate("MainWindow", "Number of intermediate supports"), QCoreApplication.translate("MainWindow", "-->Number of intermediate supports weight"), QCoreApplication.translate("MainWindow", "Prefered yarding direction"), QCoreApplication.translate("MainWindow", "-->Prefered yarding direction weight"), QCoreApplication.translate("MainWindow", "Line length"), QCoreApplication.translate("MainWindow", "-->Line length weight"), QCoreApplication.translate("MainWindow", "Total volume per line"), QCoreApplication.translate("MainWindow", "-->Total volume per line weight"), QCoreApplication.translate("MainWindow", "Volume per meter of line"), QCoreApplication.translate("MainWindow", "-->Volume per meter of line weight"), QCoreApplication.translate("MainWindow", "Average tree volume"), QCoreApplication.translate("MainWindow", "-->Average tree volume weight"), QCoreApplication.translate("MainWindow", "Carriage average distance"), QCoreApplication.translate("MainWindow", "-->Carriage average distance weight")]
            for var_name, var_value in zip(zip1, crit_opti_data):
                fichier.write(f"{var_name}: {var_value}\n")

            fichier.close()



#####################################################################################################################
#  _______  _______ .___________.   ____    ____  ___      .______    __       ___      .______    __       _______ #
# /  _____||   ____||           |   \   \  /   / /   \     |   _  \  |  |     /   \     |   _  \  |  |     |   ____|#
#|  |  __  |  |__   `---|  |----`    \   \/   / /  ^  \    |  |_)  | |  |    /  ^  \    |  |_)  | |  |     |  |__   #
#|  | |_ | |   __|      |  |          \      / /  /_\  \   |      /  |  |   /  /_\  \   |   _  <  |  |     |   __|  #
#|  |__| | |  |____     |  |           \    / /  _____  \  |  |\  \-.|  |  /  _____  \  |  |_)  | |  `----.|  |____ #
# \______| |_______|    |__|            \__/ /__/     \__\ | _| `.__||__| /__/     \__\ |______/  |_______||_______|#
#####################################################################################################################


    def get_general(self):
        self.update()
        _ski = self.checkBox_4.isChecked()
        _por = self.checkBox_3.isChecked()
        _cab = self.checkBox_2.isChecked()
        _opti = self.checkBox_1.isChecked()
        _pente = self.spinBox_1.value()
    ##testing:
        #console_info(f"get_general: ski={_ski}, por={_por}, cab={_cab}, opti={_opti}, pente={_pente}")
        return _ski, _por, _cab, _opti, _pente


    def get_spatial(self):
        self.update()
        _Wspace = getattr(self, f"lineEdit_1").text()
        _Wspace += "/"
        _Rspace = getattr(self, f"lineEdit_2").text()
        _Rspace += "/"
        _mnt = getattr(self, f"lineEdit_3").text()
        _foret = getattr(self, f"lineEdit_4").text()
        _desserte = getattr(self, f"lineEdit_5").text()
        _dep_cable = getattr(self, f"lineEdit_6").text()
        _ski_no_t_d = getattr(self, f"lineEdit_7").text()
        _ski_no_t_d += "/"
        _ski_no_t = getattr(self, f"lineEdit_8").text()
        _ski_no_t += "/"
        _por_obstacle = getattr(self, f"lineEdit_9").text()
        _por_obstacle += "/"
        _cab_obstacle = getattr(self, f"lineEdit_10").text()
        _HA = getattr(self, f"lineEdit_11").text()
        _VAM = getattr(self, f"lineEdit_12").text()
        _VBP = getattr(self, f"lineEdit_13").text()
    ##testing:
       # console_info(f"get_spatial: Wspace={_Wspace}, Rspace={_Rspace}, mnt={_mnt}, foret={_foret}, desserte={_desserte}, dep_cable={_dep_cable}, ski_no_t_d={_ski_no_t_d}, ski_no_t={_ski_no_t}, por_obstacle={_por_obstacle}, cab_obstacle={_cab_obstacle}, HA={_HA}, VAM={_VAM}, VBP={_VBP}")

        return _Wspace, _Rspace, _mnt, _foret, _desserte, _dep_cable, _ski_no_t_d, _ski_no_t, _por_obstacle, _cab_obstacle, _HA, _VAM, _VBP


    def get_skidder(self):
        self.update()
        _pente_max = self.spinBox_3.value()
        _distance_max_amont = self.spinBox_4.value()
        _distance_max_aval = self.spinBox_5.value()
        _distance_max_hors_frt_dsrt = self.spinBox_6.value() 
        _pente_amont_max = self.spinBox_7.value()
        _pente_aval_max = self.spinBox_1.value()
        if self.radioButton_1.isChecked():
            _limite = 1
        else:
            _limite = 2
        _bornes_s = self.plainTextEdit_1.toPlainText()
    ##testing:
        #console_info(f"get_skidder: pente_max={_pente_max}, distance_max_amont={_distance_max_amont}, distance_max_aval={_distance_max_aval}, distance_max_hors_frt_dsrt={_distance_max_hors_frt_dsrt}, pente_amont_max={_pente_amont_max}, pente_aval_max={_pente_aval_max}, limite={_limite}, bornes_s={_bornes_s}")
        return _pente_max, _distance_max_amont, _distance_max_aval, _distance_max_hors_frt_dsrt, _pente_amont_max, _pente_aval_max, _limite, _bornes_s
  

    def get_Forwarder(self):
        self.update()
        _pente_max = self.spinBox_8.value()
        _pente_max_remonant = self.spinBox_9.value()
        _pente_max_descendant = self.spinBox_12.value()
        _distance_max_pente_sup = self.spinBox_10.value()
        _distance_max_hors_frt = self.spinBox_11.value()
        _taille_grue = self.doubleSpinBox_1.value()
        _bornes_p = self.plainTextEdit_2.toPlainText()
    ##testing:
        #console_info(f"get_Forwarder: pente_max={_pente_max}, pente_max_remonant={_pente_max_remonant}, pente_max_descendant={_pente_max_descendant}, distance_max_pente_sup={_distance_max_pente_sup}, distance_max_hors_frt={_distance_max_hors_frt}, taille_grue={_taille_grue}, bornes_p={_bornes_p}")

        return _pente_max, _pente_max_remonant, _pente_max_descendant, _distance_max_pente_sup, _distance_max_hors_frt, _taille_grue, _bornes_p


    def get_type_cable(self):
        self.update()
        _type_machine = self.comboBox_1.currentText()
        _supports_inter = self.spinBox_14.value()
        _hauteur = self.doubleSpinBox_2.value()
        _longueur_max = self.spinBox_16.value()
        _longueur_min = self.spinBox_17.value()
    ##testing:
        #console_info(f"get_type_cable: type_machine={_type_machine}, supports_inter={_supports_inter}, hauteur={_hauteur}, longueur_max={_longueur_max}, longueur_min={_longueur_min}")

        return _type_machine, _supports_inter, _hauteur, _longueur_max, _longueur_min


    def get_type_chariot(self):
        self.update()
        _type_chariot = self.comboBox_3.currentText()
        _masse = self.spinBox_22.value()
        _pente_min = self.spinBox_23.value()
        _pente_max_amont = self.spinBox_24.value()
        _pente_max_aval = self.spinBox_25.value()
    ##testing:
        #console_info(f"get_type_chariot: type_chariot={_type_chariot}, masse={_masse}, pente_min={_pente_min}, pente_max_amont={_pente_max_amont}, pente_max_aval={_pente_max_aval}")

        return _type_chariot, _masse, _pente_min, _pente_max_amont, _pente_max_aval


    def get_proprietes_cable(self):
        self.update()
        _diametre = self.doubleSpinBox_3.value()
        _masse_li = self.doubleSpinBox_4.value()
        _tension_rupt = self.spinBox_26.value()
        _elasticite = self.spinBox_27.value()
    ##testing:
       # console_info(f"get_proprietes_cable: diametre={_diametre}, masse_li={_masse_li}, tension_rupt={_tension_rupt}, elasticite={_elasticite}")

        return _diametre, _masse_li, _tension_rupt, _elasticite


    def get_param_modelisation(self):
        self.update()
        _hauteur_sup = self.doubleSpinBox_5.value()
        _hauteur_mat = self.doubleSpinBox_8.value()
        _hauteur_min_cable = self.doubleSpinBox_6.value()
        _hauteur_max_cable = self.doubleSpinBox_9.value()
        _pechage = self.spinBox_40.value()
        _masse_max = self.spinBox_39.value()
        _securite = self.doubleSpinBox_10.value()
    ##testing:
        #console_info(f"get_param_modelisation: hauteur_sup={_hauteur_sup}, hauteur_mat={_hauteur_mat}, hauteur_min_cable={_hauteur_min_cable}, hauteur_max_cable={_hauteur_max_cable}, pechage={_pechage}, masse_max={_masse_max}, securite={_securite}")

        return _hauteur_sup, _hauteur_mat, _hauteur_min_cable, _hauteur_max_cable, _pechage, _masse_max, _securite


    def get_options(self):
        self.update()
        _opti = self.checkBox_5.isChecked()
        _precision = self.spinBox_41.value()
    ##testing:
        #console_info(f"get_options: opti={_opti}, precision={_precision}")

        return _opti, _precision


    def get_opti_cable(self,):
        self.update()
        _prelevement = self.spinBox_48.value()
        _recalculer = self.checkBox_6.isChecked()
        _Rspace_c = getattr(self, f"lineEdit_17").text()
        _Rspace_c += "/"
        _foret_c = getattr(self, f"lineEdit_14").text()
        _VBP_c = getattr(self, f"lineEdit_15").text()
        _VAM_c = getattr(self, f"lineEdit_16").text()
        _pechage_c = self.spinBox_49.value()
    ##testing:
        #console_info(f"get_opti_cable: prelevement={_prelevement}, recalculer={_recalculer}, Rspace_c={_Rspace_c}, foret_c={_foret_c}, VBP_c={_VBP_c}, VAM_c={_VAM_c}, pechage_c={_pechage_c}")

        return _prelevement, _recalculer, _Rspace_c, _foret_c, _VBP_c, _VAM_c, _pechage_c


    def get_crit_opti(self):
        self.update()
        surface_poids,nbr_sup_int_poids,sens_debardage_poids,longueure_ligne_poids,vol_ligne_poids,indice_prelev_poids,VAM_poids,dist_chariot_poids = 0,0,0,0,0,0,0,0
        if self.checkBox_101.isChecked():
            _surface = self.doubleSpinBox_11.value()
            surface_poids = self.spinBox_101.value()
        else:
            _surface = 0
        if  self.checkBox_102.isChecked():
            _nbr_sup_int = self.spinBox_46.value()
            nbr_sup_int_poids = self.spinBox_102.value()
        else:
            _nbr_sup_int = 0
        if self.checkBox_103.isChecked():
            _sens_debardage = self.spinBox_45.value()
            sens_debardage_poids = self.spinBox_103.value()
        else:
            _sens_debardage = 0
        if  self.checkBox_104.isChecked():
            _longueure_ligne = self.spinBox_44.value()
            longueure_ligne_poids = self.spinBox_104.value()
        else:
            _longueure_ligne = 0
        if self.checkBox_105.isChecked():
            _vol_ligne = self.spinBox_43.value()
            vol_ligne_poids = self.spinBox_105.value()
        else:
            _vol_ligne = 0
        if  self.checkBox_106.isChecked():
            _indice_prelev = self.doubleSpinBox_12.value()
            indice_prelev_poids = self.spinBox_106.value()
        else:
            _indice_prelev = 0
        if self.checkBox_107.isChecked():
            _VAM = self.doubleSpinBox_13.value()
            VAM_poids = self.spinBox_107.value()
        else:
            _VAM = 0
        if  self.checkBox_108.isChecked():
            _dist_chariot = self.spinBox_50.value()
            dist_chariot_poids = self.spinBox_108.value()
        else:
            _dist_chariot = 0
    ##testing:
        #console_info(f"get_crit_opti: surface={_surface}, nbr_sup_int={_nbr_sup_int}, sens_debardage={_sens_debardage}, longueure_ligne={_longueure_ligne}, vol_ligne={_vol_ligne}, indice_prelev={_indice_prelev}, VAM={_VAM}, dist_chariot={_dist_chariot}")
        #console_info(f"get_crit_opti_poids : surface_poids={surface_poids}, nbr_sup_int_poids={nbr_sup_int_poids}, sens_debardage_poids={sens_debardage_poids}, longueure_ligne_poids={longueure_ligne_poids}, vol_ligne_poids={vol_ligne_poids}, indice_prelev_poids={indice_prelev_poids}, VAM_poids={VAM_poids}, dist_chariot_poids={dist_chariot_poids}")
        return _surface,surface_poids,_nbr_sup_int,nbr_sup_int_poids,_sens_debardage,sens_debardage_poids,_longueure_ligne,longueure_ligne_poids,_vol_ligne,vol_ligne_poids,_indice_prelev,indice_prelev_poids,_VAM,VAM_poids,_dist_chariot,dist_chariot_poids

