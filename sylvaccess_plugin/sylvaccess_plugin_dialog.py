# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Sylvaccess_pluginDialog
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Importation des bibliothèques 
from PyQt5 import QtWidgets, uic
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtCore import QCoreApplication
import os
from qgis.core import QgsMessageLog, Qgis
from scipy import spatial
import numpy as np
from osgeo import gdal, osr, ogr
import math
from .resources import *
from math import sqrt,degrees,atan,cos,sin,radians,pi,atan2,ceil,floor,fabs
import shutil
import gc
import datetime
from scipy.interpolate import InterpolatedUnivariateSpline
import sys
import rpy2.robjects as robjects
from rpy2.robjects import pandas2ri
pandas2ri.activate()



# variables globales
global g,intsup,best,nblineTabis,h,b,l,r  
h,b,l,r,intsup,best,g,nblinetabis,Sylvaccess_UI = 0,0,0,0,0,0,9.80665,1,None

robjects.r.source("path/to/your/R/script.R")

# Chargement de l'interface utilisateur depuis le fichier .ui
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'sylvaccess_plugin_dialog_base.ui'))

class Sylvaccess_pluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self,iface=None, parent=None):
        super(Sylvaccess_pluginDialog, self).__init__(parent)
        self.setupUi(self)
        self.setWindowTitle("Sylvaccess")
#self.setWindowIcon(QIcon(':/plugins/sylvaccess_plugin/icon.png'))
        self.iface = iface
        global Sylvaccess_UI
        Sylvaccess_UI = self
        Sylvaccess_UI.general.setEnabled(True)
        Sylvaccess_UI.donnees_spatiale.setEnabled(True)


##################################################################
#.______     ______    __    __  .__________.  ______   .__   __.# 
#|   _  \   /  __  \  |  |  |  | |          | /  __  \  |  \ |  |# 
#|  |_)  | |  |  |  | |  |  |  | `---|  |---`|  |  |  | |   \|  |# 
#|   _  <  |  |  |  | |  |  |  |     |  |    |  |  |  | |  . `  |# 
#|  |_)  | |  `--'  | |  `--'  |     |  |    |  `--'  | |  |\   |# 
#|______/   \______/   \______/      |__|     \______/  |__| \__|# 
##################################################################        
        # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
        for i in range(1, 14):
            button = getattr(self, f"pushButton_{i}")
            button.clicked.connect(lambda _, num=i: self.open_folder(num))

        # Connexion des signaux des checkbox
        for i in range(1, 5):
            checkbox = getattr(self, f"checkBox_{i}")
            checkbox.stateChanged.connect(lambda _, num=i: self.checkbox_state_changed(num))


        for i in range(101,109):
            checkbox = getattr(self, f"checkBox_{i}")
            checkbox.stateChanged.connect(lambda _, num=i: self.checkbox_state_changed_opti(num))

        # Connexion des signaux des boutons OK et Annuler()
        self.button_box.accepted.connect(self.launch)
        self.button_box.rejected.connect(self.abort)
        self.spinBox_40.valueChanged.connect(self.spinBox_40_changed)
        self.comboBox_1.currentIndexChanged.connect(self.comboBox_1_changed)
        self.comboBox_3.currentIndexChanged.connect(self.comboBox_3_changed)

    # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
    def open_folder(self, button_number):
        # Définit les filtres génériques pour Shapefiles et fichiers raster
        shapefile_filter = "Shapefiles (*.shp );;Geopackage(*.gpkg);;All files (*)"
        raster_filter = "Raster files (*.tif *.asc *.txt);;All files (*)"

        # Définit les options de la boîte de dialogue
        options = QFileDialog.Options()
        #options |= QFileDialog.DontUseNativeDialog

        # Affiche le dialogue de sélection de fichier avec les filtres appropriés
        if button_number in [4, 5, 6]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, QCoreApplication.translate("MainWindow","Select a file"), filter=shapefile_filter, options=options)
        elif button_number in [3, 11, 12, 13]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, QCoreApplication.translate("MainWindow","Select a file"), filter=raster_filter, options=options)
        elif button_number in [1, 2, 7, 8, 9, 10]:  # Pour le bouton qui doit ouvrir un dossier
            selected_file = QFileDialog.getExistingDirectory(
                None, QCoreApplication.translate("MainWindow","Select a folder"), options=options)

        if selected_file:
            # Mise à jour du champ de texte approprié
            if button_number == 2:
                text_edit = getattr(self, f"lineEdit_2")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_17")
                text_edit.setText(selected_file)
            elif button_number == 4 :
                text_edit = getattr(self, f"lineEdit_4")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_14")
                text_edit.setText(selected_file)
            elif button_number == 13:
                text_edit = getattr(self, f"lineEdit_13")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_15")
                text_edit.setText(selected_file)
            elif button_number == 12 :
                text_edit = getattr(self, f"lineEdit_12")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_16")
                text_edit.setText(selected_file)
            else:
                text_edit = getattr(self, f"lineEdit_{button_number}")
                text_edit.setText(selected_file)

    # Fonction appelée lorsqu'une checkbox est cochée ou décochée
    def checkbox_state_changed(self, checkbox_number):
        # Récupère l'état de la checkbox
        ##for testing
        self.lineEdit_1.setText("C:/Users/yoann/Downloads/meisenthal2")
        self.lineEdit_2.setText("C:/Users/yoann/Downloads/meisenthal2/results")
        self.lineEdit_3.setText("C:/Users/yoann/Downloads/meisenthal2/mnt_rgealti_5m.tif")
        self.lineEdit_4.setText("C:/Users/yoann/Downloads/meisenthal2/frt.shp")
        self.lineEdit_5.setText("C:/Users/yoann/Downloads/meisenthal2/desserte.shp")
        self.lineEdit_6.setText("C:/Users/yoann/Downloads/meisenthal2/piste.shp")
        ##
        checkbox = getattr(self, f"checkBox_{checkbox_number}")
        checkbox_state = checkbox.isChecked()

        if checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(True)
                # désactive les lineEdit pour éviter les erreurs
                self.lineEdit_14.setEnabled(False)
                self.lineEdit_15.setEnabled(False)
                self.lineEdit_16.setEnabled(False)
                self.lineEdit_17.setEnabled(False)
                self.spinBox_49.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(True)
            if checkbox_number == 3:
                self.Forwarder.setEnabled(True)
            if checkbox_number == 4:
                self.skidder.setEnabled(True)
        elif not checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(False)
            if checkbox_number == 3:
                self.Forwarder.setEnabled(False)
 
            if checkbox_number == 4:
                self.skidder.setEnabled(False)


    def spinBox_40_changed(self):
        value = self.spinBox_40.value()
        self.spinBox_49.setValue(value)
        ##test
        console_info(f"spinBox_40_changed: value={value}")


    def comboBox_1_changed(self):
        value = self.comboBox_1.currentText()
        if value == QCoreApplication.translate("MainWindow", "Cable crane mounted on agricultural tractor"):
            self.spinBox_14.setValue(2)
            self.doubleSpinBox_2.setValue(8.5)
            self.spinBox_16.setValue(500)
            self.spinBox_17.setValue(125)
            self.doubleSpinBox_3.setValue(16.0)
            self.doubleSpinBox_4.setValue(1.4)
            self.spinBox_26.setValue(25000)
            self.spinBox_40.setValue(35)
        elif value == QCoreApplication.translate("MainWindow", "Cable crane mounted on trailer"):
            self.spinBox_14.setValue(3)
            self.doubleSpinBox_2.setValue(10.5)
            self.spinBox_16.setValue(780)
            self.spinBox_17.setValue(150)
            self.doubleSpinBox_3.setValue(18.0)
            self.doubleSpinBox_4.setValue(1.9)
            self.spinBox_26.setValue(35000)
            self.spinBox_40.setValue(35)
        elif value == QCoreApplication.translate("MainWindow", "Cable crane mounted on truck"):
            self.spinBox_14.setValue(3)
            self.doubleSpinBox_2.setValue(14)
            self.spinBox_16.setValue(1200)
            self.spinBox_17.setValue(200)
            self.doubleSpinBox_3.setValue(22.0)
            self.doubleSpinBox_4.setValue(2.6)
            self.spinBox_26.setValue(48000)
            self.spinBox_40.setValue(40)
        elif value == QCoreApplication.translate("MainWindow", "Long cable"):
            self.spinBox_14.setValue(3)
            self.doubleSpinBox_2.setValue(8.0)
            self.spinBox_16.setValue(1500)
            self.spinBox_17.setValue(300)
            self.doubleSpinBox_3.setValue(22.0)
            self.doubleSpinBox_4.setValue(2.6)
            self.spinBox_26.setValue(48000)
            self.spinBox_40.setValue(40)


    def comboBox_3_changed(self):
        value = self.comboBox_3.currentText()
        if value == QCoreApplication.translate("MainWindow", "Classical carriage"):
            self.spinBox_22.setValue(500)
            self.spinBox_23.setValue(15)
            self.spinBox_24.setValue(15)
            self.spinBox_25.setValue(100)
            self.spinBox_39.setValue(2500)
            self.spinBox_23.setEnabled(True)
            self.spinBox_24.setEnabled(False)
            self.spinBox_25.setEnabled(False)
        elif value == QCoreApplication.translate("MainWindow", "self-motorized carriage"):
            self.spinBox_22.setValue(1200)
            self.spinBox_23.setValue(15)
            self.spinBox_24.setValue(15)
            self.spinBox_25.setValue(100)
            self.spinBox_39.setValue(1800)
            self.spinBox_23.setEnabled(False)
            self.spinBox_24.setEnabled(True)
            self.spinBox_25.setEnabled(True)

  
    def checkbox_state_changed_opti(self, checkbox_number):
        # Récupère l'état de la checkbox
        checkbox = getattr(self, f"checkBox_{checkbox_number}")
        checkbox_state = checkbox.isChecked()

        if checkbox_state:
            if checkbox_number == 101:
                self.spinBox_101.setMinimum(1)
            if checkbox_number == 102:
                self.spinBox_102.setMinimum(1)
                self.spinBox_102.setValue(2)
            if checkbox_number == 103:
                self.spinBox_103.setMinimum(1)
            if checkbox_number == 104:
                self.spinBox_104.setMinimum(1)
            if checkbox_number == 105:
                self.spinBox_105.setMinimum(1)
            if checkbox_number == 106:
                self.spinBox_106.setMinimum(1)
                self.spinBox_106.setValue(4)
            if checkbox_number == 107:
                self.spinBox_107.setMinimum(1)
                self.spinBox_107.setValue(3)
            if checkbox_number == 108:
                self.spinBox_108.setMinimum(1)
        elif not checkbox_state:
            if checkbox_number == 101:
                self.spinBox_101.setMinimum(0)
                self.spinBox_101.setMaximum(0)
            if checkbox_number == 102:
                self.spinBox_102.setMinimum(0)
                self.spinBox_102.setMaximum(0)
            if checkbox_number == 103:
                self.spinBox_103.setMinimum(0)
                self.spinBox_103.setMaximum(0)
            if checkbox_number == 104:
                self.spinBox_104.setMinimum(0)
                self.spinBox_104.setMaximum(0)
            if checkbox_number == 105:
                self.spinBox_105.setMinimum(0)
                self.spinBox_105.setMaximum(0)
            if checkbox_number == 106:
                self.spinBox_106.setMinimum(0)  
                self.spinBox_106.setMaximum(0)
            if checkbox_number == 107:
                self.spinBox_107.setMinimum(0)
                self.spinBox_107.setMaximum(0)
            if checkbox_number == 108:
                self.spinBox_108.setMinimum(0)
                self.spinBox_108.setMaximum(0)


    def abort(self):
        self.close()


###############################################################################################
# __          ___      .__   __.   ______  _______ .___  ___.  _______ .__   __. .___________.#
#|  |        /   \     |  \ |  |  /      ||   ____||   \/   | |   ____||  \ |  | |           |#
#|  |       /  ^  \    |   \|  | |  ,----'|  |__   |  \  /  | |  |__   |   \|  | `---|  |----`#
#|  |      /  /_\  \   |  . `  | |  |     |   __|  |  |\/|  | |   __|  |  . `  |     |  |     #
#|  `----./  _____  \  |  |\   | |  `----.|  |____ |  |  |  | |  |____ |  |\   |     |  |     #
#|_______/__/     \__\ |__| \__|  \______||_______||__|  |__| |_______||__| \__|     |__|     #
###############################################################################################  


    def launch(self):
        ##testing
        #console_info("launch")
        ##
        
        Wspace,Rspace,_,_,file_shp_Desserte,_,_,_,_,_,_,_,_ = Sylvaccess_UI.get_spatial()
        test_Skidder,test_Forwarder,test_Cable,test_cable_optimise,pente = Sylvaccess_UI.get_general()
        prelevement,recalculer,_,foret2,VBP2,VAM2,pechage2 = Sylvaccess_UI.get_opti_cable()
        surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_UI.get_crit_opti()
        w_list = [surface, nbr_sup_int, sens_debardage, longueure_ligne, vol_ligne, indice_prelev, VAM3, dist_chariot]
        lim_list = [surface_poids, nbr_sup_int_poids, sens_debardage_poids, longueure_ligne_poids, vol_ligne_poids, indice_prelev_poids, VAM_poids, dist_chariot_poids]  
        try:os.mkdir(Rspace)
        except:pass
        for i in range (1,5):   
            if not getattr(self, f"lineEdit_{i}").text():
                txt = QCoreApplication.translate("MainWindow", "Please fill in all required fields")
                console_warning(txt)
                Sylvaccess_UI.abort()
                return
        Sylvaccess_UI.check_files()
        write_file()
        if (test_Skidder + test_Forwarder) > 0:
            # Check if part of the service corresponds to a project
            testExist = check_field_EXIST(file_shp_Desserte,"EXIST") 
            
            ###################################################################################################################
            ### If no service project
            ###################################################################################################################
            if not testExist: 
                if test_Skidder:  
                    Skidder()                    
                    gc.collect()
                
                if test_Forwarder:
                    process_forwarder()
                    gc.collect()
            
            ###################################################################################################################
            ### If service project exists
            ###################################################################################################################
            else:                        
                file_shp_Desserte_Exist = create_new_road_network(file_shp_Desserte,Wspace)
                
                # First simulation without project
                console_info(QCoreApplication.translate("MainWindow","\nSIMULATION FROM EXISTING SERVICE"))
                if test_Skidder:   
                    try:os.mkdir(Rspace+"Skidder/")
                    except:pass
                    Skidder(file_shp_Desserte_Exist)                    
                    gc.collect()
                    projdir = Rspace+"Skidder/1_Existant/"
                    os.rename(Rspace+"Skidder/Skidder/",projdir)
                
                if test_Forwarder:
                    Rspace_f = Rspace+"Forwarder/"
                    old=Rspace+"Forwarder/Forwarder/"
                    new= Rspace+"Forwarder/1_Existant/"  
                    try:os.mkdir(Rspace_f)
                    except:pass
                    process_forwarder()
                    gc.collect()
                    os.rename(old,new)  
                    
                os.remove(Wspace+"Temp/Link_track.npy")
                os.remove(Wspace+"Temp/Link_RF.npy")
                os.remove(Wspace+"Temp/Tab_res_pub.npy")
                os.remove(Wspace+"Temp/Road_for.npy")
                os.remove(Wspace+"Temp/Track.npy")
                
                # Second simulation with project
                console_info(QCoreApplication.translate("MainWindow","\nSIMULATION INCLUDING THE SERVICE PROJECT"))
                if test_Skidder: 
                    Skidder()                    
                    gc.collect()
                    projdir = Rspace+"Skidder/2_Project/"
                    os.rename(Rspace+"Skidder/Skidder/",projdir)
                    make_dif_files(Rspace,0)     
                    
                if test_Forwarder:
                    Rspace_f = Rspace+"Forwarder/"
                    old=Rspace+"Forwarder/Forwarder/"
                    new= Rspace+"Forwarder/2_Project/"                                
                    process_forwarder()
                    gc.collect()         
                    os.rename(old,new)   
                    make_dif_files(Rspace,1)                       
        
        if test_Cable:
            Cable()
            test_cable_optimise=0
            gc.collect()
        if test_cable_optimise:
            line_selection(Wspace,w_list,lim_list,recalculer,foret2,VBP2,VAM2,pechage2,prelevement,pente) 
            gc.collect()  
        try:
            shutil.rmtree(Wspace+"Temp")
        except:
            pass
        Sylvaccess_UI.close()


    def check_files(self):
        verif = True
        test_Skidder,test_Forwarder,test_Cable,test_cable_optim,_ = self.get_general()
        _,_,file_MNT, file_shp_Foret, file_shp_Desserte, file_shp_Cable_dep,_,_,_,_, file_vol_AM, file_HA, file_vol_BP = Sylvaccess_UI.get_spatial_cls()
        _,new_calc,_,_,_,_,_ = self.get_opti_cable()

        msg = QCoreApplication.translate("MainWindow", "\nTHE FOLLOWING PROBLEMS HAVE BEEN IDENTIFIED WITH REGARD TO SPATIAL ENTRY: \n")
        # Check MNT
        if test_Skidder + test_Forwarder + test_Cable > 0:
            try:
                _, values, _, Extent = raster_get_info(file_MNT)
                if values[5] is None:
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Raster DTM: No value of NoData defined\n")
            except:
                msg += QCoreApplication.translate("MainWindow", " -   Raster DTM:  Path is missing or incorrect. This raster is required to run Sylvaccess\n")
                verif = False

        # Check file_shp_Desserte
        if test_Skidder + test_Forwarder > 0:
            try:
                if not check_field(file_shp_Desserte, "CL_SVAC"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Service layer: The 'CL_SVAC' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Service layer: Path is missing or incorrect. This layer is required for skidder and forwarder modules\n")

        # Check file_shp_Cable_Dep
        if test_Cable:
            try:
                if not check_field(file_shp_Cable_dep, "CABLE"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Service layer: The 'CABLE' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Potential cable departures layer: The access path is missing or incorrect. This layer is mandatory for the cable module\n")

        # Check file_shp_Foret
        if test_Skidder + test_Forwarder + test_Cable > 0:
            try:
                if not check_field(file_shp_Foret, "FORET"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Forest layer: The 'FOREST' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer: Path is missing or incorrect. This layer is required to run Sylvaccess\n")
            if not file_shp_Foret.endswith(".shp") or not file_shp_Foret.endswith(".gpkg"):
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer: The file must be a shapefile or a geopackage !NOT ALWAYS TRUE,KINDA BUGGED\n")

        # Check file_shp_Foret for cable optim
        if not test_Cable and test_cable_optim and new_calc and file_shp_Foret != "":
            try:
                if not check_field(file_shp_Foret, "FORET"):
                    verif = False
                    msg += QCoreApplication.translate("MainWindow", " -   Forest layer (optimization cable tab): The 'FOREST' field is missing\n")
            except:
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer (optimization cable tab): The path is missing or incorrect. \n")
            if not file_shp_Foret.endswith(".shp") or not file_shp_Foret.endswith(".gpkg"):
                verif = False
                msg += QCoreApplication.translate("MainWindow", " -   Forest layer (optimization cable tab): The file must be a shapefile or a geopackage\n")

        # Check file_vol_BP, file_vol_AM, file_HA
        name = [QCoreApplication.translate("MainWindow", "Raster Volume/ha"), QCoreApplication.translate("MainWindow", "Raster medium tree volume"), QCoreApplication.translate("MainWindow", "Raster tree height")]
        for i, f in enumerate([file_vol_BP, file_vol_AM, file_HA]):
            if f != "":
                try:
                    _, values2, _, Extent2 = raster_get_info(f)
                    if values2[5] is None:
                        verif = False
                        msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": No value of NoData defined\n")
                    if not values[4] == values2[4]:
                        verif = False
                        msg += " -   " + name[i] + QCoreApplication.translate("MainWindow", ": Raster cell size should be the same as DTM\n")
                    if not np.all(Extent == Extent2):
                        verif = False
                        msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The extent of the raster must be the same as that of the DTM\n")
                        
                    if (Extent2[2] < Extent[2]) or (Extent2[3] < Extent[3]):
                        verif = False
                        msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The raster size is undersized compared to the main DTM\n")
                        
                except:
                    verif = False
                    msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The access path is incorrect\n")
                if not f.endswith(".tif") or not f.endswith(".asc") or not f.endswith(".txt"):
                    verif = False
                    msg +=  " -   " + name[i] + QCoreApplication.translate("MainWindow", ": The file must be a tif, asc or txt file\n")

        if not verif:
            msg += QCoreApplication.translate("MainWindow", "\nPLEASE CORRECT BEFORE RELAUNCHING SYLVACCESS\n")
            console_warning(msg)
            Sylvaccess_UI.abort()
        return verif


#####################################################################################################################
#  _______  _______ .___________.   ____    ____  ___      .______    __       ___      .______    __       _______ #
# /  _____||   ____||           |   \   \  /   / /   \     |   _  \  |  |     /   \     |   _  \  |  |     |   ____|#
#|  |  __  |  |__   `---|  |----`    \   \/   / /  ^  \    |  |_)  | |  |    /  ^  \    |  |_)  | |  |     |  |__   #
#|  | |_ | |   __|      |  |          \      / /  /_\  \   |      /  |  |   /  /_\  \   |   _  <  |  |     |   __|  #
#|  |__| | |  |____     |  |           \    / /  _____  \  |  |\  \-.|  |  /  _____  \  |  |_)  | |  `----.|  |____ #
# \______| |_______|    |__|            \__/ /__/     \__\ | _| `.__||__| /__/     \__\ |______/  |_______||_______|#
#####################################################################################################################


    def get_general(self):
        self.update()
        _ski = self.checkBox_4.isChecked()
        _por = self.checkBox_3.isChecked()
        _cab = self.checkBox_2.isChecked()
        _opti = self.checkBox_1.isChecked()
        _pente = self.spinBox_1.value()
    ##testing:
        #console_info(f"get_general: ski={_ski}, por={_por}, cab={_cab}, opti={_opti}, pente={_pente}")
        return _ski, _por, _cab, _opti, _pente


    def get_spatial(self):
        self.update()
        _Wspace = getattr(self, f"lineEdit_1").text()
        _Wspace += "/"
        _Rspace = getattr(self, f"lineEdit_2").text()
        _Rspace += "/"
        _mnt = getattr(self, f"lineEdit_3").text()
        _foret = getattr(self, f"lineEdit_4").text()
        _desserte = getattr(self, f"lineEdit_5").text()
        _dep_cable = getattr(self, f"lineEdit_6").text()
        _ski_no_t_d = getattr(self, f"lineEdit_7").text()
        _ski_no_t_d += "/"
        _ski_no_t = getattr(self, f"lineEdit_8").text()
        _ski_no_t += "/"
        _por_obstacle = getattr(self, f"lineEdit_9").text()
        _por_obstacle += "/"
        _cab_obstacle = getattr(self, f"lineEdit_10").text()
        _HA = getattr(self, f"lineEdit_11").text()
        _VAM = getattr(self, f"lineEdit_12").text()
        _VBP = getattr(self, f"lineEdit_13").text()
    ##testing:
       # console_info(f"get_spatial: Wspace={_Wspace}, Rspace={_Rspace}, mnt={_mnt}, foret={_foret}, desserte={_desserte}, dep_cable={_dep_cable}, ski_no_t_d={_ski_no_t_d}, ski_no_t={_ski_no_t}, por_obstacle={_por_obstacle}, cab_obstacle={_cab_obstacle}, HA={_HA}, VAM={_VAM}, VBP={_VBP}")

        return _Wspace, _Rspace, _mnt, _foret, _desserte, _dep_cable, _ski_no_t_d, _ski_no_t, _por_obstacle, _cab_obstacle, _HA, _VAM, _VBP


    def get_skidder(self):
        self.update()
        _pente_max = self.spinBox_3.value()
        _distance_max_amont = self.spinBox_4.value()
        _distance_max_aval = self.spinBox_5.value()
        _distance_max_hors_frt_dsrt = self.spinBox_6.value() 
        _pente_amont_max = self.spinBox_7.value()
        _pente_aval_max = self.spinBox_1.value()
        if self.radioButton_1.isChecked():
            _limite = 1
        else:
            _limite = 2
        _bornes_s = self.plainTextEdit_1.toPlainText()
    ##testing:
        #console_info(f"get_skidder: pente_max={_pente_max}, distance_max_amont={_distance_max_amont}, distance_max_aval={_distance_max_aval}, distance_max_hors_frt_dsrt={_distance_max_hors_frt_dsrt}, pente_amont_max={_pente_amont_max}, pente_aval_max={_pente_aval_max}, limite={_limite}, bornes_s={_bornes_s}")
        return _pente_max, _distance_max_amont, _distance_max_aval, _distance_max_hors_frt_dsrt, _pente_amont_max, _pente_aval_max, _limite, _bornes_s
  

    def get_Forwarder(self):
        self.update()
        _pente_max = self.spinBox_8.value()
        _pente_max_remonant = self.spinBox_9.value()
        _pente_max_descendant = self.spinBox_12.value()
        _distance_max_pente_sup = self.spinBox_10.value()
        _distance_max_hors_frt = self.spinBox_11.value()
        _taille_grue = self.doubleSpinBox_1.value()
        _bornes_p = self.plainTextEdit_2.toPlainText()
    ##testing:
        #console_info(f"get_Forwarder: pente_max={_pente_max}, pente_max_remonant={_pente_max_remonant}, pente_max_descendant={_pente_max_descendant}, distance_max_pente_sup={_distance_max_pente_sup}, distance_max_hors_frt={_distance_max_hors_frt}, taille_grue={_taille_grue}, bornes_p={_bornes_p}")

        return _pente_max, _pente_max_remonant, _pente_max_descendant, _distance_max_pente_sup, _distance_max_hors_frt, _taille_grue, _bornes_p


    def get_type_cable(self):
        self.update()
        _type_machine = self.comboBox_1.currentText()
        _supports_inter = self.spinBox_14.value()
        _hauteur = self.doubleSpinBox_2.value()
        _longueur_max = self.spinBox_16.value()
        _longueur_min = self.spinBox_17.value()
    ##testing:
        #console_info(f"get_type_cable: type_machine={_type_machine}, supports_inter={_supports_inter}, hauteur={_hauteur}, longueur_max={_longueur_max}, longueur_min={_longueur_min}")

        return _type_machine, _supports_inter, _hauteur, _longueur_max, _longueur_min


    def get_type_chariot(self):
        self.update()
        _type_chariot = self.comboBox_3.currentText()
        _masse = self.spinBox_22.value()
        _pente_min = self.spinBox_23.value()
        _pente_max_amont = self.spinBox_24.value()
        _pente_max_aval = self.spinBox_25.value()
    ##testing:
        #console_info(f"get_type_chariot: type_chariot={_type_chariot}, masse={_masse}, pente_min={_pente_min}, pente_max_amont={_pente_max_amont}, pente_max_aval={_pente_max_aval}")

        return _type_chariot, _masse, _pente_min, _pente_max_amont, _pente_max_aval


    def get_proprietes_cable(self):
        self.update()
        _diametre = self.doubleSpinBox_3.value()
        _masse_li = self.doubleSpinBox_4.value()
        _tension_rupt = self.spinBox_26.value()
        _elasticite = self.spinBox_27.value()
    ##testing:
       # console_info(f"get_proprietes_cable: diametre={_diametre}, masse_li={_masse_li}, tension_rupt={_tension_rupt}, elasticite={_elasticite}")

        return _diametre, _masse_li, _tension_rupt, _elasticite


    def get_param_modelisation(self):
        self.update()
        _hauteur_sup = self.doubleSpinBox_5.value()
        _hauteur_mat = self.doubleSpinBox_8.value()
        _hauteur_min_cable = self.doubleSpinBox_6.value()
        _hauteur_max_cable = self.doubleSpinBox_9.value()
        _pechage = self.spinBox_40.value()
        _masse_max = self.spinBox_39.value()
        _securite = self.doubleSpinBox_10.value()
    ##testing:
        #console_info(f"get_param_modelisation: hauteur_sup={_hauteur_sup}, hauteur_mat={_hauteur_mat}, hauteur_min_cable={_hauteur_min_cable}, hauteur_max_cable={_hauteur_max_cable}, pechage={_pechage}, masse_max={_masse_max}, securite={_securite}")

        return _hauteur_sup, _hauteur_mat, _hauteur_min_cable, _hauteur_max_cable, _pechage, _masse_max, _securite


    def get_options(self):
        self.update()
        _opti = self.checkBox_5.isChecked()
        _precision = self.spinBox_41.value()
    ##testing:
        #console_info(f"get_options: opti={_opti}, precision={_precision}")

        return _opti, _precision


    def get_opti_cable(self,):
        self.update()
        _prelevement = self.spinBox_48.value()
        _recalculer = self.checkBox_6.isChecked()
        _Rspace_c = getattr(self, f"lineEdit_17").text()
        _Rspace_c += "/"
        _foret_c = getattr(self, f"lineEdit_14").text()
        _VBP_c = getattr(self, f"lineEdit_15").text()
        _VAM_c = getattr(self, f"lineEdit_16").text()
        _pechage_c = self.spinBox_49.value()
    ##testing:
        #console_info(f"get_opti_cable: prelevement={_prelevement}, recalculer={_recalculer}, Rspace_c={_Rspace_c}, foret_c={_foret_c}, VBP_c={_VBP_c}, VAM_c={_VAM_c}, pechage_c={_pechage_c}")

        return _prelevement, _recalculer, _Rspace_c, _foret_c, _VBP_c, _VAM_c, _pechage_c


    def get_crit_opti(self):
        self.update()
        surface_poids,nbr_sup_int_poids,sens_debardage_poids,longueure_ligne_poids,vol_ligne_poids,indice_prelev_poids,VAM_poids,dist_chariot_poids = 0,0,0,0,0,0,0,0
        if self.checkBox_101.isChecked():
            _surface = self.doubleSpinBox_11.value()
            surface_poids = self.spinBox_101.value()
        else:
            _surface = 0
        if  self.checkBox_102.isChecked():
            _nbr_sup_int = self.spinBox_46.value()
            nbr_sup_int_poids = self.spinBox_102.value()
        else:
            _nbr_sup_int = 0
        if self.checkBox_103.isChecked():
            _sens_debardage = self.spinBox_45.value()
            sens_debardage_poids = self.spinBox_103.value()
        else:
            _sens_debardage = 0
        if  self.checkBox_104.isChecked():
            _longueure_ligne = self.spinBox_44.value()
            longueure_ligne_poids = self.spinBox_104.value()
        else:
            _longueure_ligne = 0
        if self.checkBox_105.isChecked():
            _vol_ligne = self.spinBox_43.value()
            vol_ligne_poids = self.spinBox_105.value()
        else:
            _vol_ligne = 0
        if  self.checkBox_106.isChecked():
            _indice_prelev = self.doubleSpinBox_12.value()
            indice_prelev_poids = self.spinBox_106.value()
        else:
            _indice_prelev = 0
        if self.checkBox_107.isChecked():
            _VAM = self.doubleSpinBox_13.value()
            VAM_poids = self.spinBox_107.value()
        else:
            _VAM = 0
        if  self.checkBox_108.isChecked():
            _dist_chariot = self.spinBox_50.value()
            dist_chariot_poids = self.spinBox_108.value()
        else:
            _dist_chariot = 0
    ##testing:
        #console_info(f"get_crit_opti: surface={_surface}, nbr_sup_int={_nbr_sup_int}, sens_debardage={_sens_debardage}, longueure_ligne={_longueure_ligne}, vol_ligne={_vol_ligne}, indice_prelev={_indice_prelev}, VAM={_VAM}, dist_chariot={_dist_chariot}")
        #console_info(f"get_crit_opti_poids : surface_poids={surface_poids}, nbr_sup_int_poids={nbr_sup_int_poids}, sens_debardage_poids={sens_debardage_poids}, longueure_ligne_poids={longueure_ligne_poids}, vol_ligne_poids={vol_ligne_poids}, indice_prelev_poids={indice_prelev_poids}, VAM_poids={VAM_poids}, dist_chariot_poids={dist_chariot_poids}")
        return _surface,surface_poids,_nbr_sup_int,nbr_sup_int_poids,_sens_debardage,sens_debardage_poids,_longueure_ligne,longueure_ligne_poids,_vol_ligne,vol_ligne_poids,_indice_prelev,indice_prelev_poids,_VAM,VAM_poids,_dist_chariot,dist_chariot_poids

    @classmethod
    def get_general_cls(cls):
        _ski, _por, _cab, _opti, _pente = Sylvaccess_UI.get_general()
        return _ski, _por, _cab, _opti, _pente

    @classmethod
    def get_spatial_cls(cls):
        _Wspace, _Rspace, _mnt, _foret, _desserte, _dep_cable, _ski_no_t_d, _ski_no_t, _por_obstacle, _cab_obstacle, _HA, _VAM, _VBP = Sylvaccess_UI.get_spatial()
        return _Wspace, _Rspace, _mnt, _foret, _desserte, _dep_cable, _ski_no_t_d, _ski_no_t, _por_obstacle, _cab_obstacle, _HA, _VAM, _VBP

    @classmethod
    def get_skidder_cls(cls):
        _pente_max, _distance_max_amont, _distance_max_aval, _distance_max_hors_frt_dsrt, _pente_amont_max, _pente_aval_max, _limite, _bornes_s = Sylvaccess_UI.get_skidder()
        return _pente_max, _distance_max_amont, _distance_max_aval, _distance_max_hors_frt_dsrt, _pente_amont_max, _pente_aval_max, _limite, _bornes_s

    @classmethod
    def get_Forwarder_cls(cls):
        _pente_max, _pente_max_remonant, _pente_max_descendant, _distance_max_pente_sup, _distance_max_hors_frt, _taille_grue, _bornes_p = Sylvaccess_UI.get_Forwarder()
        return _pente_max, _pente_max_remonant, _pente_max_descendant, _distance_max_pente_sup, _distance_max_hors_frt, _taille_grue, _bornes_p

    @classmethod
    def get_type_cable_cls(cls):
        _type_machine, _supports_inter, _hauteur, _longueur_max, _longueur_min = Sylvaccess_UI.get_type_cable()
        return _type_machine, _supports_inter, _hauteur, _longueur_max, _longueur_min

    @classmethod
    def get_type_chariot_cls(cls):
        _type_chariot, _masse, _pente_min, _pente_max_amont, _pente_max_aval = Sylvaccess_UI.get_type_chariot()
        return _type_chariot, _masse, _pente_min, _pente_max_amont, _pente_max_aval

    @classmethod
    def get_proprietes_cable_cls(cls):
        _diametre, _masse_li, _tension_rupt, _elasticite = Sylvaccess_UI.get_proprietes_cable()
        return _diametre, _masse_li, _tension_rupt, _elasticite

    @classmethod
    def get_param_modelisation_cls(cls):
        _hauteur_sup, _hauteur_mat, _hauteur_min_cable, _hauteur_max_cable, _pechage, _masse_max, _securite = Sylvaccess_UI.get_param_modelisation()
        return _hauteur_sup, _hauteur_mat, _hauteur_min_cable, _hauteur_max_cable, _pechage, _masse_max, _securite

    @classmethod
    def get_options_cls(cls):
        _opti, _precision = Sylvaccess_UI.get_options()
        return _opti, _precision

    @classmethod
    def get_opti_cable_cls(cls):
        _prelevement, _recalculer, _Rspace_c, _foret_c, _VBP_c, _VAM_c, _pechage_c = Sylvaccess_UI.get_opti_cable()
        return _prelevement, _recalculer, _Rspace_c, _foret_c, _VBP_c, _VAM_c, _pechage_c

    @classmethod
    def get_crit_opti_cls(cls):
        _surface, _surface_poids, _nbr_sup_int, _nbr_sup_int_poids, _sens_debardage, _sens_debardage_poids, _longueure_ligne, _longueure_ligne_poids, _vol_ligne, _vol_ligne_poids, _indice_prelev, _indice_prelev_poids, _VAM, _VAM_poids, _dist_chariot, _dist_chariot_poids = Sylvaccess_UI.get_crit_opti()
        return _surface, _surface_poids, _nbr_sup_int, _nbr_sup_int_poids, _sens_debardage, _sens_debardage_poids, _longueure_ligne, _longueure_ligne_poids, _vol_ligne, _vol_ligne_poids, _indice_prelev, _indice_prelev_poids, _VAM, _VAM_poids, _dist_chariot, _dist_chariot_poids


#################################################
#.______   .______   __  .__   __. .___________.#
#|   _  \  |   _  \ |  | |  \ |  | |           |#
#|  |_)  | |  |_)  ||  | |   \|  | `---|  |----`#
#|   ___/  |      / |  | |  . `  |     |  |     #
#|  |      |  |\  \-|  | |  |\   |     |  |     #
#| _|      | _| `.__|__| |__| \__|     |__|     #
#################################################


# Fonctions qui affiche un message d'erreur dans la console
def console_warning(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Warning)

# Fonctions qui affiche un message d'information dans la console
def console_info(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Info)


#########################################################################
#  _______  _______ .__   __.  _______ .______        ___       __      #
# /  _____||   ____||  \ |  | |   ____||   _  \      /   \     |  |     #
#|  |  __  |  |__   |   \|  | |  |__   |  |_)  |    /  ^  \    |  |     #
#|  | |_ | |   __|  |  . `  | |   __|  |      /    /  /_\  \   |  |     #
#|  |__| | |  |____ |  |\   | |  |____ |  |\  \--./  _____  \  |  `----.#
# \______| |_______||__| \__| |_______|| _| `.___/__/     \__\ |_______|#
#########################################################################
    

def heures(Hdebut):
    Hfin = datetime.datetime.now()
    duree = Hfin - Hdebut
    str_duree = str(duree).split('.')[0]
    str_duree = str_duree.split(':')[0] + 'h ' + str_duree.split(':')[1] + 'm ' + str_duree.split(':')[2] + 's'
    str_debut = Hdebut.strftime('%d/%m/%Y %H:%M:%S')
    str_fin = Hfin.strftime('%d/%m/%Y %H:%M:%S')

    return str_duree, str_fin, str_debut


def save_integer_ascii(file_name,head_text,data):
    np.savetxt(file_name, data, fmt='%i', delimiter=' ')
    with open(file_name, "r+") as f:
        old = f.read()
        f.seek(0)
        f.write(head_text + old)
        f.close()


def clear_big_nparray():    
    """clear all globals over 100 Mo size and their associated memory space"""
    for uniquevar in [var for var in dir() if isinstance(globals()[var],np.ndarray)]:
        if globals()[uniquevar].nbytes/1000000>50:
            del globals()[uniquevar]
    gc.collect()


def read_info(info_file):
    names = np.genfromtxt(info_file, dtype=None,usecols=(0),encoding ='latin1')
    values = np.genfromtxt(info_file, dtype=None,usecols=(1),encoding ='latin1')  
    return list(names),list(values)


def raster_get_info(in_file_name):
    source_ds = gdal.Open(in_file_name)    
    src_proj = osr.SpatialReference(wkt=source_ds.GetProjection())
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform()
    ymin = ymax+src_nrows*Csize_y
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [src_ncols,src_nrows,xmin,ymin,Csize_x,nodata]
    Extent = [xmin,xmin+src_ncols*Csize_x,ymin,ymax]
    return names,values,src_proj,Extent


def read_raster(file_name):
    source_ds = gdal.Open(file_name)
    source_ds.FlushCache() # Flush 
    Array = source_ds.GetRasterBand(1).ReadAsArray()
    Array[Array==0]=-9999
    return Array


def write_file():
    # Récupération des valeurs des variables
    Wspace, Rspace, mnt, foret, desserte, dep_cable, ski_no_t_d, ski_no_t, por_obstacle, cab_obstacle, HA, VAM, VBP = Sylvaccess_UI.get_spatial_cls()
    spatial_data = [Wspace, Rspace, mnt, foret, desserte, dep_cable, ski_no_t_d, ski_no_t, por_obstacle, cab_obstacle, HA, VAM, VBP]

    ski, por, cab, opti, pente = Sylvaccess_UI.get_general_cls()
    pente = str(pente) + " %"
    general_data = [ski, por, cab, opti, pente]

    pente_max, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max, limite, bornes = Sylvaccess_UI.get_skidder_cls()
    if limite == 1:
        limite = QCoreApplication.translate("MainWindow","1-Limit soil damages: force the skidder to proceed from the forest road network")
    else:
        limite = QCoreApplication.translate("MainWindow","2-Limit winching operations: force the skidder to get as close as possible from logs")
    skidder_data = [pente_max, distance_max_amont, distance_max_aval, distance_max_hors_frt_dsrt, pente_amont_max, pente_aval_max, limite, bornes]
    for i in (0, 4, 5):
        skidder_data[i] = str(skidder_data[i]) + " %"
    for i in (1, 2, 3):
        skidder_data[i] = str(skidder_data[i]) + " m"

    pente_max2, pente_max_remonant, pente_max_descendant, distance_max_pente_sup, distance_max_hors_frt, taille_grue, bornes2 = Sylvaccess_UI.get_Forwarder_cls()
    forwarder_data = [pente_max2, pente_max_remonant, pente_max_descendant, distance_max_pente_sup, distance_max_hors_frt, taille_grue, bornes2]
    for i in (0, 1, 2):
        forwarder_data[i] = str(forwarder_data[i]) + " %"
    for i in (3, 4, 5):
        forwarder_data[i] = str(forwarder_data[i]) + " m"

    type_machine, supports_inter, hauteur, longueur_max, longueur_min = Sylvaccess_UI.get_type_cable_cls()
    type_cable_data = [type_machine, supports_inter, hauteur, longueur_max, longueur_min]
    for i in (2, 3, 4): 
        type_cable_data[i] = str(type_cable_data[i]) + " m"

    type_chariot, masse, pente_min, pente_max_amont, pente_max_aval = Sylvaccess_UI.get_type_chariot_cls()
    type_chariot_data = [type_chariot, masse, pente_min, pente_max_amont, pente_max_aval]
    masse = str(masse) + " kg"
    for i in (2, 3, 4):
        type_chariot_data[i] = str(type_chariot_data[i]) + " %"

    diamètre, masse_li, tension_rupt, elasticité = Sylvaccess_UI.get_proprietes_cable()
    propriete_cable_data = [diamètre, masse_li, tension_rupt, elasticité]
    diamètre = str(diamètre) + " mm"
    masse_li = str(masse_li) + " kg/mm"
    tension_rupt = str(tension_rupt) + " N"
    elasticité = str(elasticité) + " N/mm²"

    hauteur_sup, hauteur_mat, hauteur_min_cable, hauteur_max_cable, pechage, masse_max, securite = Sylvaccess_UI.get_param_modelisation()
    param_modelisation_data = [hauteur_sup, hauteur_mat, hauteur_min_cable, hauteur_max_cable, pechage, masse_max, securite]
    for i in (0, 1, 2, 3, 4):
        param_modelisation_data[i] = str(param_modelisation_data[i]) + " m"
    masse_max = str(masse_max) + " kg"

    opti2, precision = Sylvaccess_UI.get_options()
    options_data = [opti2, precision]

    prelevement, recalculer, Rspace2, foret2, VBP2, VAM2, pechage2 = Sylvaccess_UI.get_opti_cable()
    opti_cable_data = [prelevement, recalculer, Rspace2, foret2, VBP2, VAM2, pechage2]

    surface, surface_poids, nbr_sup_int, nbr_sup_int_poids, sens_debardage, sens_debardage_poids, longueur_ligne, longueur_ligne_poids, vol_ligne, vol_ligne_poids, indice_prelev, indice_prelev_poids, VAM3, VAM_poids, dist_chariot, dist_chariot_poids = Sylvaccess_UI.get_crit_opti()
    crit_opti_data = [surface, surface_poids, nbr_sup_int, nbr_sup_int_poids, sens_debardage, sens_debardage_poids, longueur_ligne, longueur_ligne_poids, vol_ligne, vol_ligne_poids, indice_prelev, indice_prelev_poids, VAM3, VAM_poids, dist_chariot, dist_chariot_poids]

    # Wrap all strings with tr() function
    file_name = Rspace + "_all_param.txt"
    with open(file_name, 'w') as fichier:
        
        fichier.write(QCoreApplication.translate("MainWindow","General data :\n\n"))
        zip1 = [QCoreApplication.translate("MainWindow", "skidder Analysis"), QCoreApplication.translate("MainWindow", "Forwarder Analysis"), QCoreApplication.translate("MainWindow", "Cable Yarding Analysis"), QCoreApplication.translate("MainWindow", "Optimize Cable Line"), QCoreApplication.translate("MainWindow", "Maximum slope for manual harvesting")]
        for var_name, var_value in zip(zip1, general_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nSpatial data :\n\n"))
        zip1 = [QCoreApplication.translate("MainWindow", "Workspace"), QCoreApplication.translate("MainWindow", "Result Space"), QCoreApplication.translate("MainWindow", "DTM file"), QCoreApplication.translate("MainWindow", "Forest area file"), QCoreApplication.translate("MainWindow", "Forest road network"), QCoreApplication.translate("MainWindow", "Cable Crane start point"), QCoreApplication.translate("MainWindow", "Skidder, area where winching and skidding are forbidden"), QCoreApplication.translate("MainWindow", "Skidder, area where skidding is forbidden"), QCoreApplication.translate("MainWindow", "Forwarder, obstacles for the free movement of the machine"), QCoreApplication.translate("MainWindow", "Cable yarding, obstacles for the set-up of cable line"), QCoreApplication.translate("MainWindow", "Height of the trees"), QCoreApplication.translate("MainWindow", "Average tree volume"), QCoreApplication.translate("MainWindow", "Volume per hectare")]
        for var_name, var_value in zip(zip1, spatial_data):
            if var_value == "":
                print = QCoreApplication.translate("MainWindow", "No data")
                fichier.write(f"{var_name}: {print} \n")
            else:
                fichier.write(f"{var_name}: {var_value}  \n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nParameters for skidder processing:\n\n"))
        zip1 =  [QCoreApplication.translate("MainWindow", "Maximal slope outside forest network for the skidder"), QCoreApplication.translate("MainWindow", "Maximum uphill winching distance"), QCoreApplication.translate("MainWindow", "Maximum downhill winching distance"), QCoreApplication.translate("MainWindow", "Maximal distance outside forest"), QCoreApplication.translate("MainWindow", "Slope from which uphill winching reaches maximum distance"), QCoreApplication.translate("MainWindow", "Slope from which downhill winching reaches maximum distance"), QCoreApplication.translate("MainWindow", "Simulation option"), QCoreApplication.translate("MainWindow", "Classes of skidding distance (Total distance in meters)")]
        for var_name, var_value in zip(zip1, skidder_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nParameters for forwarder processing :\n\n"))
        zip1 =  [QCoreApplication.translate("MainWindow", "Maximum lateral inclination of the machine"), QCoreApplication.translate("MainWindow", "Maximum slope for a uphill yarding"), QCoreApplication.translate("MainWindow", "Maximum slope for a downhill yarding"), QCoreApplication.translate("MainWindow", "Maximum yarding distance when slope is greater than the maximum lateral inclination of the machine"), QCoreApplication.translate("MainWindow", "Maximum distance outside forest"), QCoreApplication.translate("MainWindow", "Length of the hoist"), QCoreApplication.translate("MainWindow", "Classes of skidding distance (Total distance in meters)")]
        for var_name, var_value in zip(zip1, forwarder_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nCable machine properties :\n\n"))
        zip1 =  [QCoreApplication.translate("MainWindow", "Type of material"), QCoreApplication.translate("MainWindow", "Maximum number of intermediate supports"), QCoreApplication.translate("MainWindow", "Crane height"), QCoreApplication.translate("MainWindow", "Maximum skyline length"), QCoreApplication.translate("MainWindow", "Minimum skyline length")]
        for var_name, var_value in zip(zip1, type_cable_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nCarriage properties :\n\n"))
        zip1 =  [QCoreApplication.translate("MainWindow", "Carriage type"), QCoreApplication.translate("MainWindow", "Empty weigth"), QCoreApplication.translate("MainWindow", "Minimum slope for a gravity descent of the carriage"), QCoreApplication.translate("MainWindow", "Maximum slope of the skyline for an uphill yarding"), QCoreApplication.translate("MainWindow", "Maximum slope of the skyline for an downhill yarding")]
        for var_name, var_value in zip(zip1, type_chariot_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nSkyline porperties :\n\n"))
        zip1 = [QCoreApplication.translate("MainWindow", "Diameter"), QCoreApplication.translate("MainWindow", "Skyline self-weight"), QCoreApplication.translate("MainWindow", "Breakdown tensile force"), QCoreApplication.translate("MainWindow", "Young Modulus ( Elasticity)")]
        for var_name, var_value in zip(zip1, propriete_cable_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        zip1 =  [QCoreApplication.translate("MainWindow", "Modeling parameters"), QCoreApplication.translate("MainWindow", "Options"), QCoreApplication.translate("MainWindow", "Cable yarding - Optimization of cable parameters"), QCoreApplication.translate("MainWindow", "Criteria used for optimization")]
        fichier.write(QCoreApplication.translate("MainWindow","\nModeling parameters :\n\n"))
        for var_name, var_value in zip(zip1, param_modelisation_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nOptions :\n\n"))
        zip1 = [QCoreApplication.translate("MainWindow", "Optimize skyline height at intermediate supports and tailspar"), QCoreApplication.translate("MainWindow", "Precision of the modeling")]
        for var_name, var_value in zip(zip1, options_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nCable yarding - Optimization of cable parameters :\n\n"))
        zip1 = [QCoreApplication.translate("MainWindow", "Percentage of volume per hectare taken off"), QCoreApplication.translate("MainWindow", "Re-compute"), QCoreApplication.translate("MainWindow", "Result folder"), QCoreApplication.translate("MainWindow", "Forest file"), QCoreApplication.translate("MainWindow", "Volume per hectare"), QCoreApplication.translate("MainWindow", "Average tree volume"), QCoreApplication.translate("MainWindow", "Lateral yarding distance")]
        for var_name, var_value in zip(zip1, opti_cable_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.write("\n______________________________________________________________________________________")
        fichier.write(QCoreApplication.translate("MainWindow","\nCriteria used for optimization :\n\n"))
        zip1 = [QCoreApplication.translate("MainWindow", "Forest area impacted"), QCoreApplication.translate("MainWindow", "-->Forest area impacted weight"), QCoreApplication.translate("MainWindow", "Number of intermediate supports"), QCoreApplication.translate("MainWindow", "-->Number of intermediate supports weight"), QCoreApplication.translate("MainWindow", "Prefered yarding direction"), QCoreApplication.translate("MainWindow", "-->Prefered yarding direction weight"), QCoreApplication.translate("MainWindow", "Line length"), QCoreApplication.translate("MainWindow", "-->Line length weight"), QCoreApplication.translate("MainWindow", "Total volume per line"), QCoreApplication.translate("MainWindow", "-->Total volume per line weight"), QCoreApplication.translate("MainWindow", "Volume per meter of line"), QCoreApplication.translate("MainWindow", "-->Volume per meter of line weight"), QCoreApplication.translate("MainWindow", "Average tree volume"), QCoreApplication.translate("MainWindow", "-->Average tree volume weight"), QCoreApplication.translate("MainWindow", "Carriage average distance"), QCoreApplication.translate("MainWindow", "-->Carriage average distance weight")]
        for var_name, var_value in zip(zip1, crit_opti_data):
            fichier.write(f"{var_name}: {var_value}\n")

        fichier.close()


#############################
#  _______  __      _______.#
# /  _____||  |    /       |#
#|  |  __  |  |   |   (----`#
#|  | |_ | |  |    \   \    #
#|  |__| | |  | .---)   |   #
# \______| |__| |______/    #
#############################                            


def check_field(filename,fieldname):
    verif=False    
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break    
    source_ds.Destroy() 
    return verif


def check_field_EXIST(filename,fieldname):    
    verif=False
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break
    if verif:
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))      
        nbval = np.unique(vals).shape[0]
        if nbval==1:
            verif=False
    source_ds.Destroy() 
    return verif


def save_raster_info(values,Rspace_c):   
    np.savetxt(Rspace_c+"Area_extent.txt", values, fmt='%f', delimiter=';')


def loadrasterinfo_from_file(Rspace_c):
    values = list(np.loadtxt(Rspace_c+"Area_extent.txt"))
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']    
    ncols = values[0]
    nrows = values[1]
    xmin=values[2]
    ymin = values[3]    
    Csize = values[4] 
    Extent = [xmin,xmin+ncols*Csize,ymin,ymin+nrows*Csize]
    return names,values,Extent


def load_float_raster(raster_file,Dir_temp):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [round(cols,2), round(rows,2), round(xmin,2), round(ymin,2), round(Csize,2),round(nodatavalue,2)]
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    f = open(Dir_temp+'info_extent.txt',"w")
    f.write(head_text)
    f.close()
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array),Extent,Csize,proj 


def load_float_raster_simple(raster_file):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)    
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()    
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array)


def get_source_src(file_name):
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()
    return source_layer.GetSpatialRef()


def shapefile_to_np_array(file_name,Extent,Csize,attribute_name,order_field=None,order=None):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)
    # Get information from source shapefile
    orig_data_source = ogr.Open(file_name)
    source_ds = ogr.GetDriverByName("Memory").CopyDataSource(orig_data_source, "")
    source_layer = source_ds.GetLayer()
    if order:
        source_layer_ordered = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' ORDER BY '+order_field+' '+order)
    else:source_layer_ordered=source_layer
    source_srs = source_layer.GetSpatialRef()
    # Initialize the new memory raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], source_layer_ordered,options=["ATTRIBUTE="+attribute_name,"ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        return mask_arr


def fin_ligne(point_coords):
    fin_ligne = []
    for i in range(point_coords.shape[0]-1):
        ind = np.sum((point_coords[:,0]==point_coords[i,0])*(point_coords[:,1]==point_coords[i,1]))
        if ind ==1:
            if i>0 and i+1<point_coords.shape[0]:
                if point_coords[i-1,2]!=point_coords[i,2] or point_coords[i+1,2]!=point_coords[i,2]:
                    fin_ligne.append(i)
            elif i==0 and point_coords[i+1,2]==point_coords[i,2]:fin_ligne.append(i)
            elif i==point_coords.shape[0]-1 and point_coords[i-1,2]==point_coords[i,2]:fin_ligne.append(i)
    return fin_ligne  


def shapefile_obs_to_np_array(file_list,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Obstacle = np.zeros((nrows,ncols),dtype=np.int16)
    #Loop on all shaefile
    for shp in file_list:        
        # Get shapefile info
        source_ds = ogr.Open(shp)
        ## test
        console_info(f"file_list: {file_list}")
        console_info(f"source_ds: {source_ds}")
        ##
        source_layer = source_ds.GetLayer()    
        source_srs = source_layer.GetSpatialRef()
        source_type = source_layer.GetGeomType()
        # Create copy
        target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
        layerName = os.path.splitext(os.path.split(shp)[1])[0]
        layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
        layerDefinition = layer.GetLayerDefn()
        new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
        layer.CreateField(new_field)
        ind=0
        for feat in source_layer:
            geometry = feat.GetGeometryRef()
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(ind)
            feature.SetField('Transfo',1)
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            feature.Destroy()
            ind +=1
        # Initialize raster
        maskvalue = 1    
        xres=float(Csize)
        yres=float(Csize)
        geotransform=(xmin,xres,0,ymax,0, -yres)         
        target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
        target_ds.SetGeoTransform(geotransform)
        if source_srs:
            # Make the target raster have the same projection as the source
            target_ds.SetProjection(source_srs.ExportToWkt())
        else:
            # Source has no projection (needs GDAL >= 1.7.0 to work)
            target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        # Rasterize
        err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
        if err != 0:
            raise Exception("error rasterizing layer: %s" % err)
        else:
            target_ds.FlushCache()
            mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        Obstacle =+ mask_arr
        target_ds1.Destroy()
        source_ds.Destroy()
    Obstacle = np.int8(Obstacle>0)
    return Obstacle


def get_proj_from_road_network(road_network_file):
    source_ds = ogr.Open(road_network_file)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    return source_srs.ExportToWkt()


def ArrayToGtiff(Array,file_name,Extent,nrows,ncols,road_network_proj,nodata_value,raster_type='INT32'):
    xmin,xmax,ymin,ymax=Extent[0],Extent[1],Extent[2],Extent[3]
    xres=(xmax-xmin)/float(ncols)
    yres=(ymax-ymin)/float(nrows)
    geotransform=(xmin,xres,0,ymax,0, -yres)
    if raster_type=='INT32':
        #-2147483648 to 2147483647
        DataType = gdal.GDT_Int32    
    elif raster_type=='UINT8':
        #0 to 255
        DataType = gdal.GDT_Byte
    elif raster_type=='UINT16':
        #0 to 65535    
        DataType = gdal.GDT_UInt16
    elif raster_type=='INT16':
        #-32768 to 32767 
        DataType = gdal.GDT_Int16
    elif raster_type=='FLOAT32':
        #Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
        DataType = gdal.GDT_Float32
    elif raster_type=='FLOAT16':
        #Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
        DataType = gdal.GDT_Float16
    target_ds = gdal.GetDriverByName('GTiff').Create(file_name+'.tif', int(ncols), int(nrows), 1, DataType)
    target_ds.SetGeoTransform(geotransform)
    target_ds.SetProjection(road_network_proj)
    target_ds.GetRasterBand(1).WriteArray( Array )
    target_ds.GetRasterBand(1).SetNoDataValue(nodata_value)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache()


def crop_to_main_dtm_size(raster_file, main_raster_file):
    try:
        # Call the R function
        cropped_raster = robjects.r.crop_to_main_dtm_size(raster_file, main_raster_file)
        
        # Convert the output to a DataFrame
        cropped_df = pandas2ri.ri2py_dataframe(cropped_raster)
        
        # Pass the output through console_info
        console_info(str(cropped_df))
        
        return cropped_df
    except Exception as e:
        err = QCoreApplication.translate("MainWindow","Error: ") + str(e)
        console_info(err)



####################################################
#  ______     ___      .______    __       _______ #
# /      |   /   \     |   _  \  |  |     |   ____|#
#|  ,----'  /  ^  \    |  |_)  | |  |     |  |__   #
#|  |      /  /_\  \   |   _  <  |  |     |   __|  #
#|  `----./  _____  \  |  |_)  | |  `----.|  |____ #
# \______/__/     \__\ |______/  |_______||_______|#
####################################################
 
                                                  
# Fonctions qui gère les calculs liés au cable
def Cable():
    ##test
    console_info("Cable")
    ##
    Wspace,_,file_MNT,file_shp_Foret,_,file_shp_Cable_dep,_,_,_,Dir_Obs_cable,file_Htree,file_Vol_AM,file_Vol_ha = Sylvaccess_UI.get_spatial_cls()
    _,_,_,_,Pente_max_bucheron = Sylvaccess_UI.get_general_cls()
    Cable_type,sup_max,Htower,Lmax,Lmin=Sylvaccess_UI.get_type_cable_cls()
    Carriage_type,Pchar,slope_grav,slope_Wliner_up,slope_Wliner_down = Sylvaccess_UI.get_type_chariot_cls()
    d,masse_li,rupt_res,E = Sylvaccess_UI.get_proprietes_cable_cls()
    Hintsup,Hend,Hline_min,Hline_max,Lhor_max,Load_max,safe_fact = Sylvaccess_UI.get_param_modelisation_cls()
    test_cable_optimise,precision = Sylvaccess_UI.get_options_cls()
    prelevement, _, _, _, _, _, _ = Sylvaccess_UI.get_opti_cable_cls()
    surface, surface_poids, nbr_sup_int, nbr_sup_int_poids, sens_debardage, sens_debardage_poids, longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_UI.get_crit_opti_cls()

    masse_li2 = 0.5
    masse_li3 = 0.5
    LminSpan = 50
    Max_angle = 30
    coeff_frot = 0.15
    angle_transv = 60
    slope_trans = 30
    Lslope = 75
    PropSlope = 0.15
    VariaH = 0
    lim_list = [surface, nbr_sup_int, sens_debardage, longueure_ligne, vol_ligne, indice_prelev, VAM, dist_chariot]
    w_list = [surface_poids, nbr_sup_int_poids, sens_debardage_poids, longueure_ligne_poids, vol_ligne_poids, indice_prelev_poids, VAM_poids, dist_chariot_poids]

    
    Hdebut = datetime.datetime.now()
    Dir_temp = Wspace+"Temp/"  
    ### Check if temporary files have been generated and have the same extent
    try:
        _,values,proj,Extent = raster_get_info(file_MNT)
        Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    except:
        txt = QCoreApplication.translate("MainWindow", "Error: please define a projection for DTM raster")
        console_warning(txt)
        Sylvaccess_UI.close()
        return ""
    try: 
        _,v1=read_info(Dir_temp+'info_extent.txt')
        for i,item in enumerate(values):
            if v1[i]!=round(item,2):
                prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable)
            if i+1>4:break
    except:
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable)
    
    # Inputs
    try:
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))                
        MNT= np.load(Dir_temp+"MNT.npy") 
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy") 
        try:
            Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        except:
            Aspect = np.uint16(exposition(MNT,Csize,-9999))    
        try:
            CoordRoute= np.load(Dir_temp+"CoordRoute.npy") 
        except:
            TableX,TableY=create_coord_pixel_center_raster(values,nrows,ncols,Csize,Dir_temp)
            CoordRoute = np.zeros((Lien_RF.shape[0],2),dtype=np.float32)
            for i,pixel in enumerate(Lien_RF):
                CoordRoute[i,0]=TableX[pixel[1]]
                CoordRoute[i,1]=TableY[pixel[0]] 
            np.save(Dir_temp+"CoordRoute.npy",CoordRoute) 
            del TableX,TableY
        try:
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
        except:
            Pente = np.uint16(prepa_obstacle_cable(Dir_Obs_cable,file_MNT,Dir_temp))
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
    except: 
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable)
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))
        Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))         
        MNT= np.load(Dir_temp+"MNT.npy") 
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy")  
        CoordRoute= np.load(Dir_temp+"CoordRoute.npy")
        Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)    

    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    
     
    ### Import optional files
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
        Vol_ha[Pente>Pente_max_bucheron]=0 
        test_vp = True
    else:test_vp = False
    if file_Vol_AM != "":
        Vol_AM = load_float_raster_simple(file_Vol_AM) 
        Vol_AM[Pente>Pente_max_bucheron]=0
        test_vam = True
    else:test_vam = False 
    if file_Htree != "":
        Hfor = load_float_raster_simple(file_Htree) 
        test_hfor = True
    else:
        Hfor=0
        test_hfor = False
    if test_vp or test_vam:
        if not test_vp:
            Vol_ha = np.zeros_like(MNT)
        if not test_vam:
            Vol_AM = np.zeros_like(MNT)


    Lmax2 = round(Lmax-(sqrt(2)*(max(np.max(Hfor)*0.6666,Hend)+5)),0) #In order to take into account anchorage
    Row_line,Col_line,D_line,Nbpix_line, Row_ext,Col_ext,D_ext,Dir_list=create_buffer(Csize,Lmax2,Lhor_max)    
    road_network_proj=get_proj_from_road_network(file_shp_Cable_dep)
    Skid_direction = 0
    Rspace_c,_,slope_min_up,slope_max_up,slope_min_down,slope_max_down=get_cable_configs(slope_Wliner_up,slope_Wliner_down,slope_grav,Skid_direction) 
    try:os.mkdir(Rspace_c)
    except:pass
    Rspace_c+="/"
    Rspace_sel = Rspace_c+"FilesForOptimisation"
    try:os.mkdir(Rspace_sel)
    except:pass
    Rspace_sel+="/"
    save_raster_info(values,Rspace_sel)
    ### Calculation of useful variables
    g = 9.80665     # m.s-2
    angle_intsup = radians(Max_angle) 
    Fo =  g*(Load_max+Pchar)
    Lsans_foret = min(Lmax*0.1,Lmin)          # Longueur max contigue sans foret
    Ao = 0.25*pi*(d**2) 
    Tmax = float(rupt_res)*g/float(safe_fact)
    EAo = E*Ao
    idLinemin = np.max([1,int(LminSpan/Csize+1.5),int(10/Csize+0.5)])
    
    # D H diag slope fact indmin indmax LoL ThL TvL TupL TdownL LoUg ThUg TvUg ind_fin_span free xmidL zmidL 
    # 0 1 2    3     4    5      6      7   8   9   10   11     12   13   14   15           16   17    18  
    Span = np.zeros((sup_max+1,16),dtype=np.float32)
    rastLosup,rastTh,rastTv= check_tabconv(Dir_temp,d,E,Tmax,Lmax2,Fo,masse_li,masse_li2,masse_li3,Csize)    
    
    ### Preparation of forest roads
    nbconfig = 5       
    if precision > 1:Dir_list = range(0,360,2)
    if precision == 3:
        step_route = 2
        nbconfig = 1       
    else:
        step_route = 1
    nb_pixel_route = int((Lien_RF.shape[0]-1)/float(step_route))    
    
    Fin_ligne_forcee = np.int8(np.greater(Aerian_obs+(MNT<0),0))
    
    txt = QCoreApplication.translate("MainWindow", "    -Initialization performed, start of processing...")
    console_info("\n" + txt)
    str_nb_pixel_route=  " / "+str(nb_pixel_route-1)+ " processed pixels"
    
    Tab = np.zeros((min(1000000,int(nb_pixel_route*(360)/step_route)),18+5*sup_max),dtype=np.int16)
    File_Tab = []
    Tab_nb=0
    
    testExist = False
    if np.sum(Lien_RF[:,2]==1)>0:
        testExist = True
    
    ##############################################################################################################################################
    ### 2. PROCESSING OF THE AREA: TEST ALL POSSIBLE LINES
    ##############################################################################################################################################
    
    # Loop on forest road pixels
    Route = range(1,Lien_RF.shape[0]-1,step_route)
    id_line = 0
    Rast_couv = np.zeros((nrows,ncols),dtype=np.int8)
    if testExist:
        Rast_couv2 = np.zeros((nrows,ncols),dtype=np.int8)
    test=0
    for idpix,pixel in enumerate(Route):  
        # console_info process
        sys.stdout.write("\r%d" % idpix + str_nb_pixel_route)
        sys.stdout.flush()
        #Get point coordinates
        coordY = Lien_RF[pixel,0]
        coordX = Lien_RF[pixel,1]
        direction = Lien_RF[pixel,4]
        if MNT[coordY,coordX]>-9999 and not Aerian_obs[coordY,coordX]:             
            RoadState = Lien_RF[pixel,2]
            posiY = CoordRoute[pixel,1]
            posiX = CoordRoute[pixel,0]   
            for az in Dir_list:                                          
                test,Lline,Line = get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax2,Lmin,Csize,
                                             Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
                                             Fo,Tmax,masse_li,masse_li2,masse_li3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope)   
                if test==1:           
                    Span*=0    
                    Falt = InterpolatedUnivariateSpline(Line[:,0],Line[:,1])
                    Alts = Falt(np.arange(0.,Lline,0.5))
                    ### Optimize line
                    if Line[0,1]+Htower>=np.max(Line[idLinemin:,1])+Hend:   
                        if direction==2:
                            continue
                        #console_info az,"up",Line[-1,0] 
                        if VariaH:
                            Span = OptPyl_Up(Line,Alts,Span,Htower,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,
                                                 Csize,angle_intsup,EAo,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                 LminSpan,slope_min_up,slope_max_up,test_hfor,nbconfig)
                        else:
                            Span = OptPyl_Up_NoH(Line,Alts,Span,Htower,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,
                                                     Csize,angle_intsup,EAo,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                     LminSpan,slope_min_up,slope_max_up,test_hfor,nbconfig)
                        config = 1
                    else:    
                        if direction==1:
                            continue
                        #console_info az,"down",Line[-1,0]
                        if VariaH:
                            Span = OptPyl_Down_init(Line,Alts,Span,Htower, Hend,masse_li,masse_li2,masse_li3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo, 
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,test_hfor)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = OptPyl_Down(Line2,Alts,Span*0,Htower,Hintsup,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,Csize,angle_intsup,
                                                   EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan, min(-slope_min_down,-slope_max_down),
                                                   max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                        else:
                            Span = OptPyl_Down_init_NoH(Line,Alts,Span,Htower, Hend,masse_li,masse_li2,masse_li3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo,
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,test_hfor,nbconfig)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = OptPyl_Down_NoH(Line2,Alts,Span*0,Htower,Hintsup,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,Csize,
                                                       angle_intsup,EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,min(-slope_min_down,-slope_max_down),
                                                       max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                    ind_max_Line = int(np.max(Span[:,15]))                    
                    if Span[0,0]==0 or np.sum(Span[:,2])<Lmin or Line[ind_max_Line,8]==0:
                        test=0
                        continue                    
                    nbintsup = np.sum(Span[:,0]>0)-1
                    ### Save Line carac
                    Line = Line[0:ind_max_Line+1]
                    Lline = Line[ind_max_Line,0]                    
                    if test_vp or test_vam:    
                        if RoadState==2:
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv = get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv,Vol_ha,Vol_AM)
                        else: 
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv2 = get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2,Vol_ha,Vol_AM)
                    else:
                        if RoadState==2:
                            Distance_moyenne,Surface,Rast_couv = get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv)
                        else:
                            Distance_moyenne,Surface,Rast_couv2 = get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2)
                    #pixel, direction
                    Tab[id_line,0],Tab[id_line,1] = pixel,az
                    #Xstart,Ystart,Zstart,Hcable_start
                    Tab[id_line,2],Tab[id_line,3],Tab[id_line,4],Tab[id_line,5]=Line[0,3],Line[0,4],Line[0,1],Htower
                    #Xend,Yend,Zend,Hcable_end
                    Tab[id_line,6],Tab[id_line,7],Tab[id_line,8],Tab[id_line,9] = Line[ind_max_Line,3],Line[ind_max_Line,4],Line[ind_max_Line,1],Span[nbintsup,14]
                    #Road existing or not,Ltot,Config
                    Tab[id_line,10],Tab[id_line,11],Tab[id_line,12] = int(RoadState),int(np.sum(Span[:,2])+0.5),config
                    #Surface foret Dmoy chariot
                    Tab[id_line,13],Tab[id_line,14]=Surface,Distance_moyenne
                    #Vtot IPC
                    if test_vp:
                        Tab[id_line,15]=Vtot
                    #VAM               
                    if test_vam:
                        Tab[id_line,16]=VAM*10
                    #Int sup info  
                    Tab[id_line,17]=nbintsup
                    for pyl in range(0,nbintsup):
                        Tab[id_line,18+5*pyl]=Line[int(Span[pyl,15]),3]#X
                        Tab[id_line,19+5*pyl]=Line[int(Span[pyl,15]),4]#Y
                        Tab[id_line,20+5*pyl]=Line[int(Span[pyl,15]),1]#Alts
                        Tab[id_line,21+5*pyl]=Span[pyl,14]#Hcable
                        Tab[id_line,22+5*pyl]=atan(abs(Span[pyl,3]-Span[pyl+1,3]))*Span[pyl,10]+Fo#Press
                    id_line+=1
                    if id_line == 1000000:                        
                        np.save(Dir_temp+"Tab"+str(Tab_nb)+".npy",Tab[Tab[:,11]>0])
                        File_Tab.append(Dir_temp+"Tab"+str(Tab_nb)+".npy")
                        Tab_nb +=1
                        id_line=0
                        Tab = np.zeros((1000000,18+5*sup_max),dtype=np.int16)

    txt = QCoreApplication.translate("MainWindow", "    -Processing completed, start of results saving...")
    console_info("\n    - Saving of results")
   
    ### Save Forest,Vol_ha,VolAm,Pente
    np.save(Rspace_sel+"Forest.npy",Forest)
    if test_vp:
        np.save(Rspace_sel+"Vol_ha.npy",Vol_ha)
    if test_vam:
        np.save(Rspace_sel+"Vol_AM.npy",Vol_AM)
    np.save(Rspace_sel+"Pente.npy" ,Pente)
    np.save(Rspace_sel+"Lien_RF_c.npy",Lien_RF)
    ### Del useless    
    try:
        del Line2
    except:
        pass
    del rastLosup,rastTh,rastTv,Row_line,Col_line,D_line,Nbpix_line,CoordRoute,Aerian_obs,Lien_RF
    gc.collect()
    ### Save results
    Tab = Tab[Tab[:,11]>0]
    if Tab_nb>0:
        for files in File_Tab:
            Tabbis = np.load(files)
            Tab = np.concatenate((Tab,Tabbis))
    np.save(Rspace_sel+"Tab_all_lines.npy",Tab)    
    
    if testExist :        
        Rast_couv += 10*Rast_couv2
        Rast_couv[Rast_couv==11]=2
        Rast_couv[Rast_couv==1]=2
        Rast_couv[Rast_couv==10]=1
    
    if not test_vp:
        Vol_ha=np.zeros_like(MNT)    
    else:
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
    generate_info_cable_simu(Rspace_c,Tab,Rast_couv,Vol_ha,Csize,Forest,Pente,Pente_max_bucheron)
    
    ### Del useless   
    del Forest,Pente,Line,Alts,Span,MNT,Fin_ligne_forcee,Aspect,Falt
    try:
        del Vol_ha,Vol_AM,Rast_couv2 
    except:
        pass
    
    #Save Global res        
    header = QCoreApplication.translate("MainWindow",'ID_pixel Azimuth X_Start Y_Start Elevation_Start Hcable_Start X_End Y_End Elevation_End Hcable_End ',)
    header += QCoreApplication.translate("MainWindow",'Existing_road Cable_length Configuration ')
    header += QCoreApplication.translate("MainWindow",'Forest_area Carriage_average_distance Volume_total ATV NB_int_sup')
    for num in range(1, sup_max + 1):
        header += ' ' + QCoreApplication.translate("MainWindow",'Xcoord_intsup') + str(num) + ' ' + QCoreApplication.translate("MainWindow",'Ycoord_intsup') + str(num) + ' ' + QCoreApplication.translate("MainWindow",'Alt_intsup') + str(num)
        header += ' ' + QCoreApplication.translate("MainWindow",'Hcable_intsup') + str(num) + ' ' + QCoreApplication.translate("MainWindow",'Pression_intsup') + str(num)
    filename=Rspace_c+"Database_all_lines.gzip"
    shape_name = Rspace_c+"All_the_lines.shp"
    rast_name = Rspace_c+'Zone_accessible'
            
    
    ArrayToGtiff(Rast_couv,rast_name,Extent,nrows,ncols,road_network_proj,0,'UINT8')
    header+='\n'
    save_integer_ascii(filename,header,Tab)
    source_src=get_source_src(file_shp_Cable_dep) 
    Line_to_shapefile(Tab[0:2],Rspace_sel+"info_proj.shp",source_src,0)
    if Tab.shape[0]<1000000:         
        Line_to_shapefile(Tab,shape_name,source_src,prelevement)
    
    ##############################################################################################################################################
    ### 3. CREATE SIMULATION PARAMETER FILE
    ##############################################################################################################################################
    str_duree,str_fin,str_debut=heures(Hdebut)
    
    if Carriage_type == 1:
        carriage_name = QCoreApplication.translate("MainWindow",'self-propelled')
    else:
        carriage_name = QCoreApplication.translate("MainWindow",'Classic')
    if Cable_type < 3:
        cable_name = QCoreApplication.translate("MainWindow",'Cable mat')
    else:
        cable_name = QCoreApplication.translate("MainWindow",'Long/conventional cable')

    file_name = str(Rspace_c) + 'Parametre_simulation.txt'
    resume_texte = QCoreApplication.translate("MainWindow",'SYLVACCESS - CABLE\n\n\n')
    version = "1.0.0"
    date = "02/06/2024"
    resume_texte += QCoreApplication.translate("MainWindow","Plugin's version: ") + version + QCoreApplication.translate("MainWindow","from ") + date + "\n"
    resume_texte += QCoreApplication.translate("MainWindow",'Author: Sylvain DUPIRE. Irstea\n\n')
    resume_texte += QCoreApplication.translate("MainWindow",'Date and time when launching the script:                          ') + str_debut + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'Date and time at the end of the script execution                           ') + str_fin + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'Total execution time of the script:                                         ') + str_duree + '\n\n'
    resume_texte += QCoreApplication.translate("MainWindow",'PROPERTIES OF THE MATERIAL:\n')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Type of machine:                                                      ') + str(cable_name) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Height of mat or cable Forwarder at the depot place:    ') + str(Htower) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum number of intermediate support:                        ') + str(sup_max) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum length of the Forwarder cable:                                    ') + str(Lmax) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Minimum length of a line:                                        ') + str(Lmin) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Minimum length between two supports:                                ') + str(LminSpan) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Trolley type:                                                      ') + str(carriage_name) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Empty mass of the trolley:                                              ') + str(Pchar) + ' kg\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum mass of load:                                          ') + str(Load_max) + ' kg\n'
    if Carriage_type == 1:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Max slope of the Forwarder cable for uphill unloading:            ') + str(slope_Wliner_up) + ' %\n'
        resume_texte += QCoreApplication.translate("MainWindow",'   - Max slope of the Forwarder cable for downhill unloading:             ') + str(slope_Wliner_down) + ' %\n'
    else:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Min slope of the Forwarder cable for the trolley to climb down:  ') + str(slope_grav) + ' %\n'
    resume_texte += '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'PROPERTIES OF THE FORWARDER CABLE :\n')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Diameter of the Forwarder cable:                                            ') + str(d) + ' mm\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Line mass of the Forwarder cable:                                      ') + str(masse_li) + ' kg.m-1\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Young’s Module (Elasticity):                                         ') + str(E) + ' N.mm-2\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Breaking tension of the Forwarder cable                                   ') + str(rupt_res) + ' kgF\n\n'
    if Carriage_type != 1:
        resume_texte += QCoreApplication.translate("MainWindow",'TRACTOR AND RETURN CABLE PROPERTIES:\n')
        resume_texte += QCoreApplication.translate("MainWindow",'   - Line mass of the tractor cable:                                     ') + str(masse_li2) + ' kg.m-1\n'
        resume_texte += QCoreApplication.translate("MainWindow",'   - Line mass of the return cable:                                       ') + str(masse_li3) + ' kg.m-1\n'
        resume_texte += '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'MODELISATION PARAMETERS:\n')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Lateral distance of wood pitching:                                ') + str(Lhor_max) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Height of Forwarder cable at intermediate pylons:          ') + str(Hintsup) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Forwarder cable height at end of line:                             ') + str(Hend) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Minimum cable height at any point (load):                  ') + str(Hline_min) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum cable height at any point:                              ') + str(Hline_max) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Maximum angle of the Forwarder cable at an intermediate pylon:   ') + str(Max_angle) + ' degres\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Security factor:                                                  ') + str(safe_fact) + '\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Value of the friction angle:                                      ') + str(coeff_frot) + ' rad\n\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - DTM resolution:                                              ') + str(Csize) + ' m\n'
    resume_texte += QCoreApplication.translate("MainWindow",'   - Standing volume harvesting applied:                              ') + str(prelevement * 100) + ' %\n'
    try:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Projection:                                                           ') + str(proj.GetAttrValue("PROJCS", 0)) + '\n'
    except:
        resume_texte += QCoreApplication.translate("MainWindow",'   - Projection:                                                           unknown\n')
    if Dir_Obs_cable == "":
        reponse = QCoreApplication.translate("MainWindow",'No')
    else:
        reponse = QCoreApplication.translate("MainWindow",'Yes')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Consideration of obstacle for the cable:                             ') + str(reponse) + '\n'
    if file_Vol_ha == "":
        reponse = QCoreApplication.translate("MainWindow",'No')
    else:
        reponse = QCoreApplication.translate("MainWindow",'Yes')
    resume_texte += QCoreApplication.translate("MainWindow",'   - Information on the volume of wood provided as input:                  ') + str(reponse) + '\n'

    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()

    file_name = Rspace_sel + 'info_Lhormax.txt'
    fichier = open(file_name, "w")
    fichier.write(str(Lhor_max))
    fichier.close()

    console_info(QCoreApplication.translate("MainWindow",'\nAll possible lines have been tested.\n'))  
    ##############################################################################################################################################
    ### 4. SELECTION OF BEST LINE IF CHECKED
    ##############################################################################################################################################
    if test_cable_optimise:
        line_selection(Rspace_c,w_list,lim_list,0,file_shp_Foret,file_Vol_ha,file_Vol_AM,Lhor_max,prelevement,Pente_max_bucheron)


def prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize):
    rastLosup,rastTh,rastTv = Tabmesh(d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)
    np.save(Dir_temp+"rastLosup.npy",rastLosup)
    np.save(Dir_temp+"rastTh.npy",rastTh)
    np.save(Dir_temp+"rastTv.npy",rastTv)
    text  = "d    "+" "+str(round(d,2))+"\n"
    text += "E    "+" "+str(round(E,2))+"\n"
    text += "Tmax "+" "+str(round(Tmax,2))+"\n"
    text += "Lmax "+" "+str(round(Lmax,2))+"\n"
    text += "Fo   "+" "+str(round(Fo,2))+"\n"
    text += "Csize"+" "+str(round(Csize,2))+"\n"
    text += "masse_li   "+" "+str(round(masse_li,2))+"\n"
    text += "masse_li2   "+" "+str(round(masse_li2,2))+"\n"
    text += "masse_li3   "+" "+str(round(masse_li3,2))+"\n"
    f = open(Dir_temp+'info_config.txt',"w")
    f.write(text)
    f.close()
    return rastLosup,rastTh,rastTv


def check_tabconv(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize):
    try:
        _,v1=read_info(Dir_temp+"info_config.txt")
        if np.all(np.array([round(d,2),round(E,2),round(Tmax,2),round(Lmax,2),round(Fo,2),round(Csize,2),round(masse_li,2),round(masse_li2,2),round(masse_li3,2)])==v1):
            rastLosup = np.load(Dir_temp+"rastLosup.npy")
            rastTh = np.load(Dir_temp+"rastTh.npy")
            rastTv = np.load(Dir_temp+"rastTv.npy")
        else:
            rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)
    except:
        rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)        
    return rastLosup,rastTh,rastTv


def check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret):
    indmax = 0
    npix = Line.shape[0]
    test = 1
    i=0
    Dsansforet=0.
    for i in range(0,npix): 
        if Line[i,5]<0:break
        if Line[i,5]>=ncols:break
        if Line[i,6]<0:break
        if Line[i,6]>=nrows:break
        if Line[i,7]==1:break
        if sqrt(Line[i,0]*Line[i,0]+(Line[i,1]-Line[0,1])*(Line[i,1]-Line[0,1]))>Lmax:break        
        if (Line[i,8]+Line[i,9])>0:                 
            if Line[i,2]==1:
                indmax = i 
                Dsansforet=0
            else:
                if i>0: Dsansforet+=Line[i,0]-Line[i-1,0]
                if Dsansforet>=Lsans_foret:break
        else:        
            break
    Lline = Line[indmax,0]
    if Lline <= Lmin:
        test=0
    return test,indmax+1,Lline


def get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
              Fo,Tmax,masse_li,masse_li2,masse_li3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope):
                  
    npix = Nbpix_line[az]
    npix = get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,11),dtype=np.float32)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        ### Check pente en devers
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1 
        if test_hfor:
            Line[:,10]=np.round(np.minimum(np.maximum(-7.76961+0.71858*Hfor[inds],0),26))
        else:
            Line[:,10]=Hintsup
        ####Raccourci pour ne pas depasser Hline_max
        indmax=Line.shape[0]-1
        for i in range(indmax,1,-1):  
            test=1
            D = Line[i,0]
            H = abs(Line[0,1]+Htower-(Line[i,1]+Hend))    
            if Line[0,1]+Htower>=Line[i,1]+Hend:
                Xup,Zup =0,Line[0,1]+Htower
                fact = 1. 
            else:    
                Xup,Zup = Line[i,0],Line[i,1]+Hend
                fact = -1.             
            L=sqrt(H*H+D*D)
            F = 0.5*(0.5*L*masse_li2+0.5*L*masse_li3)*9.80665 + Fo  
            fleche = 1.1*(F*L/(4*Tmax)+masse_li*9.80665*L*L/(8*Tmax))
            for j in range(1,i-1):
                droite = -fact*H/D*(Line[j,0]-Xup)+Zup-Line[j,1]
                if droite-fleche > Hline_max:
                    test=0
                    break
            if test:
                break
        Line=Line[0:i+1]
        test,indmax,Lline=check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret,Lslope,PropSlope)
        Lline = 2 # A modifier    
        return test,Lline,Line[0:indmax, [0, 1, 2, 3, 4, 5, 6,10,9]]
    else:
        return 0,0,0 


def return_profile(Line):
    Line2 = np.zeros_like(Line)
    indmax = Line.shape[0]-1
    Dmax =Line[indmax,0]
    for i,j in enumerate(range(indmax,-1,-1)):
        Line2[i]=Line[j]
        Line2[i,0]=Dmax-Line[j,0]
    return Line2


def azimuth(X0,Y0,X1,Y1):
    dX=abs(X0-X1)
    dY=abs(Y0-Y1)
    #cas 1:cadran en haut a droite
    if (X1>X0) and (Y1>Y0):
        az=degrees(atan(dX*1.0/dY))
    #cas 2:cadran en bas a droite
    elif (X1>X0) and (Y1<Y0):
        az=180-degrees(atan(dX*1.0/dY))
    #cas 3:cadran en haut a gauche
    elif (X1<X0) and (Y1>Y0):
        az=360-degrees(atan(dX*1.0/dY)) 
    #cas 4:cadran en bas a gauche
    elif (X1<X0) and (Y1<Y0):
        az=180+degrees(atan(dX*1.0/dY)) 
    #cas 5:horizontal gauche
    elif (dY==0) and (X1>X0):
        az=90
    #cas 6:horizontal droite
    elif (dY==0) and (X1<X0):
        az=90*3
    #cas 7:vertical haut
    elif (Y1>=Y0) and (dX==0):
        az=0
    #cas 8:vertical bas
    elif (Y1<Y0) and (dX==0):
        az=180
    return az


def from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az):    
    X1 = sin(radians(az))*Lmax
    Y1 = cos(radians(az))*Lmax
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    line = ogr.Geometry(ogr.wkbLineString)
    line.AddPoint(0,0)
    line.AddPoint(X1,Y1)
    feature = ogr.Feature(layerDefinition)
    feature.SetGeometry(line)
    feature.SetFID(az)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return X1,Y1,mask_arr


def pt_emprise(X0,Y0,X1,Y1,Lhor_max):
    az=azimuth(X0,Y0,X1,Y1)
    #deb + 90
    X = [X0+sin(radians(az+90))*Lhor_max]
    Y = [Y0+cos(radians(az+90))*Lhor_max]
    #deb - 90
    X.append(X0+sin(radians(az-90))*Lhor_max)
    Y.append(Y0+cos(radians(az-90))*Lhor_max)
    #fin - 90
    X.append(X1+sin(radians(az-90))*Lhor_max)
    Y.append(Y1+cos(radians(az-90))*Lhor_max)
    #fin + 90
    X.append(X1+sin(radians(az+90))*Lhor_max)
    Y.append(Y1+cos(radians(az+90))*Lhor_max)
    return [X,Y] 


def point_line_to_line_ext(X0,Y0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize):
    ### Create mask_array
    X,Y = pt_emprise(X0,Y0,X1,Y1,Lhor_max)
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbPolygon)
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    # create polygon object:
    myRing = ogr.Geometry(ogr.wkbLinearRing)
    for i in range(0,len(X)):
        myRing.AddPoint(X[i],Y[i])
    myRing.AddPoint(X[0],Y[0])#close ring
    poly = ogr.Geometry(type=ogr.wkbPolygon)
    poly.AddGeometry(myRing)
    feature = ogr.Feature( layer.GetLayerDefn() )
    feature.SetGeometry(poly)
    feature.SetFID(1)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return mask_arr


def get_car_dist(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        _ ,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
    return mat


def get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        distance,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
        mat[i,3]=distance
    return mat


def ligh_line(mat,Dmin):
    mat[0,3]=1
    for i in range(1,mat.shape[0]):
        if (mat[i,2]-mat[i-1,2])>Dmin:
            mat[i,3]=1
    return mat[mat[:,3]>0]


def create_buffer(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float32)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float32)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+1))
        mat[:,:-1] = inds
        mat = get_car_dist(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],Dir_list


def create_buffer2(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float32)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float32)*-1
    D_lat = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float32)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+2))
        mat[:,:-2] = inds
        mat= get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))               
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        D_lat[az,0:nb_pix]=mat[ind,3]*Csize
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],D_lat[:,0:Nbpix_ext],Dir_list


def Line_to_shapefile(Tab,Cable_line_Path,source_src,prelevement,language):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    fieldvol = 'Volume_'+str(int(100*prelevement))
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xstart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ystart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Yend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Id_route', ogr.OFTInteger)
    layer.CreateField(new_field)
    if language=='FR':
        new_field = ogr.FieldDefn('Desserte', ogr.OFTString) 
        
    else:
        new_field = ogr.FieldDefn('Road', ogr.OFTString)                              
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AzimuthDeg', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Long', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Config', ogr.OFTString)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('NbIntSup', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Surface', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn(fieldvol, ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('IPC', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Dmoy', ogr.OFTInteger)
    layer.CreateField(new_field)
    cneg = "Skidding downhill"
    cpos = "Skidding uphill"
    proj = "In project"
    exis = "Existing"

    
    for ind,S in enumerate(Tab):
        line = ogr.Geometry(ogr.wkbLineString)
        line.AddPoint(float(S[2]),float(S[3]))
        line.AddPoint(float(S[6]),float(S[7]))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('IdLine',ind+1)
        feature.SetField('Xstart',float(S[2]))
        feature.SetField('Ystart',float(S[3]))
        feature.SetField('Xend',float(S[6]))
        feature.SetField('Yend',float(S[7]))
        if int(S[10])==2: 
            feature.SetField('Desserte',exis)
        else:
            feature.SetField('Desserte',proj)
        feature.SetField('Id_route',int(S[0]))
        feature.SetField('AzimuthDeg',int(S[1]))
        feature.SetField('Long',int(S[11]))
        if int(S[12])>0:
            feature.SetField('Config',cpos)
        else:
            feature.SetField('Config',cneg)
        feature.SetField('NbIntSup',int(S[17]))
        feature.SetField('Surface',S[13]/10000.)
        feature.SetField('Dmoy',int(S[14]))
        feature.SetField(fieldvol,int(S[15]*prelevement))
        feature.SetField('IPC',S[15]*prelevement/float(S[11]))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
    target_ds.Destroy()


def Pylone_in_shapefile(Tab,Cable_line_Path,source_src):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]    
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xpyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ypyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Altitude', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Hcable', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pression', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pyl_pos', ogr.OFTInteger)
    layer.CreateField(new_field)
    idi = 0
    for ind,S in enumerate(Tab):
        nb=1
        for pyl in range(int(S[17])):  
            point = ogr.Geometry(ogr.wkbPoint)
            point.SetPoint(0, float(S[18+5*pyl]),float(S[19+5*pyl]))         
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(point)
            feature.SetFID(idi)
            feature.SetField('IdLine',ind+1)
            feature.SetField('Xpyl',float(S[18+5*pyl]))
            feature.SetField('Ypyl',float(S[19+5*pyl]))
            feature.SetField('Altitude',float(S[20+5*pyl]))
            feature.SetField('Hcable',float(S[21+5*pyl]))
            feature.SetField('Pression',float(S[22+5*pyl]))
            feature.SetField('Pyl_pos',int(nb)             )    
            layer.CreateFeature(feature)
            point.Destroy()
            feature.Destroy()
            idi+=1
            nb+=1
    target_ds.Destroy()


def create_coord_pixel_center_raster(values,nline,ncol,Csize,Dir_temp):
    Xcoord = np.zeros((ncol),dtype=np.float32)
    Ycoord = np.zeros((nline),dtype=np.float32)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    np.save(Dir_temp+'TableX.npy',Xcoord)
    np.save(Dir_temp+'TableY.npy',Ycoord)
    return Xcoord,Ycoord


# Create raster of obstacles from directory containing shapefiles 
def prepa_obstacle_cable(Obstacles_directory,file_MNT,Dir_temp):
    ### Creation d'un repertoire temporaire       
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize= values[4]
    MNT = read_raster(file_MNT)
    MNT[MNT==values[5]]=-9999
    Pente = pente(np.float_(MNT),Csize,-9999)     
    if Obstacles_directory!="":
        liste_file = os.listdir(Obstacles_directory)
        liste_obs = [] 
        for files in liste_file:
            if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
        if len(liste_obs)>0:
            Obstacles_cable = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)
    else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)    
    Obstacles_cable[MNT==-9999]=1
    values[5]=-9999
    np.save(Dir_temp+'Obstacles_cables.npy',np.int8(Obstacles_cable))
    gc.collect()  
    return Pente


def get_cable_configs(slope_Wliner_up,slope_Wliner_down,slope_grav,Skid_direction):
    #Get folder
    _,Rspace,_,_,_,_,_,_,_,_,_,_,_ = Sylvaccess_UI.get_spatial_cls()
    dirs = [d for d in os.listdir(Rspace) if os.path.isdir(os.path.join(Rspace, d))]
    list_dir = []
    
    for dire in dirs:
        if dire[:5]=='Cable':
            list_dir.append(dire)

    optnum = len(list_dir)+1
    Rspace_c=Rspace+'Cable_'+str(optnum)        
    filename = Rspace_c+"/"
    Cable_type,_,_,_,_ = Sylvaccess_UI.get_type_cable_cls()
    filename += str(Cable_type)
    Carriage_type,_,_,_,_ = Sylvaccess_UI.get_type_chariot_cls()
    filename += "_"+str(Carriage_type)
    
    if Skid_direction ==0:
        filename += "_uphill&downhill"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1        
    
    elif Skid_direction ==1:
        filename += "_uphill"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = 0
        slope_min_down = 0
    
    else:
        filename += "_downhill"
        slope_min_up = 0
        slope_max_up = 0
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1 
    
    if Cable_type == "Long cable":
        if Skid_direction ==0:
            filename += "_uphill&downhill"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01) 
   
        elif Skid_direction ==1:
            filename += "_uphill"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0
 
        else:
            filename += "_downhill"
            slope_min_up = 0
            slope_max_up = 0
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01)             
    else: 
        
        if Skid_direction ==0:
            filename+= "_uphill&downhill"
            slope_min_up = -1.4
            slope_max_up = 0.1
            slope_min_down = -0.1
            slope_max_down = 1.4
        
        elif Skid_direction ==1:
            filename += "_uphill"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0 
        
        else:
            filename += "_downhill"
            slope_min_up = 0
            slope_max_up = 0
            slope_min_down = -0.1
            slope_max_down = 1.4             
    
    filename+=".txt"
    
    return Rspace_c,filename,slope_min_up,slope_max_up,slope_min_down,slope_max_down


def gen_sel_table(w_list,lim_list,sup_max):
    col =     np.array([13       ,17     ,12         ,11    ,15    ,18+5*sup_max,16          ,14          ,18+5*sup_max+1])
    sens =    np.array([1        ,-1     ,0          ,1     ,1     ,1           ,1           ,-1          ,-1])
    #sens : 1:maximize,-1 minimize,0 NA
    report =  np.array([10000.   ,1.     ,1.         ,1.    ,1.    ,100.        ,10.         ,1.          ,1.])
    name = np.array(['Surface','NBsup','SensDeb'  ,'Long','Vtot','IPC'       ,'VAM'       ,'Dchar'     ,'Cout'])
    #quant =   np.array[[99,      , 100   , 100       ,99    ,99    ,99          ,99          ,100          ,100]]
    Tab_crit=np.zeros((9,4))
    Tab_crit[:,0]=w_list
    Tab_crit[:,1]=lim_list*report    
    Tab_crit[:,2]=col
    Tab_crit[:,3]=sens
    Name = ""  
    for i,crit in enumerate(Tab_crit):
        if crit[0]>0:
            Name+= '_'+str(name[i])+'('+str(round(crit[0],1))+')'
        
    return Tab_crit[Tab_crit[:,0]>0],Name


def create_best_table(Tab2,w_list,lim_list,sup_max): 
    Tab_crit,name=gen_sel_table(w_list,lim_list,sup_max)
    #Trie en fonction des critere avec un poids et de la limite
    for crit in Tab_crit:
        if crit[3]>0:
            tp = (Tab2[:,int(crit[2])]-crit[1])>=0
        elif crit[3]<0:
            tp = (Tab2[:,int(crit[2])]-crit[1])<=0
        else:
            continue
        Tab2 = Tab2[tp]
        
    #identifier si le sens de debardage a ete choisi dans les criteres   
    liste =range(Tab_crit.shape[0])
    idsensdeb=np.argwhere(Tab_crit[:,2]==12)
    if idsensdeb.shape[0]>0:
        idsensdeb=idsensdeb[0,0]
        liste = [x for x in liste if x != idsensdeb]
    else:
        idsensdeb=-1
    #Transform variable to stick in the range [0-1+]
    nbcol = len(liste)+2    
    Tab = np.zeros((Tab2.shape[0],nbcol))    
    col=1   
    for crit in Tab_crit[liste]:
        if crit[3] < 1 : #all values contribute to transformation
            Tab[:,col]= (1-1.0*Tab2[:,int(crit[2])]/np.max(Tab2[:,int(crit[2])]))*crit[0]
        else:
            Tab[:,col]= (1.0*Tab2[:,int(crit[2])]/np.percentile(Tab2[:,int(crit[2])],98))*crit[0]
        col+=1
    
    for i in range(Tab2.shape[0]):
        Tab[i,0]=i                      #first col is idline of Tab2
        Tab[i,col]=np.sum(Tab[i,1:col]) #last col is the total weight
    #classify
    ordre = np.zeros((Tab2.shape[0],),dtype=np.int16)   
    if idsensdeb>0:
        #first the best direction
        tp = Tab2[:,12]==Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[tp][ind][0])
        ligne=i+1
        #then the othe direction
        tp = Tab2[:,12]==-Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i+ligne]=int(Tab[tp][ind][0])
    else:
        inds = np.lexsort((Tab[:,0],-Tab[:,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[ind,0])
    return Tab2[ordre],name


def select_best_lines(w_list,lim_list,Tab2,nrows,ncols,Csize,Row_ext,Col_ext,D_ext,D_lat,Lhor_max,sup_max):        
    # Reorder Tab to fit with criteria
    Tabbis,name=create_best_table(Tab2,w_list,lim_list,sup_max)
    nb_line,nb_cols = Tabbis.shape
    Rast_couv=np.zeros((nrows,ncols),dtype=np.int8)
    vals = range(0,nb_line)
    ### Parameter to validate a line
    recouv = min(0.6*Lhor_max,Lhor_max-Csize) #distance from the axis of the line where crossing is not allowed
    # Select best lines
    vals2 = []
    for id_tab in vals:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        test_free,Rast_couv=Check_line2(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,D_lat,Rast_couv,recouv,0)
        if test_free:
            vals2.append(id_tab)
    # Check taht line contribute to total impacted surface
    Tab_result = np.zeros((len(vals2),2),dtype=np.int16)
    id_line = 0    
    for id_tab in vals2:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        prop = get_prop(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Rast_couv)  
        Tab_result[id_line]=id_tab,prop*1000
        id_line+=1
    Tab_result=Tab_result[np.lexsort((Tab_result[:,0],Tab_result[:,1]))]  
    # Remove lines that does not contribute significantly to impacted surface
    nb_line = Tab_result.shape[0]
    Tab_result2 = np.zeros((nb_line,nb_cols-2),dtype=np.int16)
    id_line = 0    
    for id_tab in Tab_result[:,0]:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2) 
        test_free,Rast_couv=Check_line3(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Rast_couv,0.6)         
        if test_free:
            Tab_result2[id_line]=Tabbis[id_tab,0:-2]
            id_line+=1    
    Tab_result2=Tab_result2[Tab_result2[:,11]>0]
    return Rast_couv,Tab_result2,name


def return_crit_text(w_list,lim_list,):    
    name = [QCoreApplication.translate("MainWindow","Forest area impacted [ha] (maximize)                 Minimum: "),
            QCoreApplication.translate("MainWindow","Number of intermediate supports (minimize)           Maximum: "),
            QCoreApplication.translate("MainWindow","Favour "),
            QCoreApplication.translate("MainWindow","Line length [m] (maximize)                           Minimum: "),
            QCoreApplication.translate("MainWindow","Total volume per line [m3] (maximize)                Minimum: "),
            QCoreApplication.translate("MainWindow","Volume per meter of line  [m3/ml] (maximize)         Minimum: "),
            QCoreApplication.translate("MainWindow","Average tree volume [m3] (maximize)                  Minimum: "),
            QCoreApplication.translate("MainWindow","Carriage average distance [m] (minimize)             Maximum: "),
            QCoreApplication.translate("MainWindow","Yarding cost [€/ml] (minimize)                       Maximum: ")]
    units = ["ha", "", "", "m", "m3", "m3/ml", "m3", "m", "€/m3"]
    namelist = name
    pname = QCoreApplication.translate("MainWindow","(Weight: ")           
    Tab = np.empty((np.sum(np.array(w_list)>0),2),dtype='|U73')
    j=-1
    for i,w in enumerate(w_list):
        if w!=0:
            j+=1
            if i!=2:
                if round(lim_list[i],0)==lim_list[i]:
                    lim=int(lim_list[i])
                else:
                    lim=round(lim_list[i],1)
                Tab[j]=namelist[i],str(lim)+" "+units[i]+" "+pname+str(w)+')' 
            else:
                if lim_list[i]==-1:
                    Tab[j]= name[i]+"l\'downhill",pname+str(w)+')' 
                elif lim_list[i]==1:
                    Tab[j]= name[i]+"l\'downhill",pname+str(w)+')'  
                else:
                    continue                    
    return Tab


def generate_info_ligne(Dir_result, w_list, lim_list, Tab, Rast_couv, Vol_ha, Vol_AM, Csize, prelevement, Lhor_max):
    filename = Dir_result + "Summary_selection.txt"
    pix_area = Csize * Csize / 10000.
    Proj = np.copy(Rast_couv)
    Proj[Rast_couv == 2] = 0
    Rast_couv[Rast_couv == 2] = 1
    Surface = round(np.sum(Rast_couv) * pix_area, 1)
    Surface_proj = round(np.sum(Proj) * pix_area, 1)
    if Surface_proj > 0:
        testProj = 1
    else:
        testProj = 0
    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:, 12] > 0))
    try:
        nb_moy_pyl = round(np.sum(Tab[:, 17]) / nb_ligne, 1)
        long_moy_ligne = int(np.sum(Tab[:, 11]) / nb_ligne)
    except:
        console_info("No cable line selected")
    Vol_ha[np.isnan(Vol_ha)] = 0
    Vol_AM[np.isnan(Vol_AM)] = 0
    tp = Vol_ha > 0
    if np.sum(tp) > 0:
        vtot = np.sum(Rast_couv[tp] * Vol_ha[tp]) * pix_area * prelevement
    else:
        vtot = 0
    tp = Vol_AM > 0
    if np.sum(tp) > 0:
        vam = round(np.mean(Rast_couv[tp] * Vol_AM[tp]), 1)
    else:
        vam = 0
    if np.sum(Tab[:, 11]) != 0:
        ipc_moy = round(float(vtot) / np.sum(Tab[:, 11]), 2)
    else:
        console_info("No cable line selected")
    vtot = int(vtot)
    lim_list[4] = lim_list[4] * prelevement

    Table = np.empty((19 + np.sum(np.array(w_list) > 0), 2 + testProj), dtype='|U73')

    Table[1, 0] = QCoreApplication.translate("MainWindow","SUMMARY OF THE LINE SELECTION")
    Table[3, 0] = "                                                         "
    Table[3, 1] = QCoreApplication.translate("MainWindow","From all cable starts\t\t")
    if testProj:
        Table[3, 2] = QCoreApplication.translate("MainWindow","Only from projects")
    Table[4, 0] = QCoreApplication.translate("MainWindow","   - Total forest area impacted [ha]:                    ")
    Table[5, 0] = QCoreApplication.translate("MainWindow","   - Total number of lines:                              ")
    Table[6, 0] = QCoreApplication.translate("MainWindow","         + With uphill yarding:                          ")
    Table[7, 0] = QCoreApplication.translate("MainWindow","         + With downhill yarding:                        ")
    Table[8, 0] = QCoreApplication.translate("MainWindow","   - Average number of intermediate support per line:    ")
    Table[9, 0] = QCoreApplication.translate("MainWindow","   - Average length of the line [m]:                     ")
    Table[10, 0] = QCoreApplication.translate("MainWindow","   - Total harvested volume (estimate) [m3]:             ")
    Table[11, 0] = QCoreApplication.translate("MainWindow","   - Average volume per meter of line (estimate) [m3/m]: ")
    Table[12, 0] = QCoreApplication.translate("MainWindow","   - Average tree volume (estimate) [m3]                 ")
    Table[18, 0] = QCoreApplication.translate("MainWindow","Criteria taken into account for the selection:           ")
    Table[17, 0] = QCoreApplication.translate("MainWindow","Lateral yarding distance                             ")
    Table[18, 0] = QCoreApplication.translate("MainWindow","Proportion of stand volume removed                   ")

    Table[4, 1] = str(Surface)
    Table[5, 1] = str(nb_ligne)
    Table[6, 1] = str(nb_ligne_amont)
    Table[7, 1] = str(nb_ligne - nb_ligne_amont)
    Table[8, 1] = str(nb_moy_pyl)
    Table[9, 1] = str(long_moy_ligne)
    Table[10, 1] = str(vtot)
    Table[11, 1] = str(ipc_moy)
    Table[12, 1] = str(vam)
    Table[17, 1] = str(int(Lhor_max)) + " m"
    Table[18, 1] = str(int(prelevement * 100)) + " %"

    Tabcrit = return_crit_text(w_list, lim_list)

    for i, crit in enumerate(Tabcrit):
        Table[19 + i, 0] = crit[0]
        Table[19 + i, 1] = crit[1]

    if testProj:
        Tab = Tab[Tab[:, 10] == 1]
        Rast_couv = Proj
        nb_ligne = Tab.shape[0]
        nb_ligne_amont = int(np.sum(Tab[:, 12] > 0))
        try:
            nb_moy_pyl = round(np.sum(Tab[:, 17]) / nb_ligne, 1)
            long_moy_ligne = int(np.sum(Tab[:, 11]) / nb_ligne)
        except:
            console_info("No cable line selected")
        tp = Vol_ha > 0
        if np.sum(tp) > 0:
            vtot = np.sum(Rast_couv[tp] * Vol_ha[tp]) * pix_area * prelevement
        else:
            vtot = 0
        tp = Vol_AM > 0
        if np.sum(tp) > 0:
            vam = round(np.mean(Rast_couv[tp] * Vol_AM[tp]), 1)
        else:
            vam = 0
        if np.sum(Tab[:, 11]) != 0:
            ipc_moy = round(float(vtot) / np.sum(Tab[:, 11]), 2)
        else:
            console_info("No cable line selected")
        vtot = int(vtot)

        Table[4, 2] = "\t\t\t\t" + str(Surface_proj)
        Table[5, 2] = "\t\t\t\t" + str(nb_ligne)
        Table[6, 2] = "\t\t\t\t" + str(nb_ligne_amont)
        Table[7, 2] = "\t\t\t\t" + str(nb_ligne - nb_ligne_amont)
        Table[8, 2] = "\t\t\t\t" + str(nb_moy_pyl)
        Table[9, 2] = "\t\t\t\t" + str(long_moy_ligne)
        Table[10, 2] = "\t\t\t\t" + str(vtot)
        Table[11, 2] = "\t\t\t\t" + str(ipc_moy)
        Table[12, 2] = "\t\t\t\t" + str(vam)

    np.savetxt(filename, Table, fmt='%s', delimiter='')


def generate_info_cable_simu(Dir_result, Tab, Rast_couv, Vol_ha, Csize, Forest, Pente, Pente_max_bucheron):
    filename = Dir_result + "Summary_results_sylvaccess_cable.txt"
    Pente_max = focal_stat_max(np.float_(Pente), -9999, 1)
    Manual_harvesting = np.int8((Pente_max <= Pente_max_bucheron))
    del Pente_max
    gc.collect()
    pix_area = Csize * Csize / 10000.
    Rast_couv[Forest == 0] = 0
    Surface_exis = round(np.sum(Rast_couv == 2) * pix_area, 1)
    Surface_proj = round(np.sum(Rast_couv == 1) * pix_area, 1)
    Surface_foret = round(np.sum(Forest == 1) * pix_area, 1)
    Surface_nonbuch = round(np.sum((Forest == 1) * (Manual_harvesting == 0)) * pix_area, 1)

    Vol_ha[np.isnan(Vol_ha)] = 0
    Vol_ha[Forest == 0] = 0
    tp = Vol_ha > 0
    if np.sum(tp) > 0:
        tp2 = (tp * (Rast_couv == 2)) > 0
        vtot_exis = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
        tp2 = (tp * (Rast_couv == 1)) > 0
        vtot_proj = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
        tp2 = (tp * (Forest == 1)) > 0
        vtot_forest = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
        tp2 = (tp * (Forest == 1) * (Pente > Pente_max_bucheron)) > 0
        vtot_nonbuch = int(np.sum(Vol_ha[tp2]) * pix_area + 0.5)
    else:
        vtot_exis = 0
        vtot_proj = 0
        vtot_forest = 0
        vtot_nonbuch = 0

    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:, 12] > 0))
    nb_moy_pyl = round(np.sum(Tab[:, 17]) / nb_ligne, 1)
    long_moy_ligne = int(np.sum(Tab[:, 11]) / nb_ligne)

    Table = np.empty((17, 5), dtype='|U39')
    Table[0] = np.array(["", QCoreApplication.translate("MainWindow","Surface area (ha)"), QCoreApplication.translate("MainWindow","Surface (%)"), QCoreApplication.translate("MainWindow","Volume (m3)"), QCoreApplication.translate("MainWindow","Volume (%)")])
    Table[1, 0] = QCoreApplication.translate("MainWindow","From existing cable starts")
    Table[2, 0] = QCoreApplication.translate("MainWindow","From potential cable start")
    Table[4, 0] = QCoreApplication.translate("MainWindow","Total accessible forest")
    Table[5, 0] = QCoreApplication.translate("MainWindow","Total unaccessible forest")
    Table[6, 0] = QCoreApplication.translate("MainWindow","    including impossible manual felling")
    Table[8, 0] = QCoreApplication.translate("MainWindow","Total forest area")
    Table[11, 0] = QCoreApplication.translate("MainWindow","Total number of lines")
    Table[12, 0] = QCoreApplication.translate("MainWindow","    + With uphill yarding")
    Table[13, 0] = QCoreApplication.translate("MainWindow","    + With downhill yarding")
    Table[15, 0] = QCoreApplication.translate("MainWindow","Average length of the line (m)")
    Table[16, 0] = QCoreApplication.translate("MainWindow","Average number of intermediate support")

    if vtot_forest > 0:
        Table[1, 1:] = np.array([str(Surface_exis), str(int(Surface_exis / Surface_foret * 100 + 0.5)),
                                 str(vtot_exis), str(int(vtot_exis / vtot_forest * 100 + 0.5))])
        Table[2, 1:] = np.array([str(Surface_proj), str(int(Surface_proj / Surface_foret * 100 + 0.5)),
                                 str(vtot_proj), str(int(vtot_proj / vtot_forest * 100 + 0.5))])

        Table[4, 1:] = np.array([str(Surface_exis + Surface_proj), str(int((Surface_proj + Surface_exis) / Surface_foret * 100 + 0.5)),
                                 str(vtot_proj + vtot_exis), str(int((vtot_exis + vtot_proj) / vtot_forest * 100 + 0.5))])
        Table[5, 1:] = np.array([str(round(Surface_foret - (Surface_exis + Surface_proj), 1)),
                                 str(int((Surface_foret - (Surface_proj + Surface_exis)) / Surface_foret * 100 + 0.5)),
                                 str(vtot_forest - (vtot_proj + vtot_exis)),
                                 str(int((vtot_forest - (vtot_exis + vtot_proj)) / vtot_forest * 100 + 0.5))])
        Table[6, 1:] = np.array([str(Surface_nonbuch), str(int(Surface_nonbuch / Surface_foret * 100 + 0.5)),
                                 str(vtot_nonbuch), str(int(vtot_nonbuch / vtot_forest * 100 + 0.5))])
    else:
        Table[1, 1:] = np.array([str(Surface_exis), str(int(Surface_exis / Surface_foret * 100 + 0.5)), '0', '0'])
        Table[2, 1:] = np.array([str(Surface_proj), str(int(Surface_proj / Surface_foret * 100 + 0.5)), '0', '0'])

        Table[4, 1:] = np.array([str(Surface_exis + Surface_proj),
                                 str(int((Surface_proj + Surface_exis) / Surface_foret * 100 + 0.5)), '0', '0'])
        Table[5, 1:] = np.array([str(round(Surface_foret - (Surface_exis + Surface_proj), 1)),
                                 str(int((Surface_foret - (Surface_proj + Surface_exis)) / Surface_foret * 100 + 0.5)),
                                 '0', '0'])
        Table[6, 1:] = np.array([str(Surface_nonbuch), str(int(Surface_nonbuch / Surface_foret * 100 + 0.5)), '0', '0'])

    Table[8, 1:] = np.array([str(Surface_foret), "", str(vtot_forest), ""])

    Table[11, 1] = str(nb_ligne)
    Table[12, 1] = str(nb_ligne_amont)
    Table[13, 1] = str(nb_ligne - nb_ligne_amont)
    Table[15, 1] = str(long_moy_ligne)
    Table[16, 1] = str(nb_moy_pyl)

    np.savetxt(filename, Table, fmt='%s', delimiter=';')


def calculate_azimut(x1,y1,x2,y2):
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    return Angle%360   


def create_rast_couv(Tab_result,Dir_result,source_src,Extent,Csize,Lhor_max):
    drv = ogr.GetDriverByName("GBKG")    
    layer_name = "Extent"
    dst_ds = drv.CreateDataSource( Dir_result+layer_name+".gbkg" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('EXIST', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    layerDefinition = dst_layer.GetLayerDefn()  
    for idi,line in enumerate(Tab_result):
        Xstart,Ystart,Xend,Yend = line[2],line[3],line[6],line[7]
        az = calculate_azimut(Xstart,Ystart,Xend,Yend)
        conv = radians(90)
        ring = ogr.Geometry(ogr.wkbLinearRing)
        ring.AddPoint(Xstart+Lhor_max*cos(az-conv), Ystart+Lhor_max*sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*cos(az-conv), Yend+Lhor_max*sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*cos(az+conv), Yend+Lhor_max*sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*cos(az+conv), Ystart+Lhor_max*sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*cos(az-conv), Ystart+Lhor_max*sin(az-conv))
        poly = ogr.Geometry(ogr.wkbPolygon)
        poly.AddGeometry(ring)
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(poly)
        feature.SetFID(idi)        
        feature.SetField('EXIST',int(line[10]))
        dst_layer.CreateFeature(feature)
        ring.Destroy()
        poly.Destroy()
        feature.Destroy()
    dst_ds.Destroy()
    Rast_couv = np.int8(shapefile_to_np_array(Dir_result+layer_name+".shp",Extent,Csize,"EXIST","EXIST",'ASC') )
    for extension in [".shp",".prj",".shx",".dbf"]:
        os.remove(Dir_result+layer_name+extension)
    return Rast_couv


def prepa_data_cable(Wspace, file_MNT, file_shp_Foret, file_shp_Cable_Dep, Dir_Obs_cable):
    console_info(QCoreApplication.translate("MainWindow","Pre-processing of the inputs for cable model\n"))
    ### Make directory for temporary files
    Dir_temp = Wspace + "Temp/"
    try:
        os.mkdir(Dir_temp)
    except:
        pass
    ###########################################################################
    ### __         __ __   __         __ __               __   __
    ###|__|.-----.|__|  |_|__|.---.-.|  |__|.-----.---.-.|  |_|__|.-----.-----.
    ###|  ||     ||  |   _|  ||  _  ||  |  ||__ --|  _  ||   _|  ||  _  |     |
    ###|__||__|__||__|____|__||___._||__|__||_____|___._||____|__||_____|__|__|
    ###
    MNT, Extent, Csize, _ = load_float_raster(file_MNT, Dir_temp)
    np.save(Dir_temp + "MNT", MNT)

    #############################################################################################################
    ###        __                       ___ __ __             __                                __
    ###.-----.|  |--.---.-.-----.-----.'  _|__|  |.-----.    |  |_.-----.    .----.---.-.-----.|  |_.-----.----.
    ###|__ --||     |  _  |  _  |  -__|   _|  |  ||  -__|    |   _|  _  |    |   _|  _  |__ --||   _|  -__|   _|
    ###|_____||__|__|___._|   __|_____|__| |__|__||_____|    |____|_____|    |__| |___._|_____||____|_____|__|
    ###                   |__|
    Foret = shapefile_to_np_array(file_shp_Foret, Extent, Csize, "FORET")
    np.save(Dir_temp + "Foret", np.int8(Foret))
    del Foret
    console_info(QCoreApplication.translate("MainWindow","    - Forest raster processed"))
    ### Forest : shapefile to raster
    Exposition = exposition(MNT, Csize, -9999)
    np.save(Dir_temp + "Aspect", np.uint16(Exposition + 0.5))
    Pente = prepa_obstacle_cable(Dir_Obs_cable, file_MNT, Dir_temp)
    np.save(Dir_temp + "Pente", Pente)
    Pond_pente = np.sqrt((Pente * 0.01 * Csize) ** 2 + Csize ** 2) / float(Csize)
    Pond_pente[Pente == -9999] = 10000
    np.save(Dir_temp + "Pond_pente", Pond_pente)
    del Pente, MNT
    console_info(QCoreApplication.translate("MainWindow","    - Cable obstacles processed"))

    #################################################################################################################################
    ###             __     __                    __               __                                                 __              
    ###.----.---.-.|  |--.|  |.-----.    .-----.|  |_.---.-.----.|  |_     .-----.----.-----.----.-----.-----.-----.|__|.-----.-----.
    ###|  __|  _  ||  _  ||  ||  -__|    |__ --||   _|  _  |   _||   _|    |  _  |   _|  _  |  __|  -__|__ --|__ --||  ||     |  _  |
    ###|____|___._||_____||__||_____|    |_____||____|___._|__|  |____|    |   __|__| |_____|____|_____|_____|_____||__||__|__|___  |
    ###                                                                    |__|                                               |_____|
    Cable_start = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"CABLE","CABLE",'ASC') 
    testExist = check_field(file_shp_Cable_Dep,"EXIST")
    if testExist:    
        Existing = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"EXIST","EXIST",'ASC') 
    else:
        Existing = np.ones_like(Cable_start,dtype=np.int8)*2

    pixels = np.argwhere(Cable_start>0)
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.int16) 
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        Lien_RF[ID,4]=Cable_start[pixel[0],pixel[1]]
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=Existing[pixel[0],pixel[1]]
        ID +=1         
    # Link RF with res_pub and calculate transportation distance
    # Lien_RF=Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for, Lien_RF,Csize) 
    # Lien_RF=Lien_RF[Lien_RF[:,4]>0]
    Lien_RF=Lien_RF[Lien_RF[:,2]>-1]
    np.save(Dir_temp+"Lien_RF_c",Lien_RF)  
    console_info(QCoreApplication.translate("MainWindow","    - Potential cable yarding starts processed"))    

    ###################################################################################################################################################################################
    ###                                 __                                     __                      __                                      __                                      
    ###.----.----.-----.-----.----.    |  |.-----.-----.    .----.---.-.-----.|  |_.-----.----.    .--|  |.-----.    .----.-----.-----.----.--|  |.-----.-----.-----.-----.-----.-----.
    ###|  __|   _|  -__|  -__|   _|    |  ||  -__|__ --|    |   _|  _  |__ --||   _|  -__|   _|    |  _  ||  -__|    |  __|  _  |  _  |   _|  _  ||  _  |     |     |  -__|  -__|__ --|
    ###|____|__| |_____|_____|__|      |__||_____|_____|    |__| |___._|_____||____|_____|__|      |_____||_____|    |____|_____|_____|__| |_____||_____|__|__|__|__|_____|_____|_____|
    ###                                                                                                                                                                                
    _, values, _, Extent = raster_get_info(file_MNT)
    Csize, ncols, nrows = values[4], int(values[0]), int(values[1])  
    TableX, TableY=create_coord_pixel_center_raster(values, nrows, ncols, Csize, Dir_temp)
    CoordRoute = np.zeros((Lien_RF.shape[0], 2), dtype=np.float32)
    for i, pixel in enumerate(Lien_RF):
        CoordRoute[i, 0]=TableX[pixel[1]]
        CoordRoute[i, 1]=TableY[pixel[0]] 
    np.save(Dir_temp+"CoordRoute.npy", CoordRoute)  
    console_info(QCoreApplication.translate("MainWindow","    - Table of coordinates created"))  
    ##############################################################################################################################################
    ###       __                         __   __                                __         __   
    ###.----.|  |.-----.-----.-----.    |  |_|  |--.-----.    .-----.----.----.|__|.-----.|  |_ 
    ###|  __||  ||  _  |__ --|  -__|    |   _|     |  -__|    |__ --|  __|   _||  ||  _  ||   _|
    ###|____||__||_____|_____|_____|    |____|__|__|_____|    |_____|____|__|  |__||   __||____|
    ###                                                                            |__|         
    console_info(QCoreApplication.translate("MainWindow","\nCable input data processing achieved\n"))
    clear_big_nparray()


def line_selection(Rspace_c, w_list, lim_list, new_calc, file_shp_Foret, file_Vol_ha, file_Vol_AM, Lhor_max, prelevement, Pente_max_bucheron):
    console_info(QCoreApplication.translate("MainWindow","Selection of the best lines based on user criteria."))
    ### Check if temporary files have been generated and have the same extent
    Rspace_sel = Rspace_c + "FilesForOptimization/"
    console_info(QCoreApplication.translate("MainWindow","Start of the best lines selection according to user criteria."))
    try: 
        Tab = np.load(Rspace_sel + "Tab_all_lines.npy") 
    except:
        console_warning(QCoreApplication.translate("MainWindow","Please run first the Sylvaccess cable."))
        return ""
    Lmax = np.max(Tab[:, 11])    
    _, values, Extent = loadrasterinfo_from_file(Rspace_sel)
    Csize, nrows, ncols = values[4], int(values[1]), int(values[0]) 
    if not new_calc:
        f = open(Rspace_sel + "info_Lhormax.txt", "r")
        Lhor_max = f.readlines(0)
        f.close()
        Lhor_max = float(Lhor_max[0])
    
    _, _, _, _, Row_ext, Col_ext, D_ext, D_lat, _ = create_buffer2(Csize, Lmax, Lhor_max)        
    Lien_RF = np.load(Rspace_sel + "Lien_RF_c.npy")
    ############################################
    ### Recompute cable line stats if necessary
    ############################################
    if new_calc:
        console_info(QCoreApplication.translate("MainWindow","    - Processing new line characteristics with new input data...")) 
        #Couche foret
        if file_shp_Foret != "":
            Forest = np.int8(shapefile_to_np_array(file_shp_Foret, Extent, Csize, "FORET"))
        else:
            Forest = np.load(Rspace_sel + "Forest.npy")
        #Couche vol_ha
        if file_Vol_ha != "":
            Vol_ha = load_float_raster_simple(file_Vol_ha) 
            Vol_ha[Vol_ha < 0] = 0
            Vol_ha[np.isnan(Vol_ha)] = 0
            test_vp = True
        else:
            test_vp = False            
            if file_Vol_AM != "":
                Vol_ha = np.zeros_like(Forest, dtype=np.float32)
            else:
                Vol_ha = np.zeros_like(Forest, dtype=np.int8)
        #Couche vol_am
        if file_Vol_AM != "":
            Vol_AM = load_float_raster_simple(file_Vol_AM) 
            Vol_AM[Vol_AM < 0] = 0
            Vol_AM[np.isnan(Vol_AM)] = 0
            test_vam = True
        else:
            test_vam = False  
            if file_Vol_ha != "":
                Vol_AM = np.zeros_like(Forest, dtype=np.float32)   
            else:
                Vol_AM = np.zeros_like(Forest, dtype=np.int8)   
       
        if test_vp or test_vam:             
            Pente = np.load(Rspace_sel + "Pente.npy")
            Vol_AM[Pente > Pente_max_bucheron] = 0
            Vol_ha[Pente > Pente_max_bucheron] = 0
        nbline = Tab.shape[0]        
        Rast_couv = np.zeros_like(Forest, dtype=np.int8)
        for i in range(0, nbline):
            coordX = Lien_RF[Tab[i, 0], 1]
            coordY = Lien_RF[Tab[i, 0], 0]       
            az = Tab[i, 1]
            Lline = sqrt((Tab[i, 2] - Tab[i, 6]) ** 2 + (Tab[i, 3] - Tab[i, 7]) ** 2)                                                      
            if test_vp or test_vam:
                Distance_moyenne, Surface, Vtot, VAM, Rast_couv = get_line_carac_vol(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv, Vol_ha, Vol_AM)
            else:
                Distance_moyenne, Surface, Rast_couv = get_line_carac_simple(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv)
            #Surface foret Dmoy chariot
            Tab[i, 13], Tab[i, 14] = Surface, Distance_moyenne
            #Vtot IPC
            if test_vp:
                Tab[i, 15] = Vtot
            #VAM               
            if test_vam:
                Tab[i, 16] = VAM * 10
   
    
    ############################################
    ### Calc IPC according to prelevement
    ############################################
    
    Tab2 = np.zeros((Tab.shape[0], Tab.shape[1] + 4), dtype=np.int16)
    Tab2[:, 0:-4] = Tab
    Tab2[:, -4] = np.int_(100.0 * Tab[:, 15] * prelevement / Tab[:, 11])
    del Tab
    gc.collect()    
    Tab2[:, -1] = Lien_RF[Tab2[:, 0], 0]
    Tab2[:, -2] = Lien_RF[Tab2[:, 0], 1]     
    del Lien_RF
    gc.collect()
    sup_max = np.max(Tab2[:, 17])    
    
    lim_list[4] = lim_list[4] / prelevement  # in order to account for prelevement in line selection
    
    #Modify selection criteria in case of no volume or vam        
    if np.max(Tab2[:, 15]) == 0:        
        if w_list[4] > 0:
            console_info(QCoreApplication.translate("MainWindow","Impossible optimization on volume/ipc criteria (no information available)."))   
        w_list[4], lim_list[4] = 0, 0
        w_list[5], lim_list[5] = 0, 0
        
    if np.max(Tab2[:, 16]) == 0:
        if w_list[6] > 0:
            console_info(QCoreApplication.translate("MainWindow","Impossible optimization on average tree volume criteria (no information available)."))
        w_list[6], lim_list[6] = 0, 0
        
    Rast_couv, Tab_result, Tab_name = select_best_lines(w_list, lim_list, Tab2,
                                                                   nrows, ncols, Csize,
                                                                   Row_ext, Col_ext, D_ext,
                                                                   D_lat, Lhor_max, sup_max)
    del Tab2  
    gc.collect()
    #Get folder
    dirs = [d for d in os.listdir(Rspace_c) if os.path.isdir(os.path.join(Rspace_c, d))]
    list_dir = []
    for dire in dirs:
        if dire[:12] == QCoreApplication.translate("MainWindow","Optimization"):
            list_dir.append(dire)
    optnum = len(list_dir) + 1
    Dir_result = Rspace_c + "Optimization" + str(optnum) 
    ### Get best volume
    header = QCoreApplication.translate("MainWindow","ID_pixel Azimuth_deg X_Start Y_Start Elevation_Start Hcable_Start X_End Y_End Elevation_End Hcable_End ")
    header += QCoreApplication.translate("MainWindow","Existing_road Cable_length Configuration ")
    header += QCoreApplication.translate("MainWindow","Forest_area Carriage_average_distance Volume_total ATV NB_int_sup")
    for num in range(1, sup_max + 1):
        header += ' ' + QCoreApplication.translate("MainWindow","Xcoord_intsup") + str(num) + ' ' + QCoreApplication.translate("MainWindow","Ycoord_intsup") + str(num) + ' ' + QCoreApplication.translate("MainWindow","Elevation_intsup") + str(num)
        header += ' ' + QCoreApplication.translate("MainWindow","Hcable_intsup") + str(num) + ' ' + QCoreApplication.translate("MainWindow","Pression_intsup") + str(num)
    header += QCoreApplication.translate("MainWindow","IPC cost") 
    Dir_result += Tab_name  
    header += '\n'
    try:
        os.mkdir(Dir_result)
    except:
        pass
    Dir_result += "/"
    filename = Dir_result + "Database_Optimization_" + str(optnum) + ".gzip" 
    shape_name = Dir_result + "CableLines_Optimization_" + str(optnum) + ".shp"
    rast_name = Dir_result + "CableArea_Optimization_" + str(optnum)
    pyl_name = Dir_result + "Int_sup_Optimization_" + str(optnum) + ".shp"
    
    save_integer_ascii(filename, header, Tab_result)
    source_src = get_source_src(Rspace_sel + "info_proj.shp") 
    road_network_proj = get_proj_from_road_network(Rspace_sel + "info_proj.shp")
    Line_to_shapefile(Tab_result, shape_name, source_src, prelevement) 
    #New rast_couv to take into account project of cable start
    Rast_couv = create_rast_couv(Tab_result, Dir_result, source_src, Extent, Csize, Lhor_max)
    #Rast_couv[Rast_couv>0]=1
    if not new_calc:
        Forest = np.load(Rspace_sel + "Forest.npy")
        try:         
            Vol_ha = np.load(Rspace_sel + "MainWindow","Vol_ha.npy")
        except:
            Vol_ha = np.zeros_like(Forest)
        try:
            Vol_AM = np.load(Rspace_sel + "MainWindow","Vol_AM.npy")
        except:
            Vol_AM = np.zeros_like(Forest)    
    Rast_couv[Forest == 0] = 0
    ArrayToGtiff(Rast_couv, rast_name, Extent, nrows, ncols, road_network_proj, 0, 'UINT8')    
    Pylone_in_shapefile(Tab_result, pyl_name, source_src)
    ### Summary of the choice
    generate_info_ligne(Dir_result, w_list, lim_list, Tab_result, Rast_couv, Vol_ha, Vol_AM, Csize, prelevement, Lhor_max) 
    console_info(QCoreApplication.translate("MainWindow","Selection of the best cable lines achieved."))

 

#####################################################################
#    _______. __  ___  __   _______   _______   _______ .______     #
#    /       ||  |/  / |  | |       \ |       \ |   ____||   _  \   #
#   |   (----`|  '  /  |  | |  .--.  ||  .--.  ||  |__   |  |_)  |  #
##   \   \    |    <   |  | |  |  |  ||  |  |  ||   __|  |      /   #
#.----)   |   |  .  \  |  | |  '--'  ||  '--'  ||  |____ |  |\  \--.#
#|_______/    |__|\__\ |__| |_______/ |_______/ |_______|| _| `.___|#
#####################################################################

# Fonctions qui gère les calculs liés au skidder

def Skidder():
    Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, _, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder, _, _, file_Vol_ha, _, _ = Sylvaccess_UI.get_spatial_cls()
    #if file_Vol_ha == "":
     #   file_Vol_ha = crop_to_main_dtm_size(file_Vol_ha, file_MNT)
    _, _, _, _, Pente_max_bucheron = Sylvaccess_UI.get_general_cls()
    Pente_max_skidder, Dtreuil_max_up, Dtreuil_max_down, Dmax_train_near_for, Pmax_amont, Pmax_aval, Option_Skidder, Skid_Debclass = Sylvaccess_UI.get_skidder_cls()
    ##test
    console_info(QCoreApplication.translate("MainWindow","Starting the skidder model"))
    ##

    Hdebut = datetime.datetime.now()

    # Create a folder for process results
    Rspace_s = Rspace + "Skidder/"
    try:
        os.mkdir(Rspace_s)
    except:
        pass
    Dir_temp = Wspace + "Temp/"

    # Check if temporary files have been generated and have the same extent
    try:
        _, values, _, Extent = raster_get_info(file_MNT)
    except:
        return QCoreApplication.translate("MainWindow","Error: Please define a projection for the DTM raster.")
    try:
        _, v1 = read_info(Dir_temp + 'info_extent.txt')
        for i, item in enumerate(values):
            if v1[i] != round(item, 2):
                prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder)
            if i + 1 > 4:
                break
    except:
        prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder)

    # Inputs
    try:
        Foret = np.int8(np.load(Dir_temp + "Foret.npy"))
        Piste = np.int8(np.load(Dir_temp + "Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp + "Route_for.npy"))
        Res_pub = np.int8(np.load(Dir_temp + "Res_pub.npy"))
        Lien_piste = np.load(Dir_temp + "Lien_piste.npy")
        Lien_RF = np.load(Dir_temp + "Lien_RF.npy")
        Pente = np.load(Dir_temp + "Pente.npy")
        Pond_pente = np.load(Dir_temp + "Pond_pente.npy")
        MNT = np.load(Dir_temp + "MNT.npy")
        Full_Obstacles_skidder = np.int8(np.load(Dir_temp + "Full_Obstacles_skidder.npy"))
        Partial_Obstacles_skidder = np.int8(np.load(Dir_temp + "Partial_Obstacles_skidder.npy"))
    except:
        prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder)
        Foret = np.int8(np.load(Dir_temp + "Foret.npy"))
        Piste = np.int8(np.load(Dir_temp + "Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp + "Route_for.npy"))
        Res_pub = np.int8(np.load(Dir_temp + "Res_pub.npy"))
        Lien_piste = np.load(Dir_temp + "Lien_piste.npy")
        Lien_RF = np.load(Dir_temp + "Lien_RF.npy")
        Pente = np.load(Dir_temp + "Pente.npy")
        Pond_pente = np.load(Dir_temp + "Pond_pente.npy")
        MNT = np.load(Dir_temp + "MNT.npy")
        Full_Obstacles_skidder = np.int8(np.load(Dir_temp + "Full_Obstacles_skidder.npy"))
        Partial_Obstacles_skidder = np.int8(np.load(Dir_temp + "Partial_Obstacles_skidder.npy"))

    nrows, ncols = MNT.shape[0], MNT.shape[1]
    road_network_proj = get_proj_from_road_network(file_shp_Desserte)
    
    # Calculation of useful variables for the model process
    Pmax_up = float(abs(Pmax_amont)) / 100.0
    Pmax_down = -float(abs(Pmax_aval)) / 100.0
    deniv_up = math.sqrt(float(Dtreuil_max_up * Dtreuil_max_up) / float(1 + 1.0 / float(Pmax_up * Pmax_up)))
    deniv_down = -math.sqrt(float(Dtreuil_max_down * Dtreuil_max_down) / float(1 + 1.0 / float(Pmax_down * Pmax_down)))
    coeff = float(Dtreuil_max_up - Dtreuil_max_down) / float(deniv_up - deniv_down)
    orig = Dtreuil_max_up - coeff * deniv_up
    Csize = values[4]
    Pond_pente[Full_Obstacles_skidder == 1] = 1000
    Pente_max = focal_stat_max(np.float_(Pente), -9999, 1)
    Manual_harvesting = np.int8((Pente_max <= Pente_max_bucheron))
    del Pente_max
    gc.collect()
    Pente_ok_skid = np.int8((Pente <= Pente_max_skidder) * (Pente > -9999))
    MNT_OK = np.int8((MNT != values[5]))
    Zone_OK = np.int8(MNT_OK * (Foret == 1) * (Full_Obstacles_skidder == 0) * Manual_harvesting == 1)

    Surf_foret = np.sum((Foret == 1) * MNT_OK) * Csize * Csize * 0.0001
    Surf_foret_non_access = int(np.sum((Manual_harvesting == 0) * (Foret == 1) * MNT_OK * Csize * Csize * 0.0001) + 0.5)

    Row_line, Col_line, D_line, Nbpix_line = create_buffer_skidder(Csize, Dtreuil_max_up, Dtreuil_max_down)

    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)] = 0
        Temp = ((Vol_ha > 0) * (Foret == 1) * MNT_OK) > 0
        Vtot = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
        Temp = ((Vol_ha > 0) * (Manual_harvesting == 0) * (Foret == 1) * MNT_OK) > 0
        Vtot_non_buch = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
        del Vol_ha, Temp
    else:
        Vtot = 0
        Vtot_non_buch = 0

    ArrayToGtiff(Manual_harvesting, Rspace_s + 'Manual_harvesting', Extent, nrows, ncols, road_network_proj, 0, 'UINT8')
    console_info(QCoreApplication.translate("MainWindow","    - Initialization achieved, processing..."))
    del Pente, Manual_harvesting
    gc.collect()

    
    ###############################################################################################################################################    
    ### Calculation of skidding distance inside the forest stands
    ###############################################################################################################################################                  
    # Identify the forest area that may be run through by the skidder
    zone_rast = Pente_ok_skid*(Foret==1)
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    from_rast = np.int8(((Piste==1)+(Route_for==1))>0)
    from_rast[Res_pub==1]=0
    Zone_for,_ = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Zone_for[Zone_for>=0]=1
    Zone_for[from_rast==1]=1
    Zone_for=np.int8(Zone_for)
    
    # Create a buffer of Dmax_out_forest around these area taking into account slope and obstacles
    from_rast = focal_stat_nb(np.float_(Zone_for==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.copy(Pente_ok_skid)
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0 
    Zone_for2,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Dmax_train_near_for) 
    Pente_ok_skidder = np.int8(Zone_for2>0)
    Pente_ok_skidder[Zone_for==1]=1 
    
    del Zone_for,Zone_for2,Out_alloc
    gc.collect()
    
    #Stick all forest with pente_ok_skidder to the area
    from_rast = focal_stat_nb(np.float_(Pente_ok_skidder==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.int8(1*Pente_ok_skid*(Foret==1))
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Pente_ok_skidder[Zone_for>=0]=1    
           
    del Zone_for,from_rast,zone_rast,Out_alloc,Pente_ok_skid
    gc.collect()     
    
    
    D_foret_piste,L_Piste,D_piste=Dfwd_flat_forest_tracks(Lien_piste, Pond_pente, Pente_ok_skidder*(Route_for==0)*1, Csize)    
    D_foret_RF,L_RF = Dfwd_flat_forest_road(Lien_RF,Pond_pente,Pente_ok_skidder*1*(Piste==0),Csize)
    
    del Pente_ok_skidder, Pond_pente
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Skidding distance from forest roads network calculated"))

    ###############################################################################################################################################
    ### Calculation of skidding distance from forest roads
    ###############################################################################################################################################

    DebRF_D, DebRF_LRF = skid_debusq_RF(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line, coeff, orig, Pmax_up, Pmax_down,
                                        Dtreuil_max_up, Dtreuil_max_down, nrows, ncols, Zone_OK * (Route_for == 0) * 1 * (Piste == 0))

    console_info(QCoreApplication.translate("MainWindow","    - Winching distance from forest roads calculated"))

    ###############################################################################################################################################
    #### Calculation of skidding distance from forest tracks
    ###############################################################################################################################################                 

    Debp_D, Debp_LP, Debp_Dtrpiste = skid_debusq_Piste(Lien_piste, MNT, Row_line, Col_line, D_line, Nbpix_line, coeff, orig, Pmax_up, Pmax_down,
                                                    Dtreuil_max_up, Dtreuil_max_down, nrows, ncols, Zone_OK * (Piste == 0) * 1 * (Route_for == 0))

    console_info(QCoreApplication.translate("MainWindow","    - Winching distance from forest tracks calculated"))
    gc.collect()

        
    ###############################################################################################################################################    
    ### Concatenation of the resultats (1)
    ###############################################################################################################################################
    DTrain_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    DTrain_foret = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Ddebusquage = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_RF = np.ones((nrows,ncols),dtype=np.int32)*-9999
             
    if Option_Skidder==1:
        # Option 1 : Skidder is forced to stay as much possible as possible on forest road networks
        # Get value of winching distance from forest roads
        Temp = (DebRF_D>=0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = DebRF_D[Temp]
        Lien_foret_RF[Temp] = DebRF_LRF[Temp]
            
        # Get value of winching distance from forest tracks  
        Temp = Debp_D>=0
        Temp[(Debp_D+0.1*Debp_Dtrpiste)>Ddebusquage]=0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp]
        Lien_foret_RF[Temp] = -9999
        Temp = ((Ddebusquage<0)*(Debp_D>=0))>0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp]
        Lien_foret_RF[Temp] = -9999
        
        # Get value of skidding distance within forest stand from forest tracks
        Temp = (Ddebusquage<0)*(D_foret_piste>=0)
        DTrain_piste[Temp] = D_piste[Temp]
        DTrain_foret[Temp] = D_foret_piste[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_piste[Temp] = L_Piste[Temp]
        
        # Get value of skidding distance within forest stand from forest roads
        Temp = (Ddebusquage==0)*(D_foret_RF>=0)
        Temp[(DTrain_foret+0.1*DTrain_piste)<D_foret_RF]=0
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]  
        Temp = (Ddebusquage<0)*(D_foret_RF>=0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]   
         
        
    else:
        # Option 2 : Limit the skidding : skidder goes as close as possible to the timber before using winching possibility

        # Get value of skidding distance within forest stand from forest tracks
        Temp = (D_foret_piste>=0)
        DTrain_piste[Temp] = D_piste[Temp]
        DTrain_foret[Temp] = D_foret_piste[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_piste[Temp] = L_Piste[Temp]   
        
        # Get value of skidding distance within forest stand from forest roads       
        Temp = (Ddebusquage==0)*(D_foret_RF>=0)
        Temp[(DTrain_foret+0.1*DTrain_piste)<D_foret_RF]=0
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]     
        Temp = (D_foret_RF>=0)*(DTrain_foret<0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]                  
        
        # Get value of winching distance from forest roads
        Temp = (DebRF_D>=0)*(DTrain_foret<0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = DebRF_D[Temp]
        Lien_foret_RF[Temp] = DebRF_LRF[Temp]   
        
        # Get value of winching distance from forest tracks
        Temp = Debp_D>=0
        Temp[(Debp_D+0.1*Debp_Dtrpiste)>Ddebusquage]=0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp] 
        Lien_foret_RF[Temp] = -9999        
        Temp = ((DTrain_foret<0)*(Debp_D>=0))>0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp] 
        Lien_foret_RF[Temp] = -9999
        
        
    # Calculation of the forest area accessible with a skidder
    zone_tracteur = np.zeros_like(MNT,dtype=np.int8)
    zone_tracteur[((D_foret_piste>=0)*(Foret==1))>0]=1
    zone_tracteur[((D_foret_RF>=0)*(Foret==1))>0]=1    
    
    ArrayToGtiff(zone_tracteur,Rspace_s+'Free_access_of_the_skidder',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    console_info(QCoreApplication.translate("MainWindow","    - First concatenation done"))  
    del DebRF_D,DebRF_LRF,Debp_D,Debp_LP,Debp_Dtrpiste
    gc.collect() 
    
    ################################################################################################################################################  
    ### Calculation of winching distance from contours
    ################################################################################################################################################
    contour = focal_stat_nb(np.float_((zone_tracteur==1)*1),0,1)
    contour = ((contour<9)*(contour>0)>0)*1
    contour[Full_Obstacles_skidder==1]=0
    contour[Partial_Obstacles_skidder==1]=0
    contour[Res_pub==1]=0   
    contour[MNT_OK==0]=0  
    
    pixels=np.argwhere(contour>0)
    del zone_tracteur,Full_Obstacles_skidder,Partial_Obstacles_skidder,Res_pub,MNT_OK,contour
    gc.collect()
    
    #line=ID_contour, Y, X,L_RF,L_piste,Dtrain,Dpis
    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int16)    
    ID = 1
    for pixel in pixels:
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        testpiste=0
        if D_foret_RF[pixel[0],pixel[1]]<0:
            testpiste=1
        elif D_piste[pixel[0],pixel[1]]>=0:
            if (D_foret_piste[pixel[0],pixel[1]]+0.1*D_piste[pixel[0],pixel[1]])<D_foret_RF[pixel[0],pixel[1]]:
                testpiste=1
        if testpiste:
            Lien_contour[ID,2],Lien_contour[ID,3]=-9999,L_Piste[pixel[0],pixel[1]]
            Lien_contour[ID,4],Lien_contour[ID,5]=D_foret_piste[pixel[0],pixel[1]],D_piste[pixel[0],pixel[1]]
        else:
            Lien_contour[ID,2],Lien_contour[ID,3]=L_RF[pixel[0],pixel[1]],-9999
            Lien_contour[ID,4],Lien_contour[ID,5]=D_foret_RF[pixel[0],pixel[1]],0     
        ID += 1
    del D_foret_piste,L_Piste,D_piste,D_foret_RF,L_RF
    gc.collect()    
    
    # Get the contour of traversable area
    Ddebus,L_RF,L_Piste,Dpis,Dfor=skid_debusq_contour(Lien_contour,MNT,Row_line,Col_line,D_line,Nbpix_line,coeff,orig,Pmax_up,Pmax_down,
                                                         Dtreuil_max_up,Dtreuil_max_down,nrows,ncols,Zone_OK*1*(Ddebusquage<=0))
                                                      
    del Lien_contour,pixels,MNT
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Distance de debusquage depuis le contour de la zone parcourable calculee"))      
    
    ################################################################################################################################################  
    ### Concatenation (2)
    ################################################################################################################################################    
    
    Temp = (Ddebusquage<0)*(Ddebus>=0)
    DTrain_piste[Temp] = Dpis[Temp]
    DTrain_foret[Temp] = Dfor[Temp]
    Ddebusquage[Temp] = Ddebus[Temp]
    Lien_foret_RF[Temp] = L_RF[Temp]
    Lien_foret_piste[Temp] = L_Piste[Temp]
        
    del Ddebus,L_RF,L_Piste,Dpis,Dfor
    gc.collect()
    
    Temp = (Foret==0)
    DTrain_piste[Temp] = -9999
    DTrain_foret[Temp] = -9999
    Ddebusquage[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    
    del Temp
    gc.collect()
    
    # Fill Lien foret respub and Lien foret RF
    Lien_foret_Res_pub,Lien_foret_RF,Keep=fill_Link(Lien_foret_piste,Lien_piste,Lien_RF, Lien_foret_RF, nrows,ncols)
    
    Temp = (Keep<1)*((Piste==1)+(Route_for==1))>0
    DTrain_piste[Temp] = -9999
    DTrain_foret[Temp] = -9999
    Ddebusquage[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_Res_pub[Temp] = -9999
        
    del Temp,Keep
    gc.collect()
    
    # Calculation of the total skidding distance
    Dtotal = np.ones((nrows,ncols),dtype=np.int32)*-9999
    zone_accessible = np.zeros((nrows,ncols),dtype=np.int8)
    Temp = (Ddebusquage>=0)
    Dtotal[Temp]= DTrain_piste[Temp] + DTrain_foret[Temp] + Ddebusquage[Temp]
    zone_accessible[Temp] = 1    
   
    del Temp
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Concatenation des resultats terminee. Sauvegarde en cours..."))             
        
    
    ### Saving all rasters
    ##################################################################################################################################################
    ### Create a summary table of accessible area    
    make_summary_surface_vol(Skid_Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,Dtotal,Vtot,Vtot_non_buch,Rspace_s,"Skidder")
     
    ### Save output rasters
    ArrayToGtiff(zone_accessible,Rspace_s+'Accesible_forest',Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    ArrayToGtiff(Foret-zone_accessible,Rspace_s+'Unacccessible_forest',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    ArrayToGtiff(DTrain_piste,Rspace_s+'Skidding_distance_on_tracks',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(DTrain_foret,Rspace_s+'Skidding_distance_in_forest',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Ddebusquage,Rspace_s+'Winching_distance',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Dtotal,Rspace_s+'Total_distance',Extent,nrows,ncols,road_network_proj,-9999,'INT32')        
    ArrayToGtiff(Lien_foret_piste,Rspace_s+'Link_forest_ForestTrack',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_RF,Rspace_s+'Link_forest_ForestRoads',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_Res_pub,Rspace_s+'link_forest_public_road_network',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    layer_name = 'Skidder_recap_accessibility'
    source_src=get_source_src(file_shp_Desserte)  
    create_access_shapefile(Dtotal,Rspace_s,Foret,Skid_Debclass.split(";"),road_network_proj,source_src, Dir_temp,Extent,nrows,ncols,layer_name)
      
    del zone_accessible,DTrain_piste,DTrain_foret,Ddebusquage,Dtotal
    del Lien_foret_piste,Lien_foret_RF,Lien_foret_Res_pub
    
    str_duree,str_fin,str_debut=heures(Hdebut)
    
    ### Genere le fichier avec le resume des parametres de simulation
    file_name = str(Rspace_s)+"Parameters_of_simulation.txt"
    resume_texte = QCoreApplication.translate("MainWindow","Sylvaccess : AUTOMATIC MAPPING OF FOREST ACCESSIBILITY WITH SKIDDER\n\n\n")
    ver = "0.2"
    date = "2024/02"
    resume_texte += QCoreApplication.translate("MainWindow","Software version :") + ver + QCoreApplication.translate("MainWindow"," - ", "skidder_results") + date + "\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","Resolution       : " + str(Csize) + QCoreApplication.translate("MainWindow"," m ") + "\n\n")
    resume_texte += "" .join (["_"]*80) + "\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","Date and time when launching the script:              ")+str_debut+"\n"
    resume_texte += QCoreApplication.translate("MainWindow","Date and time at the end of execution of the script:  ")+str_fin+"\n"
    resume_texte += QCoreApplication.translate("MainWindow","Total execution time of the script:                   ")+str_duree+"\n\n"
    resume_texte += "" .join (["_"]*80) + "\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","PARAMETERS USED FOR THE MODELING:\n\n")
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum uphill distance for winching:                        ")+str(Dtreuil_max_up)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum downhill distance for winching:                      ")+str(Dtreuil_max_down)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope to get maximum uphill winching distance:       ")+str(Pmax_amont)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope to get maximum downhill winching distance:     ")+str(Pmax_aval)+" %\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum distance outside forest and forest road network:     ")+str(Dmax_train_near_for)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for a free access of the parcels with skidder: ")+str(Pente_max_skidder)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for manual felling of the trees:               ")+str(Pente_max_bucheron)+" %\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Simulation option:\n"  )  
    if Option_Skidder==1:
        resume_texte += QCoreApplication.translate("MainWindow","      * Limit soil damages: force the skidder to process as much as possible \n")    
        resume_texte += QCoreApplication.translate("MainWindow","        from the forest road network\n" )
    else:
        resume_texte += QCoreApplication.translate("MainWindow","      * Limit winching distances: force the skidder to go as close as possible\n")    
        resume_texte += QCoreApplication.translate("MainWindow","        to the timber\n" )
    if Dir_Full_Obs_skidder!='':
        resume_texte += QCoreApplication.translate("MainWindow","      * Simulation with areas where skidder operations are forbidden (Full obstacles)\n" ) 
    if Dir_Partial_Obs_skidder!='':
        resume_texte += QCoreApplication.translate("MainWindow","      * Simulation with areas where skidding is forbidden but winching possible (Partial obstacles)\n" ) 
        
    if os.path.exists(Rspace_s+"Forest_tracks_not_connected.tif"):
        resume_texte += "\n\n"
        resume_texte += "".join(["_" * 80])
        resume_texte += QCoreApplication.translate("MainWindow","      !!! Warning !!! Some forest tracks are not connected to public network.\n")  
        resume_texte += QCoreApplication.translate("MainWindow","      They were removed from the analysis.\n")  
    if os.path.exists(Rspace_s+"Forest_road_not_connected.tif"):
        resume_texte += "".join(["_" * 80])
        resume_texte += "\n\n" + QCoreApplication.translate("MainWindow","      !!! Warning !!! Some forest roads are not connected to public network.\n")  
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    
        
        
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    console_info(QCoreApplication.translate("MainWindow","Skidder model finished"))
    clear_big_nparray()
    gc.collect()
    

def create_new_road_network(file_shp_Desserte,Wspace):
    Dir_temp = Wspace+"Temp/"    
    try:os.mkdir(Dir_temp)
    except:pass 
    File_fin = Dir_temp+"Existing_roads.shp"    
    source_ds = ogr.Open(file_shp_Desserte)
    source_layer = source_ds.GetLayer()
    source_src = source_layer.GetSpatialRef()
    driver = ogr.GetDriverByName('ESRI Shapefile')
    target_ds = driver.CreateDataSource(File_fin)
    layerName = os.path.splitext(os.path.split(File_fin)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn("CL_SVAC", ogr.OFTInteger)
    layer.CreateField(new_field)
    for feat in source_layer:
        geometry = feat.GetGeometryRef()
        label = feat.GetField('EXIST')
        if label == 2:
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetField("CL_SVAC",feat.GetField("CL_SVAC"))
            layer.CreateFeature(feature)
            feature.Destroy()
    source_ds.Destroy()
    target_ds.Destroy()
    return File_fin


def make_summary_surface_vol(Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,Dtotal,Vtot,Vtot_non_buch,Rspace_s,modele_name):
    Skid_list = Debclass.split(";")
    nbclass = len(Skid_list)
    file_name = str(Rspace_s)+"Summary_results_Sylvaccess_"+modele_name+".txt" 
    vol = False

    #SURFACE
    Surf_Cum = 0 
    recap_surface = []
    totaux_surface = []

    for i in range(1, nbclass):
        dmin, dmax = int(Skid_list[i - 1]), int(Skid_list[i])
        class_text = f"{dmin} - {dmax} m"
        Temp = np.sum((Dtotal >= dmin) * (Dtotal < dmax) * Csize * Csize * 0.0001)
        recap_surface.append(class_text)
        recap_surface.append(str(round(Temp, 1)))
        recap_surface.append(str(round(Temp / Surf_foret * 100, 1)))
        recap_surface.append(str(round(Temp + Surf_Cum, 1)))
        recap_surface.append(str(round((Temp + Surf_Cum) / Surf_foret * 100, 1)))
        Surf_Cum += Temp

    # Ajouter la classe de distance infinie
    dmin = Skid_list[nbclass - 1]
    if dmin.isdigit():
        dmin = int(dmin)
        try:
            Temp = np.sum((Dtotal >= dmin) * Csize * Csize * 0.0001)
            recap_surface.append(f"> {dmin} m")
            recap_surface.append(str(round(Temp, 1)))
            recap_surface.append(str(round(Temp / Surf_foret * 100, 1)))
            recap_surface.append(str(round(Temp + Surf_Cum, 1)))
            recap_surface.append(str(round((Temp + Surf_Cum) / Surf_foret * 100, 1)))
            Surf_Cum += Temp
        except ValueError as e:
            console_warning(QCoreApplication.translate("MainWindow","Error converting '{dmin}' to an integer. Skid_list: {Skid_list}", dmin=dmin, Skid_list=Skid_list))
            console_warning(QCoreApplication.translate("MainWindow","Dtotal: {Dtotal}", Dtotal=Dtotal))
            Sylvaccess_UI.close()
            raise e
    else:
        console_warning(QCoreApplication.translate("MainWindow","Invalid literal for int() with base 10: '{dmin}'. Skid_list: {Skid_list}", dmin=dmin, Skid_list=Skid_list))
        Sylvaccess_UI.close()
        raise ValueError(QCoreApplication.translate("MainWindow","Invalid literal for int() with base 10: '{dmin}'", dmin=dmin))


    # Calcul des totaux
    totaux_surface.append(str(round(Surf_Cum, 1)) + " ha")
    totaux_surface.append(str(round(Surf_Cum / Surf_foret * 100, 1)) + " %")
    totaux_surface.append(str(round(Surf_foret - Surf_Cum, 1)) + " ha")
    totaux_surface.append(str(round((Surf_foret - Surf_Cum) / Surf_foret * 100, 1)) + " %")
    totaux_surface.append(str(round(Surf_foret_non_access, 1)) + " ha")
    totaux_surface.append(str(round(Surf_foret_non_access / Surf_foret * 100, 1)) + " %")
    totaux_surface.append(str(round(Surf_foret, 1)) + " ha")
            
    #VOLUME            
    recap_volume = []
    totaux_volume = []

    if file_Vol_ha != "":
        vol = True
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)] = 0

        # Créer des tableaux pour les classes de distance et les valeurs associées
        classes_distance = []
        valeurs_associees = []

        # Create recap per distance class
        Vol_Cum = 0
        for i in range(1, nbclass):
            dmin, dmax = int(Skid_list[i - 1]), int(Skid_list[i])
            Temp = ((Dtotal >= dmin) * (Dtotal < dmax) * (Vol_ha >= 0)) > 0
            if np.sum(Temp > 0):
                Vclass = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
            else:
                Vclass = 0
            classes_distance.append(f"{dmin}-{dmax}")
            valeurs_associees.append(Vclass)

        # Ajouter la classe de distance infinie
        dmin = int(Skid_list[nbclass - 1])
        Temp = ((Dtotal >= dmin) * (Vol_ha >= 0)) > 0
        if np.sum(Temp > 0):
            Vclass = np.mean(Vol_ha[Temp]) * np.sum(Temp) * Csize * Csize * 0.0001
        else:
            Vclass = 0
        classes_distance.append(f"{dmin}-inf")
        valeurs_associees.append(Vclass)

        # Enregistrer les valeurs cumulées
        Vol_Cum = 0
        for i in range(len(classes_distance)):
            Vol_Cum += valeurs_associees[i]
            recap_volume.append(classes_distance[i])
            recap_volume.append(str(int(valeurs_associees[i] + 0.5)))
            recap_volume.append(str(round(valeurs_associees[i] / Vtot * 100, 1)))
            recap_volume.append(str(int(valeurs_associees[i] + Vol_Cum + 0.5)))
            recap_volume.append(str(round(100 * (valeurs_associees[i] + Vol_Cum) / Vtot, 1)))

        # Ajouter les totaux
        totaux_volume.append(str(int(Vol_Cum + 0.5)) + " m3")
        totaux_volume.append(str(round(100 * Vol_Cum / Vtot, 1)) + " %")
        totaux_volume.append(str(int(Vtot - Vol_Cum + 0.5)) + " m3")
        totaux_volume.append(str(round(100 * (Vtot - Vol_Cum) / Vtot, 1)) + " %")
        totaux_volume.append(str(int(Vtot_non_buch + 0.5)) + " m3")
        totaux_volume.append(str(round(100 * (Vtot_non_buch) / Vtot, 1)) + " %")
        totaux_volume.append(str(int(Vtot + 0.5)) + " m3")

    # Les en-têtes des colonnes dans le fichier texte
    headers =QCoreApplication.translate("MainWindow", "Total yarding distance |   Surface area (ha)   | Surface per class (%) |Cumulative surface (ha)|Cumulative surface (%) \n", " each section between | has to be 23 character wide to retain the layout")
    headers2= QCoreApplication.translate("MainWindow","Total yarding distance |      Volume (m3)      | Volume per class (%)  |Cumulative volume (m3) |Cumulative volume (%) \n" , " each section between | has to be 23 character wide to retain the layout")

    # Ajouter des espaces pour que les colonnes aient la même largeur
    recap_surface = [str(elem) for elem in recap_surface]
    recap_surface = [elem.ljust(30) for elem in recap_surface]
    recap_volume = [str(elem) for elem in recap_volume]
    recap_volume = [elem.ljust(30) for elem in recap_volume]

    # Données des tableaux
    data = zip(recap_surface[::5], recap_surface[1::5], recap_surface[2::5], recap_surface[3::5], recap_surface[4::5])
    data2 = zip(recap_volume[::5], recap_volume[1::5], recap_volume[2::5], recap_volume[3::5], recap_volume[4::5])
    # Écriture dans le fichier
    with open(file_name, "w") as file:
        # Écriture des en-têtes
        file.write(headers)
        # Écriture des données
        for row in data:
            file.write("|".join(row) + "\n")
        file.write("".join(["_" * len(headers)]))
        file.write("\n\n")
        file.write(QCoreApplication.translate("MainWindow","Total accessible forest") + ":   " + totaux_surface[0] + ";  " + totaux_surface[1] + "\n")
        file.write(QCoreApplication.translate("MainWindow","Total unaccessible forest") + ": " + totaux_surface[2] + ";  " + totaux_surface[3] + "\n")
        file.write(QCoreApplication.translate("MainWindow","    --> including impossible manual felling") + ":   " + totaux_surface[4] + ";" + totaux_surface[5] + "\n") 
        file.write("".join(["_" * len(headers)]))
        file.write("\n\n")
        file.write(QCoreApplication.translate("MainWindow","Total area of forest :") + "   " + totaux_surface[6] + "\n")
        if vol:
            file.write(headers2)
            for row in data2:
                file.write("|".join(row) + "\n")


def make_dif_files(Rspace, idmod):  # idmod 0 : Skidder, 1 : Forwarder
    Modele = ["Skidder","Forwarder"]
    Rspace_s = Rspace+Modele[idmod]+"/"
    filename = "Summary_results_Sylvaccess_"+Modele[idmod]+".txt"
    rastname = "Total_distance.tif"
    foldExist = Rspace_s+"1_Existing/"
    foldProj = Rspace_s+"2_Project/"
    txtname = Rspace_s+"Comparison_before_after_project.txt"
    shpname = "Impacted_area"
        

    #Shapefile des differences
    _,values,_,Extent = raster_get_info(foldExist+rastname)
    Csize = values[4]
    DExist =  load_float_raster_simple(foldExist+rastname)
    DProj =  load_float_raster_simple(foldProj+rastname)
    nrows,ncols = DProj.shape
    Diff2 = DExist-DProj
    Diff2[DExist==-9999]=0
    Diff2[DProj==-9999]=0
    Diff = np.zeros_like(DExist,dtype=np.int8)
    Diff[((DExist==-9999)*(DProj>=0))>0] = 1 #Nouvel accessible
    Diff[((Diff2>0)*(Diff2<500))>0] = 2 
    Diff[((Diff2>500)*(Diff2<1000))>0] = 3
    Diff[((Diff2>1000)*(Diff2<1500))>0] = 4
    Diff[Diff2>1500] = 5
    Surf_impact = round(np.sum(Diff>0)*Csize*Csize/10000,1)
    road_network_proj=get_proj_from_road_network(foldExist+Modele[idmod]+"_recap_accessibility.shp")
    source_src=get_source_src(foldExist+Modele[idmod]+"_recap_accessibility.shp") 

       
    ArrayToGtiff(Diff,Rspace_s+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    del DExist,DProj,Diff2,Diff
    gc.collect()
    
    label =  QCoreApplication.translate("MainWindow",["","0_New accessible area","4_Shortened distance from 1 to 500m",
               "3_Shortened distance from 500 to 999m", "2_Shortened distance from 1000 to 1499m",
               "1_Shortened distance of at least 1500m"])

    
    ds = gdal.Open(Rspace_s+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("GPKG")
    dst_ds = drv.CreateDataSource( Rspace_s+shpname+".gpkg")
    dst_layer = dst_ds.CreateLayer(shpname, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds = None
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
            feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()    
    
    os.remove(Rspace_s+"Recap.tif")
    
    
    #Tableau des differences   
    TabExist = np.loadtxt(foldExist+filename,dtype='|U39',delimiter=";")
    TabProj = np.loadtxt(foldProj+filename,dtype='|U39',delimiter=";")
    if TabExist.shape[1]<6:        
        colrecap=[1,2]       
    else:        
        colrecap=[1,2,5,6] 
    Table = np.empty((TabExist.shape[0]-3,TabExist.shape[1]),dtype='|U39')    
    Table[0:-3,0]=TabExist[0:-6,0]
    for i in range(1,Table.shape[1]):
        Table[0,i]=str("Diff. ")+TabExist[0,i]
    
    for i in range(1,TabExist.shape[0]-6):
        for j in range(1,Table.shape[1]):
            Table[i,j]=round(float(TabProj[i,j])-float(TabExist[i,j]),1)
    
        Table[-2,0]=QCoreApplication.translate("MainWindow","Total supplementary forest area")
        Table[-1,0]=QCoreApplication.translate("MainWindow","Impacted forest area")
            
    for i in colrecap:
        Table[-2,i]=round(np.sum(np.float32(Table[1:-3,i])),1)
        
    Table[-1,1:3]=Surf_impact,round(Surf_impact/float(TabExist[-1,1][:-3])*100,1)   
    np.savetxt(txtname, Table,fmt='%s', delimiter=';') 


def prepa_obstacle_skidder(Obstacles_directory,Extent,Csize,ncols,nrows,Rast_desserte_ok):
    liste_file = os.listdir(Obstacles_directory)
    liste_obs = []
    for files in liste_file:
        if files[-4:len(files)] == '.shp' or files[-4:len(files)] == '.gbkg':
            liste_obs.append(Obstacles_directory+files)
    if len(liste_obs)>0:
        Obstacles_skidder = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        Temp = (Rast_desserte_ok>0)
        Obstacles_skidder[Temp] = 0
    else: Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    return Obstacles_skidder


def create_buffer_skidder(Csize,Dtreuil_max_up,Dtreuil_max_down):
    Lcote = max(Dtreuil_max_up,Dtreuil_max_down)+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((max(Dtreuil_max_up,Dtreuil_max_down)/Csize+1.5))
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float32)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)    
    for az in Dir_list:
        #Fill line info
        _,_,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lcote,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],3))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix        
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line


def create_access_shapefile(Dtotal,Rspace_s,Foret,HarvClass_list,road_network_proj,source_src,Dir_temp,Extent,nrows,ncols,layer_name):
    Recap = np.copy(Foret)
    #0: no Forest
    #1: inaccessible forest
    #2: Non_buch
    #Then harvesting classes
    label = [QCoreApplication.translate("MainWindow","Non-forest area"),QCoreApplication.translate("MainWindow","Inaccessible forest"),QCoreApplication.translate("MainWindow","Non harvestable (too steep slope)")]
    nbclass = len(HarvClass_list)    
    for i in range(1,nbclass):
        dmin,dmax = int(HarvClass_list[i-1]),int(HarvClass_list[i])
        label.append(QCoreApplication.translate("MainWindow","Accessible - Skidding class ")+str(i)+': '+str(HarvClass_list[i-1])+" - "+str(HarvClass_list[i])+" m")
        Temp = ((Dtotal>=dmin)*(Dtotal<dmax)*(Foret==1))>0
        Recap[Temp]=2+i
    #add infinite distance class 
    dmin = int(HarvClass_list[nbclass-1])
    label.append(QCoreApplication.translate("MainWindow","Accessible - Skidding class ")+str(nbclass)+" : > "+str(dmin)+" m")
    Temp = ((Dtotal>=dmin)*(Foret==1))>0
    Recap[Temp]=2+nbclass
    #Get area too slopy for harvesting
    Temp = load_float_raster_simple(Rspace_s+'Manual_harvesting.tif')
    Temp = ((Temp!=1)*(Foret==1))>0
    Recap[Temp]=2
    #Save as Gtiff
    ArrayToGtiff(Recap,Dir_temp+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    #Convert to shape
    type_mapping = { gdal.GDT_Byte: ogr.OFTInteger,
                 gdal.GDT_UInt16: ogr.OFTInteger,   
                 gdal.GDT_Int16: ogr.OFTInteger,    
                 gdal.GDT_UInt32: ogr.OFTInteger,
                 gdal.GDT_Int32: ogr.OFTInteger,
                 gdal.GDT_Float32: ogr.OFTReal,
                 gdal.GDT_Float64: ogr.OFTReal,
                 gdal.GDT_CInt16: ogr.OFTInteger,
                 gdal.GDT_CInt32: ogr.OFTInteger,
                 gdal.GDT_CFloat32: ogr.OFTReal,
                 gdal.GDT_CFloat64: ogr.OFTReal}

    ds = gdal.Open(Dir_temp+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("GPKG")
    dst_ds = drv.CreateDataSource( Rspace_s+layer_name+".gpkg" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', type_mapping[srcband.DataType])
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds.FlushCache()
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
        feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()


def create_arrays_from_roads(source_shapefile,Extent,Csize):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #Recupere le driver
    #Get information from source shapefile
    source_ds = ogr.Open(source_shapefile)
    source_layer = source_ds.GetLayer()    
    source_type = source_layer.GetGeomType()
    source_srs = source_layer.GetSpatialRef()
    ###################################################
    ###                                                      __     __ __       
    ###.----.-----.-----.-----.---.-.--.--.    .-----.--.--.|  |--.|  |__|.----.
    ###|   _|  -__|__ --|  -__|  _  |  |  |    |  _  |  |  ||  _  ||  |  ||  __|
    ###|__| |_____|_____|_____|___._|_____|    |   __|_____||_____||__|__||____|
    ###                                        |__|                                 
    expression = '"CL_SVAC" = 3'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Res_pub = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###                   __               ___                          __   __                   
    ###.----.-----.--.--.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|   _|  _  |  |  ||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|__| |_____|_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
                                                                                           
    expression = '"CL_SVAC" = 2'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Route_For = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###        __         __               ___                          __   __                   
    ###.-----.|__|.-----.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|  _  ||  ||__ --||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|   __||__||_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
    ###|__|                                                                                       
    expression = '"CL_SVAC" = 1'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Piste = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    source_ds.Destroy()    
    return Res_pub,Route_For,Piste


def prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder):
    console_info(QCoreApplication.translate("MainWindow","Pre-processing of the inputs for skidder model"))
    ### Make directory for temporary files
    Dir_temp = Wspace+"Temp/"
    try:os.mkdir(Dir_temp)
    except:pass 
    Rspace_s = Rspace+"Skidder/"
    try:os.mkdir(Rspace_s)
    except:pass
    ##############################################################################################################################################
    ### Initialization
    ##############################################################################################################################################
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    ##############################################################################################################################################
    ### Forest : shapefile to raster
    ##############################################################################################################################################
    Foret = shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET")
    np.save(Dir_temp+"Foret",np.int8(Foret))    
    del Foret
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Forest raster processed"))
        
    ##############################################################################################################################################
    ### Calculation of a slope raster and a cost raster of slope
    ##############################################################################################################################################
    # Slope raster
    MNT,Extent,Csize,_ = load_float_raster(file_MNT,Dir_temp)
    np.save(Dir_temp+"MNT",np.float32(MNT))
    Pente = pente(MNT,Csize,-9999)
    np.save(Dir_temp+"Pente",np.float32(Pente))    
    # Cost raster of slope
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    np.save(Dir_temp+"Pond_pente",np.float32(Pond_pente))
    # Report a success message   
    del Pente,MNT
    gc.collect()
    console_info(QCoreApplication.translate("MainWindow","    - Slope raster processed")  )
    ##############################################################################################################################################
    ### Road network processing
    ##############################################################################################################################################
    Res_pub,Route_for,Piste= create_arrays_from_roads(file_shp_Desserte,Extent,Csize)
    np.save(Dir_temp+"Res_pub",Res_pub)  
    ##############################################################################################################################################
    ### Forest road network processing
    ##############################################################################################################################################
    pixels = np.argwhere(Res_pub==1) 
    # Give an identifiant to each public network pixel    
    ID = 1    
    Tab_res_pub = np.zeros((pixels.shape[0]+1,2),dtype=np.int32) 
    for pixel in pixels:
        Tab_res_pub[ID,0],Tab_res_pub[ID,1]=pixel[0],pixel[1]
        ID +=1         
    np.save(Dir_temp+"Tab_res_pub",Tab_res_pub)
    pixels = np.argwhere(Route_for==1)
    #num_ligne = id_RF, Y, X, Dtransp,Lien_Respub
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.float32)     
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=100001
        ID +=1 
    # Link RF with res_pub and calculate transportation distance
    Lien_RF=Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for,Res_pub, Lien_RF,Csize) 
    Lien_RF[:,2]=np.int_(Lien_RF[:,2]+0.5)
    Lien_RF=Lien_RF.astype('int')
    Temp = (Lien_RF[:,3]>0)*(Lien_RF[:,2]==0)
    Lien_RF=Lien_RF[Temp==0]    
    np.save(Dir_temp+"Lien_RF",Lien_RF)
    # Check if all Forest road are linked to public network    
    if np.max(Lien_RF[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_RF[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_RF[ind,0],Lien_RF[ind,1]]=1        
        ArrayToGtiff(RF_bad,Rspace_s+'Forest_road_not_connected',Extent,nrows,ncols,road_network_proj,0,'UINT8')
        console_info(QCoreApplication.translate("MainWindow","    - Some forest road are not connected to public network. To see where, check raster "+Rspace_s+"Forest_road_not_connected.tif"))
    else:
        console_info(QCoreApplication.translate("MainWindow","    - Forest road processed") )
            
    ##############################################################################################################################################
    ### Forest tracks network processing
    ##############################################################################################################################################
    # Tracks
    pixels = np.argwhere(Piste==1)
    #num_ligne = id_piste, Y, X, Dpiste,Dtransp,Lien_RF, Lien_Respub,
    Lien_piste = np.zeros((pixels.shape[0]+1,7),dtype=np.float32)    
    ID = 1
    for pixel in pixels:
        Lien_piste[ID,0],Lien_piste[ID,1]=pixel[0],pixel[1]
        Lien_piste[ID,4]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_piste[ID,2]=-9999
        else:
            Lien_piste[ID,2]=100001
        ID +=1
    Lien_piste=Link_tracks_res_pub(Tab_res_pub,Lien_RF,Pond_pente,Piste,Route_for,Res_pub,Lien_piste,Csize)
    Lien_piste[:,2]=np.int_(Lien_piste[:,2]+0.5)
    Lien_piste=Lien_piste.astype('int')
    Temp = (Lien_piste[:,5]>0)*(Lien_piste[:,2]==0)
    Lien_piste=Lien_piste[Temp==0]    
    ind = np.lexsort((Lien_piste[:,1],Lien_piste[:,2]))
    Lien_piste=Lien_piste[ind]
    np.save(Dir_temp+"Lien_piste",Lien_piste) 
    if np.max(Lien_piste[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_piste[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_piste[ind,0],Lien_piste[ind,1]]=1   
            Piste[Lien_piste[ind,0],Lien_piste[ind,1]]=0
            ArrayToGtiff(RF_bad,Rspace_s+'Forest_tracks_not_connected',Extent,nrows,ncols,road_network_proj,0,'UINT8')
            console_info(QCoreApplication.translate("MainWindow","    - Some forest tracks are not connected to public network or forest road."))
            console_info(QCoreApplication.translate("MainWindow","      To see where, check raster "+Rspace_s+"Forest_tracks_not_connected.tif"))
    else:
        console_info(QCoreApplication.translate("MainWindow","    - Forest tracks processed"))  
    Route_for[Res_pub==1]=0
    Piste[Res_pub==1]=0
    np.save(Dir_temp+"Route_for",Route_for) 
    np.save(Dir_temp+"Piste",np.int8(Piste))
    del Tab_res_pub,Lien_RF,Lien_piste,Res_pub  
    gc.collect()     
    ##############################################################################################################################################
    ### Create a raster of total obstacle for skidder
    ##############################################################################################################################################
    if Dir_Full_Obs_skidder!="":
        Full_Obstacles_skidder = prepa_obstacle_skidder(Dir_Full_Obs_skidder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))
    else:
        Full_Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Full_Obstacles_skidder",np.int8(Full_Obstacles_skidder))  
    console_info(QCoreApplication.translate("MainWindow","    - Skidder total obstacle raster processed"))
    ##############################################################################################################################################
    ### Create a raster of partial obstacle for skidder
    ##############################################################################################################################################
    if Dir_Partial_Obs_skidder!="":
        Partial_Obstacles_skidder = prepa_obstacle_skidder(Dir_Partial_Obs_skidder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))        
    else:
        Partial_Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Partial_Obstacles_skidder",np.int8(Partial_Obstacles_skidder))  
    console_info(QCoreApplication.translate("MainWindow","    - Skidder partial obstacle raster processed"))
    console_info(QCoreApplication.translate("MainWindow","Input data processing achieved"))
    ##############################################################################################################################################
    ### Close the script
    ##############################################################################################################################################
    clear_big_nparray()
    gc.collect()


###########################################################################
#.______     ______   .______  .___________. _______  __    __  .______   #
#|   _  \   /  __  \  |   _  \ |           ||   ____||  |  |  | |   _  \  #
#|  |_)  | |  |  |  | |  |_)  |`---|  |----`|  |__   |  |  |  | |  |_)  | #
#|   ___/  |  |  |  | |      /     |  |     |   __|  |  |  |  | |      /  #
#|  |      |  `--'  | |  |\  \-.   |  |     |  |____ |  `--'  | |  |\  \-.#
#| _|       \______/  | _| `.__|   |__|     |_______| \______/  | _| `.__|#
# #########################################################################                                                                               

  
def prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder):
    console_info(QCoreApplication.translate("MainWindow","Pre-processing of the inputs for forwarder model"))
    ### Make directory for temporary files
    Dir_temp = Wspace+"Temp/"
    try:os.mkdir(Dir_temp)
    except:pass 
    Rspace_f = Rspace+"Forwarder/"
    try:os.mkdir(Rspace_f)
    except:pass
    ##############################################################################################################################################
    ### Initialization
    ##############################################################################################################################################
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    ##############################################################################################################################################
    ### Forest : shapefile to raster
    ##############################################################################################################################################
    Foret = shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET")
    np.save(Dir_temp+"Foret",np.int8(Foret))    
    del Foret
    console_info(QCoreApplication.translate("MainWindow","    - Forest raster processe"))
    ##############################################################################################################################################
    ### Calculation of a slope raster and a cost raster of slope
    ##############################################################################################################################################
    # Slope raster
    MNT,Extent,Csize,_ = load_float_raster(file_MNT,Dir_temp)
    np.save(Dir_temp+"MNT",np.float32(MNT))      
    Pente = pente(MNT,Csize,-9999)
    np.save(Dir_temp+"Pente",np.float32(Pente))    
    Exposition = np.int16(exposition(MNT,Csize,-9999)+0.5)
    Exposition[Pente==-9999] = -9999
    np.save(Dir_temp+"Aspect",Exposition) 
    # Cost raster of slope
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    np.save(Dir_temp+"Pond_pente",np.float32(Pond_pente))
    # Report a success message   
    del Pente,MNT,Exposition
    console_info(QCoreApplication.translate("MainWindow","    - Slope and aspects rasters processed"))  
    ##############################################################################################################################################
    ### Road network processing
    ##############################################################################################################################################
    Res_pub,Route_for,Piste= create_arrays_from_roads(file_shp_Desserte,Extent,Csize)
    np.save(Dir_temp+"Res_pub",Res_pub)  
    ##############################################################################################################################################
    ### Forest road network processing
    ##############################################################################################################################################
    pixels = np.argwhere(Res_pub==1) 
    # Give an identifiant to each public network pixel    
    ID = 1    
    Tab_res_pub = np.zeros((pixels.shape[0]+1,2),dtype=np.int32) 
    for pixel in pixels:
        Tab_res_pub[ID,0],Tab_res_pub[ID,1]=pixel[0],pixel[1]
        ID +=1         
    np.save(Dir_temp+"Tab_res_pub",Tab_res_pub)
    pixels = np.argwhere(Route_for==1)
    #num_ligne = id_RF, Y, X, Dtransp,Lien_Respub
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.float32)     
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=100001
        ID +=1 
    # Link RF with res_pub and calculate transportation distance
    Lien_RF=Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for,Res_pub, Lien_RF,Csize) 
    Lien_RF[:,2]=np.int_(Lien_RF[:,2]+0.5)
    Lien_RF=Lien_RF.astype('int')
    Temp = (Lien_RF[:,3]>0)*(Lien_RF[:,2]==0)
    Lien_RF=Lien_RF[Temp==0]    
    np.save(Dir_temp+"Lien_RF",Lien_RF)
    # Check if all Forest road are linked to public network    
    if np.max(Lien_RF[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_RF[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_RF[ind,0],Lien_RF[ind,1]]=1        
        ArrayToGtiff(RF_bad,Rspace_f+'Forest_road_not_connected',Extent,nrows,ncols,road_network_proj,0,'UINT8')
        console_info(QCoreApplication.translate("MainWindow","    - Some forest road are not connected to public network. To see where, check raster ")+Rspace_f+"Forest_road_not_connected.tif")
    else:
        console_info(QCoreApplication.translate("MainWindow","    - Forest road processed")) 
             
    ##############################################################################################################################################
    ### Forest tracks network processing
    ##############################################################################################################################################
    pixels = np.argwhere(Piste==1)
    #num_ligne = id_piste, Y, X, Dpiste,Dtransp,Lien_RF, Lien_Respub,
    Lien_piste = np.zeros((pixels.shape[0]+1,7),dtype=np.float32)    
    ID = 1
    for pixel in pixels:
        Lien_piste[ID,0],Lien_piste[ID,1]=pixel[0],pixel[1]
        Lien_piste[ID,4]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_piste[ID,2]=-9999
        else:
            Lien_piste[ID,2]=100001
        ID +=1
    Lien_piste=Link_tracks_res_pub(Tab_res_pub,Lien_RF,Pond_pente,Piste,Route_for,Res_pub,Lien_piste,Csize)
    Lien_piste[:,2]=np.int_(Lien_piste[:,2]+0.5)
    Lien_piste=Lien_piste.astype('int')
    Temp = (Lien_piste[:,5]>0)*(Lien_piste[:,2]==0)
    Lien_piste=Lien_piste[Temp==0]    
    ind = np.lexsort((Lien_piste[:,1],Lien_piste[:,2]))
    Lien_piste=Lien_piste[ind]
    np.save(Dir_temp+"Lien_piste",Lien_piste) 
    if np.max(Lien_piste[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_piste[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_piste[ind,0],Lien_piste[ind,1]]=1   
            Piste[Lien_piste[ind,0],Lien_piste[ind,1]]=0
            ArrayToGtiff(RF_bad,Rspace_f+'Forest_tracks_not_connected',Extent,nrows,ncols,Csize,road_network_proj,0,'UINT8')
            console_info(QCoreApplication.translate("MainWindow","    - Some forest tracks are not connected to public network or forest road."))
            console_info(QCoreApplication.translate("MainWindow","      To see where, check raster "+Rspace_f+"Forest_tracks_not_connected.tif"))
    else:
        console_info(QCoreApplication.translate("MainWindow","    - Forest road processed"))  
    Route_for[Res_pub==1]=0
    Piste[Res_pub==1]=0
    np.save(Dir_temp+"Route_for",Route_for) 
    np.save(Dir_temp+"Piste",np.int8(Piste))
    del Tab_res_pub,Lien_RF,Lien_piste,Res_pub  
    gc.collect() 
    ##############################################################################################################################################
    ### Create a raster of total obstacle for forwarder
    ##############################################################################################################################################
    if Dir_Obs_forwarder!="":
        Obstacles_forwarder = prepa_obstacle_skidder(Dir_Obs_forwarder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))
    else:
        Obstacles_forwarder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Obstacles_forwarder",np.int8(Obstacles_forwarder))    
    console_info(QCoreApplication.translate("MainWindow","    - Forwarder obstacles raster processed")) 
    console_info(QCoreApplication.translate("MainWindow","Input data processing achieved"))
    ##############################################################################################################################################
    ### Close the script
    ##############################################################################################################################################
    clear_big_nparray()


def process_forwarder():
    Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,_,_,_,Dir_Obs_forwarder,_,file_Vol_ha,_,_ = Sylvaccess_UI.get_spatial_cls()
    _,_,_,_,Pente_max_bucheron = Sylvaccess_UI.get_general_cls()
    Forw_angle_incl,Forw_angle_up,Forw_angle_down,Forw_Lmax,Forw_Dmax_out_for,Forw_portee,Forw_Debclass=Sylvaccess_UI.get_Forwarder_cls()

    console_info(QCoreApplication.translate("MainWindow","Sylvaccess - Forwarder starts"))

    ###############################################################################################################################################
    ### Initialisation
    ###############################################################################################################################################
    Hdebut = datetime.datetime.now()
    
    # Create a folder for process result
    Rspace_s = Rspace+"Forwarder/"
    try:os.mkdir(Rspace_s)
    except:pass
    Dir_temp = Wspace+"Temp/"
    
    # Check if temporary files have been generated and have the same extent
    try:
        _,values,_,Extent = raster_get_info(file_MNT)
    except:
        console_info(QCoreApplication.translate("MainWindow","Error: please define a projection for the DTM raster"))
        return ""    
    try: 
        _,v1=read_info(Dir_temp+'info_extent.txt')
        for i,item in enumerate(values):
            if v1[i]!=round(item,2):
                prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder)
            if i+1>4:break
    except:
        prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder)
    
    Csize = values[4]
    # Inputs
    try:
        Foret = np.int8(np.load(Dir_temp+"Foret.npy"))
        Piste = np.int8(np.load(Dir_temp+"Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp+"Route_for.npy"))        
        Lien_piste = np.load(Dir_temp+"Lien_piste.npy")
        Res_pub = np.int8(np.load(Dir_temp+"Res_pub.npy"))
        Lien_RF = np.load(Dir_temp+"Lien_RF.npy")
        Pente = np.load(Dir_temp+"Pente.npy")
        Pond_pente = np.load(Dir_temp+"Pond_pente.npy")
        MNT = np.load(Dir_temp+"MNT.npy")
        try:
            Aspect = np.load(Dir_temp+"Aspect.npy")    
        except:
            Aspect = np.int16(exposition(np.float_(MNT),Csize,-9999))
            Aspect[Pente==-9999] = -9999
            np.save(Dir_temp+"Aspect",Aspect)             
        try:
            Obstacles_forwarder = np.int8(np.load(Dir_temp+"Obstacles_forwarder.npy"))
        except:
            nrows,ncols = MNT.shape[0],MNT.shape[1]
            if Dir_Obs_forwarder!="":
                Obstacles_forwarder = np.int8(prepa_obstacle_skidder(Dir_Obs_forwarder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1)))
            else:
                Obstacles_forwarder = np.zeros((nrows,ncols),dtype=np.int8)
                np.save(Dir_temp+"Obstacles_forwarder",np.int8(Obstacles_forwarder)) 
    except: 
        prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder)
        Foret = np.int8(np.load(Dir_temp+"Foret.npy"))
        Piste = np.int8(np.load(Dir_temp+"Piste.npy"))
        Res_pub = np.int8(np.load(Dir_temp+"Res_pub.npy"))
        Route_for = np.int8(np.load(Dir_temp+"Route_for.npy"))        
        Lien_piste = np.load(Dir_temp+"Lien_piste.npy")
        Lien_RF = np.load(Dir_temp+"Lien_RF.npy")
        Pente = np.load(Dir_temp+"Pente.npy")
        Pond_pente = np.load(Dir_temp+"Pond_pente.npy")
        MNT = np.load(Dir_temp+"MNT.npy")
        Aspect = np.load(Dir_temp+"Aspect.npy")
        Obstacles_forwarder = np.int8(np.load(Dir_temp+"Obstacles_forwarder.npy"))
    
    # Generate useful variable for the process
    nrows,ncols = MNT.shape[0],MNT.shape[1]
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    Fwd_max_inc = math.degrees(math.atan(Forw_angle_incl*0.01))
    Fwd_max_up = math.degrees(math.atan(Forw_angle_up*0.01))
    Fwd_max_down = math.degrees(math.atan(Forw_angle_down*0.01))
    Pond_pente[Obstacles_forwarder==1] = 1000
    Manual_harvesting = np.int8((focal_stat_max(np.float_(Pente),-9999,1)<=Pente_max_bucheron))
    MNT_OK = np.int8((MNT!=values[5]))
    Pente_deg = np.degrees(np.arctan(Pente*0.01))
    Pente_deg[Pente==-9999]=-9999        
        
    Pente_ok_forw = np.int8((Pente_deg<=min(Fwd_max_inc,Fwd_max_up,Fwd_max_down))*(Pente_deg > -9999))    
    
    Surf_foret = np.sum((Foret==1)*MNT_OK)*Csize*Csize*0.0001
    Surf_foret_non_access = int(np.sum((Manual_harvesting==0)*(Foret==1)*MNT_OK*Csize*Csize*0.0001)+0.5)
    
    Row_line,Col_line,D_line,Nbpix_line=create_buffer_skidder(Csize,Forw_Lmax,Forw_Lmax)
    
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)]=0
        Temp = ((Vol_ha>0)*(Foret==1)*MNT_OK)>0
        Vtot = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        Temp = ((Vol_ha>0)*(Manual_harvesting==0)*(Foret==1)*MNT_OK)>0
        Vtot_non_buch = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        del Vol_ha,Temp
    else:
        Vtot=0    
        Vtot_non_buch =0
       
        ArrayToGtiff(Manual_harvesting,Rspace_s+'Manual_harvesting',Extent,nrows,ncols,road_network_proj,0,'UINT8')
        console_info(QCoreApplication.translate("MainWindow","    - Initialization achieved"))   
    del Pente
    gc.collect()     
    
    ###############################################################################################################################################    
    ### Calculation of skidding distance inside the forest stands
    ###############################################################################################################################################                  
    # Identify the forest area that may be run through by the skidder
    zone_rast = Pente_ok_forw*(Foret==1)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    from_rast = np.int8(((Piste==1)+(Route_for==1))>0)
    from_rast[Res_pub==1]=0
    Zone_for,_ = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Zone_for[Zone_for>=0]=1
    Zone_for[from_rast==1]=1
    Zone_for=np.int8(Zone_for)
    
    # Create a buffer of Dmax_out_forest around these area taking into account slope and obstacles
    from_rast = focal_stat_nb(np.float_(Zone_for==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.copy(Pente_ok_forw)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for2,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Forw_Dmax_out_for) 
    Pente_ok_forwarder = np.int8(Zone_for2>0)
    Pente_ok_forwarder[Zone_for==1]=1    
    
    del Zone_for,Zone_for2,Out_alloc
    gc.collect()
    
    #Stick all forest with pente_ok_skidder to the area
    from_rast = focal_stat_nb(np.float_(Pente_ok_forwarder==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = Pente_ok_forw*(Foret==1)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Pente_ok_forwarder[Zone_for>=0]=1  
    
    # Create a buffer of Dmax_out_forest around forest
    from_rast = focal_stat_nb(np.float_(Foret==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.int8(Pente_deg<=max(Fwd_max_inc,Fwd_max_up,Fwd_max_down))
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Foret==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Forw_Dmax_out_for) 
    BufForest = np.int8(Zone_for>0)
           
    del Zone_for,from_rast,zone_rast,Out_alloc,Pente_ok_forw
    gc.collect()     
    
    ###############################################################################################################################################
    ### Get directly passable area from forest tracks PAFT (forwarder can reach throught the forest)
    ###############################################################################################################################################
    D_foret,L_Piste,D_piste=Dfwd_flat_forest_tracks(Lien_piste, Pond_pente,Pente_ok_forwarder*(Route_for==0), Csize)
    
    D_foret[(Foret+BufForest)==0] = -9999
    L_Piste[(Foret+BufForest)==0] = -9999
    D_piste[(Foret+BufForest)==0] = -9999
    
    ###############################################################################################################################################
    ### Get directly passable area from forest roads PAFR (forwarder can reach throught the forest)
    ###############################################################################################################################################
    RF_D,RF_L_forRF = Dfwd_flat_forest_road(Lien_RF,Pond_pente,Pente_ok_forwarder*(Piste==0),Csize)

    RF_D[(Foret+BufForest)==0] = -9999
    RF_L_forRF[(Foret+BufForest)==0] = -9999    
    
    del BufForest,Pente_ok_forwarder
    gc.collect()
    
    ###############################################################################################################################################
    ### Check forwarder inclination and terrain slope conditions from forest road network
    ###############################################################################################################################################
    from_rast = focal_stat_nb(np.float_(Foret==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.copy(Manual_harvesting)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Foret==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_OK,Out_alloc = calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Forw_Dmax_out_for) 
    Zone_OK[Zone_OK>=0]=1
    Zone_OK[Zone_OK<0]=0
    Zone_OK=np.int8(Zone_OK)
    Zone_OK[Foret==1]=1
    Zone_OK[MNT_OK==0]=0
    Zone_OK[Obstacles_forwarder==1]=0
    Zone_OK[Manual_harvesting==0]=0
    
    del Out_alloc
    
    contour=np.int8((Piste+Route_for)>0)
    contour[Obstacles_forwarder==1]=0
    contour[Res_pub==1]=0   
    contour[MNT_OK==0]=0     
    pixels=np.argwhere(contour>0)
    del contour    
    
    #line=ID_contour, Y, X,Dpis,Dfor,L_RF,L_Piste    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int16)    
    ID = 1
    Dpis=np.zeros_like(MNT,np.int32)
    Lpis=np.zeros_like(MNT,np.int32)
    LRF=np.zeros_like(MNT,np.int32)
    for i,p in enumerate(Lien_piste[1:]):
        Dpis[p[0],p[1]]=p[2]
        Lpis[p[0],p[1]]=i+1
        LRF[p[0],p[1]]=p[4]
    for i,p in enumerate(Lien_RF[1:]):        
        LRF[p[0],p[1]]=i+1    
    
    for pixel in pixels:        
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        Lien_contour[ID,2],Lien_contour[ID,3]=Dpis[pixel[0],pixel[1]],0
        Lien_contour[ID,4],Lien_contour[ID,5]=LRF[pixel[0],pixel[1]],Lpis[pixel[0],pixel[1]]
        ID +=1   
    
    del Dpis,Lpis,LRF
    gc.collect()
    
    zone_rast = np.int8(Zone_OK*(Pente_deg<=max(Fwd_max_inc,Fwd_max_up,Fwd_max_down)))
        
    Dpente,L_RF,L_pis,Dpis,Dfor=fwd_azimuts_contour(Lien_contour,MNT,Aspect,Pente_deg,Row_line,Col_line,D_line,Nbpix_line,
                                                       Fwd_max_up, Fwd_max_down,Fwd_max_inc, Forw_Lmax, nrows,ncols,zone_rast)    
        
    del Dfor
    gc.collect()
    
    ###############################################################################################################################################
    ### Concatenate for passable area
    ###############################################################################################################################################   
    DTot = np.ones((nrows,ncols),dtype=np.int32)*100001
    Dforet = np.ones((nrows,ncols),dtype=np.int32)*-9999    
    Dpiste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999     
    Lien_foret_RF = np.ones((nrows,ncols),dtype=np.int32)*-9999
    
    ### Get flat area from forest tracks
    Temp = (D_piste>=0)
    DTot[Temp] = D_foret[Temp]+D_piste[Temp]
    Dforet[Temp] = D_foret[Temp] 
    Dpiste[Temp] = D_piste[Temp]
    Lien_foret_piste[Temp] = L_Piste[Temp] 
       
    ### Get flat area from forest roads
    Temp =  (DTot<100001)*(RF_D>=0)
    Temp[RF_D>(Dforet+0.1*Dpiste)]=0
    DTot[Temp] = RF_D[Temp]
    Dforet[Temp] = RF_D[Temp] 
    Dpiste[Temp] = 0
    Lien_foret_RF[Temp] = RF_L_forRF[Temp]
    Temp=(DTot==100001)*(RF_D>=0)
    DTot[Temp] = RF_D[Temp]
    Dforet[Temp] = RF_D[Temp] 
    Dpiste[Temp] = 0
    Lien_foret_RF[Temp] = RF_L_forRF[Temp]
    
    contour = focal_stat_nb(np.float_(Dforet),-9999,1)
    contour = ((contour<9)*(contour>0))>0
    
    ### Get slope area from tracks and roads
    Temp =  (DTot<100001)*(Dpente>=0)
    Temp[Dpente<(Dforet+0.1*Dpiste)]=0
    DTot[Temp] = Dpente[Temp]+Dpis[Temp]
    Dforet[Temp] = 0
    Dpiste[Temp] = Dpis[Temp]
    Lien_foret_RF[Temp] = L_RF[Temp]
    Lien_foret_piste[Temp] = L_pis[Temp] 
    Temp =  (DTot==100001)*(Dpente>=0)
    DTot[Temp] = Dpente[Temp]+Dpis[Temp]
    Dforet[Temp] = 0
    Dpiste[Temp] = Dpis[Temp]
    Lien_foret_RF[Temp] = L_RF[Temp]
    Lien_foret_piste[Temp] = L_pis[Temp] 
    
    del RF_D,RF_L_forRF,Temp,D_foret,L_Piste,D_piste
    gc.collect()    
    
    console_info(QCoreApplication.translate("MainWindow","    - Directly passable area identified")) 
    
    ###############################################################################################################################################
    ### Get contour of passable area (check forwarder inclination and terrain slope conditions)
    ###############################################################################################################################################
    #Identify zone_ok taking into account non forest area    
    contour[Obstacles_forwarder==1]=0
    contour[Res_pub==1]=0  
    contour[Route_for==1]=0  
    contour[Piste==1]=0  
    contour[MNT_OK==0]=0 
    
    Temp = (Dforet>=0)*(contour==0)
    pixels=np.argwhere(contour>0)
    del contour
    
    #line=ID_contour, Y, X,Dpis,Dfor,L_RF,L_Piste    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int16)    
    ID = 1
    for pixel in pixels:
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        Lien_contour[ID,2],Lien_contour[ID,3]=Dpiste[pixel[0],pixel[1]],Dforet[pixel[0],pixel[1]]
        Lien_contour[ID,4],Lien_contour[ID,5]=Lien_foret_RF[pixel[0],pixel[1]],Lien_foret_piste[pixel[0],pixel[1]]
        ID +=1   
        
    zone_rast = np.int8(Zone_OK*(Pente_deg<=max(Fwd_max_inc,Fwd_max_up,Fwd_max_down))*(Temp==0))
        
    Dpente,L_RF,L_pis,Dpis,Dfor=fwd_azimuts_contour(Lien_contour,MNT,Aspect,Pente_deg,Row_line,Col_line,D_line,Nbpix_line,
                                                       Fwd_max_up, Fwd_max_down,Fwd_max_inc, Forw_Lmax, nrows,ncols,zone_rast)
    
    del MNT,Aspect,Pente_deg
    gc.collect()   
    
    ###############################################################################################################################################
    ### Concatenate for in slope area 
    ###############################################################################################################################################      
     
    Temp = (DTot==100001)*(Dpente+Dfor+Dpis>=0)
    DTot[Temp] = Dfor[Temp]+Dpis[Temp]+Dpente[Temp]
    Dforet[Temp] = Dfor[Temp]+Dpente[Temp]
    Dpiste[Temp] = Dpis[Temp]
    Lien_foret_piste[Temp] = L_pis[Temp] 
    Lien_foret_RF[Temp] = L_RF[Temp] 
    
    Temp = (Foret==0)
    DTot[Temp] = 100001
    Dforet[Temp] = -9999
    Dpiste[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_RF[Temp] = -9999   
    
    del Dpente,Dfor,L_pis,Dpis,Temp,Lien_contour,pixels,L_RF,zone_rast
    gc.collect()    
    
    console_info(QCoreApplication.translate("MainWindow","    - Accessible area in slope identified")) 
    
    ################################################################################################################################################
    ### Calculation of area reachable with the grap
    ################################################################################################################################################                   
    # Get the contour of traversable area
    contour = focal_stat_nb(np.float_(Dforet),-9999,1)
    contour = (contour<9)*(contour>0) 
    contour[Obstacles_forwarder==1]=0
    contour[Res_pub==1]=0   
    contour[MNT_OK==0]=0 
    pixels=np.argwhere(contour>0)
    
    del contour,MNT_OK,Res_pub,Obstacles_forwarder
    gc.collect()
    
    Temp = (DTot<100001)    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int16)    
    ID = 1
    for pixel in pixels:
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        Lien_contour[ID,2],Lien_contour[ID,3]=Dforet[pixel[0],pixel[1]],Lien_foret_RF[pixel[0],pixel[1]]
        Lien_contour[ID,4],Lien_contour[ID,5]=Dpiste[pixel[0],pixel[1]],Lien_foret_piste[pixel[0],pixel[1]]
        ID +=1   
    
    zone_rast = Zone_OK*(Temp==0)   
    Dbras,Lien_RF2,Lien_piste2,Dpiste2,Dforet2=Fwd_add_contour(Lien_contour, Pond_pente,zone_rast,Forw_portee, Csize)

    ###############################################################################################################################################                                                                                    
    ### Concatenation of the resultats number 2
    ###############################################################################################################################################
    Temp =  (DTot==100001)*(Dbras+Dpiste2+Dforet2>=0)
    DTot[Temp] = Dbras[Temp]+Dpiste2[Temp]+Dforet2[Temp]
    Dforet[Temp] = Dbras[Temp] + Dforet2[Temp]
    Dpiste[Temp] = Dpiste2[Temp]
    Lien_foret_piste[Temp] = Lien_piste2[Temp]
    Lien_foret_RF[Temp] = Lien_RF2[Temp] 
    
    # Keep only results in Forest area
    Temp = (DTot==100001)
    DTot[Temp] = -9999
    Temp = (Foret==0)
    DTot[Temp] = -9999
    Dforet[Temp] = -9999
    Dpiste[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    
    del zone_rast,Zone_OK,Temp,Lien_contour,Dbras,Dpiste2,Dforet2,Lien_piste2,Lien_RF2,Pond_pente
    gc.collect()
    
    # Fill Lien foret respub and Lien foret RF
    Lien_foret_Res_pub,Lien_foret_RF,Keep=fill_Link(Lien_foret_piste,Lien_piste,Lien_RF, Lien_foret_RF, nrows,ncols)
    
    Temp = (Keep<1)*((Piste==1)+(Route_for==1))>0
    DTot[Temp] = -9999
    Dforet[Temp] = -9999
    Dpiste[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
       
    Zone_accessible = np.int8(1*(DTot>=0))    
    
    del Keep,Piste,Route_for
    gc.collect()    
    console_info(QCoreApplication.translate("MainWindow","    - Area reachable with the boom added")) 
    model_name = QCoreApplication.translate("MainWindow","Forwarder")
    
    
    ###############################################################################################################################################                                                                                    
    ### CREATE SUMMARY TABLE
    ###############################################################################################################################################
    make_summary_surface_vol(Forw_Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,DTot,Vtot,Vtot_non_buch,Rspace_s,model_name)
            
    ###############################################################################################################################################                                                                                    
    ### SAVE RASTER
    ###############################################################################################################################################    
    console_info("    - Saving output files") 
    ArrayToGtiff(DTot,Rspace_s+'Total_yarding_distance',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Lien_foret_piste,Rspace_s+'Link_forest_forest_tracks',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_RF,Rspace_s+'Link_forest_forest_road',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_Res_pub,Rspace_s+'Link_forest_public_network',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Dforet,Rspace_s+'Distance_in_forest',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Dpiste,Rspace_s+'Distance_on_forest_tracks',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Zone_accessible,Rspace_s+'Accessible_area',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    
    layer_name = 'Forwarder_recap_accessibility'
    source_src=get_source_src(file_shp_Desserte)  
    create_access_shapefile(DTot,Rspace_s,Foret,Forw_Debclass.split(";"),road_network_proj,source_src, Dir_temp,Extent,nrows,ncols,layer_name)
       
    ###############################################################################################################################################                                                                                    
    ### SAVE PARAMETERS
    ###############################################################################################################################################    
    
    str_duree,str_fin,str_debut=heures(Hdebut)
    ### Genere le fichier avec le resume des parametres de simulation
    file_name = str(Rspace_s)+"Parameters_of_simulation.txt"
    resume_texte = QCoreApplication.translate("MainWindow","Sylvaccess : AUTOMATIC MAPPING OF FOREST ACCESSIBILITY WITH FORWARDER\n\n\n")
    ver = "0.2"
    date = "2024/02"
    resume_texte += QCoreApplication.translate("MainWindow","Software version :") + ver + QCoreApplication.translate("MainWindow"," - ", "skidder_results") + date + "\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","Resolution       : ")+str(Csize)+" m\n\n"
    resume_texte += "" .join (["_"]*80)+"\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","Date and time when launching the script:              ")+str_debut+"\n"
    resume_texte += QCoreApplication.translate("MainWindow","Date and time at the end of execution of the script:  ")+str_fin+"\n"
    resume_texte += QCoreApplication.translate("MainWindow","Total execution time of the script:                   ")+str_duree+"\n\n"
    resume_texte += "" .join (["_"]*80)+"\n\n"
    resume_texte += QCoreApplication.translate("MainWindow","PARAMETERS USED FOR THE MODELING:\n\n")
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum perpendicular lateral inclination (MPLI):            ")+str(Forw_angle_incl)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for an uphill yarding:                         ")+str(Forw_angle_up)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for an downhill yarding:                       ")+str(Forw_angle_down)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Boom reach:                                                  ")+str(Forw_portee)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum yarding distance when terrain slope > MPLI:          ")+str(Forw_Lmax)+" m\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for a free access of the parcels with skidder: ")+str(Forw_angle_incl)+" %\n"
    resume_texte += QCoreApplication.translate("MainWindow","   - Maximum slope for manual felling of the trees:               ")+str(Pente_max_bucheron)+" %\n"       
    
    if os.path.exists(Rspace_s+"Forest_tracks_not_connected.tif"):
        resume_texte += "\n\n"
        resume_texte += "" .join (["-"]*80)+"\n\n"
        resume_texte += QCoreApplication.translate("MainWindow","      !!! Warning !!! Some forest tracks are not connected to public network.\n" ) 
        resume_texte += QCoreApplication.translate("MainWindow","      They were removed from the analysis.\n")  
    if os.path.exists(Rspace_s+"Forest_road_not_connected.tif"):
        resume_texte += "" .join (["-"]*80)
        resume_texte += QCoreApplication.translate("MainWindow","\n\n      !!! Warning !!! Some forest roads are not connected to public network.\n")      
    
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    console_info(QCoreApplication.translate("MainWindow","Forwarder accessibility processed"))

    ##############################################################################################################################################
    ### Close the script
    ##############################################################################################################################################
    clear_big_nparray()

####################################################################
#  ______ ____    ____ .___________. __    __    ______   .__   __.# 
# /      |\   \  /   / |           ||  |  |  |  /  __  \  |  \ |  |#
#|  ,----' \   \/   /  `---|  |----`|  |__|  | |  |  |  | |   \|  |# 
#|  |       \_    _/       |  |     |   __   | |  |  |  | |  . `  |# 
#|  `----.    |  |         |  |     |  |  |  | |  `--'  | |  |\   |# 
# \______|    |__|         |__|     |__|  |__|  \______/  |__| \__|# 
####################################################################                                                                  


def dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4):
    a = 1. / (Th * Th) * (
            -Tv * Tv / rac1 + (Tv - F - W) * (Tv - F - W) / rac2 -
            (Tv - F - W * s1 / Lo) * (Tv - F - W * s1 / Lo) / rac3 +
            (Tv - W * s1 / Lo) * (Tv - W * s1 / Lo) / rac4
    )
    a += math.sqrt(1 + (Tv / Th) * (Tv / Th)) - math.sqrt(1 + ((Tv - F - W) / Th) * ((Tv - F - W) / Th)) + \
         math.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th) * ((Tv - F - W * s1 / Lo) / Th)) - \
         math.sqrt(1 + ((Tv - W * s1 / Lo) / Th) * ((Tv - W * s1 / Lo) / Th))
    a *= Lo / W
    return a


def double_max(a, b):
    return a if a >= b else b


def int_max(a, b):
    return a if a >= b else b


def double_min(a, b):
    return a if a <= b else b


def pente(raster_mnt, Csize, nodata):
    nline, ncol = raster_mnt.shape
    pente = np.zeros_like(raster_mnt, dtype=np.float32)

    for y in range(1, nline-1):
        for x in range(1, ncol-1):
            e = raster_mnt[y, x]
            if e > nodata:
                a, b, c, d, f, g, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                          raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                          raster_mnt[y + 1, x], raster_mnt[y + 1, x + 1])
                if a == nodata: a = e
                if b == nodata: b = e
                if c == nodata: c = e
                if d == nodata: d = e
                if f == nodata: f = e
                if g == nodata: g = e
                if h == nodata: h = e
                if i == nodata: i = e
                dz_dx = float(c + 2*f + i - (a + 2*d + g)) / float(8 * Csize)
                dz_dy = float(g + 2*h + i - (a + 2*b + c)) / float(8 * Csize)
                pente[y, x] = sqrt(dz_dx * dz_dx + dz_dy * dz_dy) * 100
            else:
                pente[y, x] = nodata

    # Coins sup gauche
    if raster_mnt[0,0]>nodata:
        e = raster_mnt[0,0]
        f = raster_mnt[0,1]
        if f==nodata:f=e
        h = raster_mnt[1,0]
        if h==nodata:h=e
        i = raster_mnt[1,1]
        if i==nodata:i=e
        dz_dx = float(f+i-(e+h))/float(2*Csize)
        dz_dy = float(h+i-(d+f))/float(2*Csize)
        pente[0,0]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100      
    else: pente[0, 0] = nodata
        # Coin inferieur gauche    
    if raster_mnt[nline-1,0]>nodata:
        e = raster_mnt[nline-1,0]
        b = raster_mnt[nline-2,0]
        if b==nodata:b=e
        c = raster_mnt[nline-2,1]
        if c==nodata:c=e
        f = raster_mnt[nline-1,1]
        if f==nodata:f=e
        dz_dx = float(c+f-(b+e))/float(2*Csize)
        dz_dy = float(e+f-(b+c))/float(2*Csize)
        pente[nline-1,0]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100       
    else: pente[nline-1,0]=nodata 
    # Coin superieur droite
    if raster_mnt[0,ncol-1]>nodata:
        e = raster_mnt[0,ncol-1]
        d = raster_mnt[0,ncol-2]
        if d==nodata:d=e
        g = raster_mnt[1,ncol-2]
        if g==nodata:g=e
        h = raster_mnt[1,ncol-1]
        if h==nodata:h=e
        dz_dx = float(e+h-(d+g))/float(2*Csize)
        dz_dy = float(g+h-(d+e))/float(2*Csize)
        pente[0,ncol-1]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100      
    else: pente[0,ncol-1]=nodata
    # Coin inferieur droite
    if raster_mnt[nline-1,ncol-1]>nodata:
        e = raster_mnt[nline-1,ncol-1]
        a = raster_mnt[nline-2,ncol-2]
        if a==nodata:a=e
        d = raster_mnt[nline-1,ncol-2]
        if d==nodata:d=e
        b = raster_mnt[nline-2,ncol-1]
        if b==nodata:b=e
        dz_dx = float(e+b-(d+a))/float(2*Csize)
        dz_dy = float(d+e-(a+b))/float(2*Csize)
        pente[nline-1,ncol-1]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100       
    else: pente[nline - 1, ncol - 1] = nodata
    # Pour premiere ligne
    x=1
    for x in range( 1 <= x < ncol-1):
        e = raster_mnt[0,x] 
        if e > nodata:            
            d = raster_mnt[0,x-1]    
            if d==nodata:d=e
            f = raster_mnt[0,x+1]
            if f==nodata:f=e
            g = raster_mnt[1,x-1]  
            if g==nodata:g=e
            h = raster_mnt[1,x] 
            if h==nodata:h=e
            i = raster_mnt[1,x+1]
            if i==nodata:i=e                            
            dz_dx = float(f+i-(d+g))/float(4*Csize)
            dz_dy = float(g+h+i-(d+e+f))/float(3*Csize)
            pente[0,x]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[0,x]=nodata
    # Pour derniere ligne
    for x in range (1 <= x < ncol-1):
        e = raster_mnt[nline-1,x] 
        if e > nodata:            
            d = raster_mnt[nline-1,x-1]    
            if d==nodata:d=e
            f = raster_mnt[nline-1,x+1]
            if f==nodata:f=e
            a = raster_mnt[nline-2,x-1]  
            if a==nodata:a=e
            b = raster_mnt[nline-2,x] 
            if b==nodata:b=e
            c = raster_mnt[nline-2,x+1]
            if c==nodata:c=e                            
            dz_dx = float(f+c-(d+a))/float(4*Csize)
            dz_dy = float(d+e+f-(a+b+c))/float(3*Csize)
            pente[nline-1,x]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[nline-1,x]=nodata
    # Pour premiere colonne
    for y in range (1 <= x < nline-1):
        e = raster_mnt[x,0] 
        if e > nodata:            
            b = raster_mnt[x+1,0]    
            if b==nodata:b=e
            c = raster_mnt[x+1,1]
            if c==nodata:c=e
            f = raster_mnt[x,1]  
            if f==nodata:f=e
            h = raster_mnt[x+1,0] 
            if h==nodata:h=e
            i = raster_mnt[x+1,1]
            if i==nodata:i=e                            
            dz_dx = float(c+f+i-(b+e+h))/float(3*Csize)
            dz_dy = float(h+i-(b+c))/float(4*Csize)
            pente[x,0]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[x,0]=nodata
    # Pour derniere colonne
    for x in range (1 <= x < nline-1):
        e = raster_mnt[x,ncol-1] 
        if e > nodata:            
            a = raster_mnt[x-1,ncol-2]    
            if a==nodata:a=e
            b = raster_mnt[x-1,ncol-1]
            if b==nodata:b=e
            d = raster_mnt[x,ncol-2]  
            if d==nodata:d=e
            g = raster_mnt[x+1,ncol-2] 
            if g==nodata:g=e
            h = raster_mnt[x+1,ncol-1]
            if h==nodata:h=e                            
            dz_dx = float(b+e+h-(a+d+g))/float(3*Csize)
            dz_dy = float(h+g-(b+a))/float(4*Csize)
            pente[x,ncol-1]= sqrt(dz_dx*dz_dx+dz_dy*dz_dy)*100
        else: pente[x,ncol-1]=nodata

    return pente


def exposition(raster_mnt, Csize, nodata):
    nline, ncol = raster_mnt.shape
    expo = np.zeros_like(raster_mnt, dtype=np.float32)

    for y in range(1, nline-1):
        for x in range(1, ncol-1):
            e = raster_mnt[y, x]
            if e > nodata:
                a, b, c, d, f, g, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                          raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                          raster_mnt[y+1, x], raster_mnt[y+1, x+1])
                dz_dx = float(c + 2*f + i - (a + 2*d + g)) / float(8 * Csize)
                dz_dy = float(g + 2*h + i - (a + 2*b + c)) / float(8 * Csize)
                expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
                if a == nodata: a = e
                if b == nodata: b = e
                if c == nodata: c = e
                if d == nodata: d = e
                if f == nodata: f = e
                if g == nodata: g = e
                if h == nodata: h = e
                if i == nodata: i = e
                if expo1 < 0.:
                    expo[y, x] = 90.0 - expo1
                elif expo1 > 90.:
                    expo[y, x] = 360.0 - expo1 + 90.0
                else:
                    expo[y, x] = 90.0 - expo1
            else:
                expo[y, x] = nodata

    # Coins
    # Coin sup gauche
    if raster_mnt[0,0]>nodata:
        e = raster_mnt[0,0]
        f = raster_mnt[0,1]
        if f==nodata:f=e
        h = raster_mnt[1,0]
        if h==nodata:h=e
        i = raster_mnt[1,1]
        if i==nodata:i=e
        dz_dx = float(f+i-(e+h))/float(2*Csize)
        dz_dy = float(h+i-(d+f))/float(2*Csize)
        expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[0,0]= 90.0 - expo1
        elif expo1>90.:
            expo[0,0]= 360.0 - expo1 + 90.0
        else:
            expo[0,0]= 90.0 - expo1    
    else: expo[0,0]=nodata
        # Coin inferieur gauche    
    if raster_mnt[nline-1,0]>nodata:
        e = raster_mnt[nline-1,0]
        b = raster_mnt[nline-2,0]
        if b==nodata:b=e
        c = raster_mnt[nline-2,1]
        if c==nodata:c=e
        f = raster_mnt[nline-1,1]
        if f==nodata:f=e
        dz_dx = float(c+f-(b+e))/float(2*Csize)
        dz_dy = float(e+f-(b+c))/float(2*Csize)
        expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[nline-1,0]= 90.0 - expo1
        elif expo1>90.:
            expo[nline-1,0]= 360.0 - expo1 + 90.0
        else:
            expo[nline-1,0]= 90.0 - expo1          
    else: expo[nline-1,0]=nodata 
    # Coin superieur droite
    if raster_mnt[0,ncol-1]>nodata:
        e = raster_mnt[0,ncol-1]
        d = raster_mnt[0,ncol-2]
        if d==nodata:d=e
        g = raster_mnt[1,ncol-2]
        if g==nodata:g=e
        h = raster_mnt[1,ncol-1]
        if h==nodata:h=e
        dz_dx = float(e+h-(d+g))/float(2*Csize)
        dz_dy = float(g+h-(d+e))/float(2*Csize)
        expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[0,ncol-1]= 90.0 - expo1
        elif expo1>90.:
            expo[0,ncol-1]= 360.0 - expo1 + 90.0
        else:
            expo[0,ncol-1]= 90.0 - expo1           
    else: expo[0,ncol-1]=nodata
    # Coin inferieur droite
    if raster_mnt[nline-1,ncol-1]>nodata:
        e = raster_mnt[nline-1,ncol-1]
        a = raster_mnt[nline-2,ncol-2]
        if a==nodata:a=e
        d = raster_mnt[nline-1,ncol-2]
        if d==nodata:d=e
        b = raster_mnt[nline-2,ncol-1]
        if b==nodata:b=e
        dz_dx = float(e+b-(d+a))/float(2*Csize)
        dz_dy = float(d+e-(a+b))/float(2*Csize)
        expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
        if expo1<0.:
            expo[nline-1,ncol-1]= 90.0 - expo1
        elif expo1>90.:
            expo[nline-1,ncol-1]= 360.0 - expo1 + 90.0
        else:
            expo[nline-1,ncol-1]= 90.0 - expo1 
    else: expo[nline-1,ncol-1]=nodata
    # Pour premiere ligne
    x=1
    for x in range(1,ncol-1):
        e = raster_mnt[0,x] 
        if e > nodata:            
            d = raster_mnt[0,x-1]    
            if d==nodata:d=e
            f = raster_mnt[0,x+1]
            if f==nodata:f=e
            g = raster_mnt[1,x-1]  
            if g==nodata:g=e
            h = raster_mnt[1,x] 
            if h==nodata:h=e
            i = raster_mnt[1,x+1]
            if i==nodata:i=e                            
            dz_dx = float(f+i-(d+g))/float(4*Csize)
            dz_dy = float(g+h+i-(d+e+f))/float(3*Csize)
            expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[0,x]= 90.0 - expo1
            elif expo1>90.:
                expo[0,x]= 360.0 - expo1 + 90.0
            else:
                expo[0,x]= 90.0 - expo1 
        else: expo[0,x]=nodata
    # Pour derniere ligne
    x=1
    for x in range(1,ncol-1):
        e = raster_mnt[nline-1,x] 
        if e > nodata:            
            d = raster_mnt[nline-1,x-1]    
            if d==nodata:d=e
            f = raster_mnt[nline-1,x+1]
            if f==nodata:f=e
            a = raster_mnt[nline-2,x-1]  
            if a==nodata:a=e
            b = raster_mnt[nline-2,x] 
            if b==nodata:b=e
            c = raster_mnt[nline-2,x+1]
            if c==nodata:c=e                            
            dz_dx = float(f+c-(d+a))/float(4*Csize)
            dz_dy = float(d+e+f-(a+b+c))/float(3*Csize)
            expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[nline-1,x]= 90.0 - expo1
            elif expo1>90.:
                expo[nline-1,x]= 360.0 - expo1 + 90.0
            else:
                expo[nline-1,x]= 90.0 - expo1 
        else: expo[nline-1,x]=nodata
    # Pour premiere colonne
    y=1
    for y in range(1,nline-1):
        e = raster_mnt[y,0] 
        if e > nodata:            
            b = raster_mnt[y+1,0]    
            if b==nodata:b=e
            c = raster_mnt[y+1,1]
            if c==nodata:c=e
            f = raster_mnt[y,1]  
            if f==nodata:f=e
            h = raster_mnt[y+1,0] 
            if h==nodata:h=e
            i = raster_mnt[y+1,1]
            if i==nodata:i=e                            
            dz_dx = float(c+f+i-(b+e+h))/float(3*Csize)
            dz_dy = float(h+i-(b+c))/float(4*Csize)
            expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[y,0]= 90.0 - expo1
            elif expo1>90.:
                expo[y,0]= 360.0 - expo1 + 90.0
            else:
                expo[y,0]= 90.0 - expo1 
        else: expo[y,0]=nodata
    # Pour derniere colonne
    y=1
    for y in range(1,nline-1):
        e = raster_mnt[y,ncol-1] 
        if e > nodata:            
            a = raster_mnt[y-1,ncol-2]    
            if a==nodata:a=e
            b = raster_mnt[y-1,ncol-1]
            if b==nodata:b=e
            d = raster_mnt[y,ncol-2]  
            if d==nodata:d=e
            g = raster_mnt[y+1,ncol-2] 
            if g==nodata:g=e
            h = raster_mnt[y+1,ncol-1]
            if h==nodata:h=e                            
            dz_dx = float(b+e+h-(a+d+g))/float(3*Csize)
            dz_dy = float(h+g-(b+a))/float(4*Csize)
            expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
            if expo1<0.:
                expo[y,ncol-1]= 90.0 - expo1
            elif expo1>90.:
                expo[y,ncol-1]= 360.0 - expo1 + 90.0
            else:
                expo[y,ncol-1]= 90.0 - expo1 
        else: expo[y,ncol-1]=nodata

    return expo


def mask_zone(matrice):
    nline, ncol = matrice.shape
    top, bottom, left, right = nline, 0, ncol, 0

    for y in range(nline):
        for x in range(ncol):
            if matrice[y, x] > 0:
                top = min(top, y)
                bottom = max(bottom, y)
                left = min(left, x)
                right = max(right, x)

    return top, bottom, left, right


def calcul_distance_de_cout(from_rast, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = from_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    h, b, l, r = mask_zone(from_rast)
    
    # Création des rasters de sortie
    Out_distance = np.ones_like(from_rast, dtype=np.int32) * Max_distance
    Out_alloc = np.ones_like(from_rast, dtype=np.int32) * -9999
    
    x1, y1 = l, h
    for y1 in range(h, b):
        for x1 in range(l, r):
            if from_rast[y1, x1] > 0:
                Out_distance[y1, x1] = 0
                Out_alloc[y1, x1] = from_rast[y1, x1]
                for y in range(max(0, y1-1), min(nline, y1+2)):
                    for x in range(max(0, x1-1), min(ncol, x1+2)):                        
                        if zone_rast[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag
                            else:
                                Dist = cost_rast[y, x] * direct
                            if Out_distance[y, x] > Dist:
                                Out_distance[y, x] = int(Dist + 0.5)                                
                                Out_alloc[y, x] = from_rast[y1, x1]
    
    # Traitement complet
    h, b, l, r = mask_zone(zone_rast)
    dist_ac = Csize
    count_sans_match = 0
    
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        test = 0
        y1, x1 = h, l
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1   
                    for y in range(max(0, y1-1), min(nline, y1+2)):
                        for x in range(max(0, x1-1), min(ncol, x1+2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] > Dist:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    Out_alloc[y, x] = Out_alloc[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
    
    for y in range(nline):
        for x in range(ncol):
            if Out_distance[y, x] == Max_distance:
                Out_distance[y, x] = -9999
                Out_alloc[y, x] = -9999
    
    return Out_distance, Out_alloc


def focal_stat_nb(raster, nodata, cote):
    nline, ncol = raster.shape
    rnb = np.ones_like(raster, dtype=np.float32) * nodata
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                nb, y, x = 0.0, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            nb += 1.0
                
                rnb[y1, x1] = nb
    
    return rnb


def focal_stat_max(raster, nodata, cote):
    nline, ncol = raster.shape
    rmax = np.ones_like(raster, dtype=np.float32) * nodata
    min_value = np.min(raster[raster != nodata])
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                local_max, y, x = min_value, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            local_max = max(local_max, raster[y, x])
                
                rmax[y1, x1] = local_max
    
    return rmax


def get_npix(az, npix, coordY, coordX, ncols, nrows, Row_line, Col_line):
    for i in range(npix):
        x = Col_line[az, i] + coordX
        if x < 0 or x >= ncols:
            break
        y = Row_line[az, i] + coordY
        if y < 0 or y >= nrows:
            break
    return i


def get_line_carac_simple(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv):
    i = 0
    nfor = 0
    Dmoy_car = 0
    Forest_area = 0

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0:
            i += 1
            continue
        if x >= ncols:
            i += 1
            continue
        y = Row_ext[az, i] + coordY
        if y < 0:
            i += 1
            continue
        if y >= nrows:
            i += 1
            continue
        if Forest[y, x] == 1:
            nfor += 1
            Dmoy_car += D_ext[az, i]
            Rast_couv[y, x] = 1
        i += 1

    if nfor > 0:
        Forest_area = nfor * Csize * Csize
        Dmoy_car = Dmoy_car / nfor
    else:
        Dmoy_car = D_ext[az, i]

    return int(Dmoy_car), int(Forest_area), Rast_couv


def Check_line(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, D_lat, Rast_couv, debut, recouv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.zeros((nrows, ncols), dtype=np.int8)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0:
            i += 1
            continue
        if x >= ncols:
            i += 1
            continue
        y = Row_ext[az, i] + coordY
        if y < 0:
            i += 1
            continue
        if y >= nrows:
            i += 1
            continue
        if Rast_couv[y, x] == 0:
            if D_ext[az, i] < debut:
                Rast_couv_bis[y, x] = 2
                nb2 += 1
            else:
                if float(D_lat[az, i]) < float(recouv):  # Ensure consistent types
                    Rast_couv_bis[y, x] = 1
                    nb1 += 1
                else:
                    Rast_couv_bis[y, x] = 2
                    nb2 += 1
        elif Rast_couv[y, x] == 1:
            test = 0
            break
        else:
            nb2 += 1
        i += 1

    # Check if the line is really important
    if test and nb1 >= (nb1 + nb2) * rapport:
        Rast_couv = Rast_couv + Rast_couv_bis
    else:
        test = 0

    return test, Rast_couv


def Check_line2(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, D_lat, Rast_couv, recouv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.zeros((nrows, ncols), dtype=np.int8)
    debut = min(100, Lline * 0.4)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if 0 <= x < ncols:
            y = Row_ext[az, i] + coordY
            if 0 <= y < nrows:
                Rast_couv_bis[y, x] = 1
                if Rast_couv[y, x] == 0:
                    nb1 += 1
                elif Rast_couv[y, x] > 1 and D_ext[az, i] > debut and D_lat[az, i] < recouv:
                    test = 0
                    break
                else:
                    nb2 += 1
        i += 1

    if test and nb1 >= (nb1 + nb2) * rapport:
        Rast_couv += Rast_couv_bis
    else:
        test = 0

    return test, Rast_couv


def Check_line3(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Rast_couv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.copy(Rast_couv)
    debut = min(100, Lline * 0.4)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if 0 <= x < ncols:
            y = Row_ext[az, i] + coordY
            if 0 <= y < nrows:
                if Rast_couv[y, x] > 0:
                    Rast_couv_bis[y, x] -= 1
                if Rast_couv[y, x] == 1:
                    nb1 += 1
                elif Rast_couv[y, x] > 1:
                    if D_ext[az, i] > debut:
                        nb2 += 1
                    else:
                        nb1 += 1
        i += 1

    # Check if the line is really important
    if nb1 < (nb1 + nb2) * rapport:
        test = 0
        Rast_couv = Rast_couv_bis

    return test, Rast_couv


def df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4):
    a = (1.0 / Th) * (-Tv / rac1 + (Tv - F - W) / rac2 - (Tv - F - W * s1 / Lo) / rac3 + (Tv - W * s1 / Lo) / rac4)
    a += math.asinh(Tv / Th) - math.asinh((Tv - F - W) / Th) + math.asinh((Tv - F - W * s1 / Lo) / Th) - math.asinh((Tv - W * s1 / Lo) / Th)
    a *= Lo / W
    a += Lo / EAo
    return a


def f_x(Th, Tv, Lo, EAo, W, F, s1, D):
    x = Th * Lo / EAo - D
    x += Th * Lo / W * (
        math.asinh(Tv / Th)
        - math.asinh((Tv - F - W) / Th)
        + math.asinh((Tv - F - W * s1 / Lo) / Th)
        - math.asinh((Tv - W * s1 / Lo) / Th)
    )
    return x


def f_z(Th, Tv, Lo, EAo, W, F, s1, H):
    z = (W * Lo / EAo) * (Tv / W - 0.5) - H
    Temp = (
        math.sqrt(1 + (Tv / Th) ** 2)
        - math.sqrt(1 + ((Tv - F - W) / Th) ** 2)
        + (F * W / (Th * EAo)) * (s1 / Lo - 1)
    )
    Temp += math.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th) ** 2) - math.sqrt(1 + ((Tv - W * s1 / Lo) / Th) ** 2)
    z += Th * Lo / W * Temp
    return z


def calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s):
    x = Th * s / EAo
    x += Th * Lo / W * (
        math.asinh(Tv / Th)
        - math.asinh((Tv - F - W * s / Lo) / Th)
        + math.asinh((Tv - F - W * s1 / Lo) / Th)
        - math.asinh((Tv - W * s1 / Lo) / Th)
    )
    return x


def calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s):
    z = W * s / EAo * (Tv / W - s / (2 * Lo))
    Temp = (
        math.sqrt(1 + (Tv / Th))
        - math.sqrt(1 + ((Tv - F - W * s / Lo) / Th))
        + F * W / (Th * EAo) * (s1 / Lo - s / Lo)
    )
    Temp += math.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th)) - math.sqrt(1 + ((Tv - W * s1 / Lo) / Th))
    z += Th * Lo / W * Temp
    return z


def find_ThTvTmax(Tmax, W, EAo, F, pas, D, H, Lo, step=50):
    Fx_min = 0.05
    Gz_min = 0.05
    sum_min = 10.0
    Th = -1.0
    Tv = -1.0
    T = 1
    test = 0

    for i in range(0, int(Tmax), step):
        for j in range(0, int(Tmax), step):
            Fx = f_x(float(i), float(j), Lo, EAo, W, F, pas, D)
            if abs(Fx) < Fx_min:
                Gz = f_z(float(i), float(j), Lo, EAo, W, F, pas, H)
                if abs(Gz) < Gz_min:
                    if abs(Fx) + abs(Gz) < sum_min:
                        sum_min = min(abs(Fx) + abs(Gz), sum_min)
                        Th = float(i)
                        Tv = float(j)
                        if sum_min < 0.03:
                            test = 1
                            break
        if test == 1:
            break

    if math.sqrt(Th * Th + Tv * Tv) > Tmax:
        T = 0

    return Th, Tv, T


def newton_ThTv(Th, Tv, H, D, Lo, W, s1, F, EAo, Tmax, err=1.0):
    h = 100.0
    k = 100.0
    it = 0
    step = 100
    fo = 0
    go = 0
    rac1 = 0
    rac2 = 0
    rac3 = 0
    rac4 = 0
    dfTv = 0
    dfTh = 0
    dgTv = 0
    dgTh = 0
    coeff = 0
    Fx = 0
    Gz = 0
    Fx_min = 0.05
    Gz_min = 0.05
    sum_min = 10.0
    i = 0
    j = 0
    test = 0

    while abs(h) > err and abs(k) > err:
        fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
        go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
        rac1 = math.sqrt((Tv / Th) ** 2 + 1)
        rac2 = math.sqrt(((Tv - F - W) / Th) ** 2 + 1)
        rac3 = math.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
        rac4 = math.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
        dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
        dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
        dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
        dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
        coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
        h = coeff * (-dgTv * fo + dfTv * go)
        k = coeff * (dgTh * fo - dfTh * go)
        Th = Th + h
        Tv = Tv + k
        it += 1

        if min(Th, Tv) < 0:
            it = 0
            for i in range(1, math.ceil(Tmax), step):
                for j in range(0, math.ceil(Tmax), step):
                    Fx = f_x(float(i), float(j), Lo, EAo, W, F, s1, D)
                    if abs(Fx) < Fx_min:
                        Gz = f_z(float(i), float(j), Lo, EAo, W, F, s1, H)
                        if abs(Gz) < Gz_min:
                            if abs(Fx) + abs(Gz) < sum_min:
                                sum_min = min(abs(Fx) + abs(Gz), sum_min)
                                Th = float(i)
                                Tv = float(j)
                                if sum_min < 0.03:
                                    test = 1
                                    break
                if test:
                    break

        if it > 20:
            break

    return Th, Tv


def Tabmesh(d, E, Tmax, Lmax, Fo, q1, q2, q3, Csize):
    pas = 1
    ncol = int(np.ceil((Lmax + Csize) / pas - 1))
    nline = ncol + 1
    rastLosup = np.full((nline, ncol), np.nan, dtype=np.float32)
    rastTh = np.copy(rastLosup)
    rastTv = np.copy(rastLosup)
    col = 0
    lig = 0
    Hmax = 0
    Tvo = 0.1 * Tmax
    Tho = 0.9 * Tmax
    Lsupo = 0.0
    D = 0.0
    H = 0.0
    Tvprec = Tvo
    Thprec = Tho
    Lsup_prec = Lsupo
    diag = 0.0
    Lo = 0.0
    W = 0.0
    F = 0.0
    Th = 0.0
    Tv = 0.0
    Tcalc = 0.0
    incr = 0.0
    signe = 0.0

    EAo = 0.25 * math.pi * (d * d) * E

    for D in range(5, int(Lmax + Csize), pas):
        lig = 0
        Hmax = int(math.ceil(math.sqrt(Lmax * Lmax - D * D) + Csize))
        Tvprec = Tvo
        Thprec = Tho
        Lsup_prec = Lsupo

        for H in range(0, Hmax, pas):
            diag = math.sqrt(H ** 2 + D ** 2)
            Lo = diag + Lsup_prec
            W = q1 * 9.81 * Lo
            F = 0.5 * ((q2 + (Lo - D) * q3) + Fo) * 9.81

            Th, Tv = newton_ThTv(Thprec, Tvprec, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2, 0.1)

            # Check if Th, Tv are OK
            if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                Th, Tv = newton_ThTv(D / diag * Tmax, Tmax * (H / diag + 0.01), H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                    Th, Tv, _ = find_ThTvTmax(Tmax, W, EAo, F, Lo * 0.5, D, H, Lo, 20)
                    Th, Tv = newton_ThTv(Th, Tv, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                    if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                        continue

            # Find Lo so that Tcalc does not exceed Tmax
            Tcalc = math.sqrt(Th ** 2 + Tv ** 2)

            if math.ceil(Lsup_prec * 0.1) >= 1:
                incr = 1.0
            elif math.ceil(Lsup_prec) >= 1:
                incr = 0.1
            elif math.ceil(Lsup_prec * 10.0) >= 1:
                incr = 0.01
            else:
                incr = 0.001

            signe = (Tcalc - Tmax) / abs(Tcalc - Tmax)

            # Incrementation
            while abs(Tcalc - Tmax) > 10.0:
                Lo += signe * incr
                F = 0.5 * ((q2 + (Lo - D) * q3) + Fo) * 9.81
                W = q1 * 9.81 * Lo
                Th, Tv = newton_ThTv(Th, Tv, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                Tcalc = math.sqrt(Th ** 2 + Tv ** 2)

                if signe * (Tcalc - Tmax) < 0:
                    incr *= 0.1
                    signe *= -1.0

                if Lo > math.sqrt(H ** 2 + D ** 2) + 1000.0:
                    break

            if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                continue

            Tvprec = Tv
            Thprec = Th
            Lsup_prec = Lo - diag
            rastLosup[lig, col] = Lsup_prec
            rastTh[lig, col] = Th
            rastTv[lig, col] = Tv

            if H == 0:
                Tvo = Tv
                Tho = Th
                Lsupo = Lsup_prec

            lig += 1

        col += 1

    return rastLosup, rastTh, rastTv


def check_droite(fact, H, D, Xup, Zup, Line, Hline_min, Hline_max, Tmax, q1, q2, q3, Fo, pg, pd, Dsupdep=0., Dsupend=0.):
    test = 1
    L = np.sqrt(H**2 + D**2)
    F = (0.5 * ((0.5 * L + Dsupdep) * q2 + (0.5 * L + Dsupend) * q3)) * 9.80665 + Fo
    fleche = 1.1 * (F * L / (4 * Tmax) + q1 * 9.80665 * L**2 / (8 * Tmax))
    
    for i in range(pg + 1, pd):
        droite = -fact * H / D * (Line[i, 0] - Xup) + Zup - Line[i, 1]
        if droite < Hline_min:
            test = 0
            break
        if droite - fleche > Hline_max:
            test = 0
            break
    
    return test


def check_Hlinemin(Alts, H, D, Lo, fact, Tho, Tvo, Xup, Zup, Fo, Tmax, Hline_min, Hline_max, q1, q2, q3, Csize, EAo, Dsupdep=0., Dsupend=0.):
    end = Lo - 10.
    test = 1
    Th, Tv = Tho, Tvo
    W = g * q1 * Lo
    s1 = Lo * 0.5
    h, k = 100.0, 100.0
    it = 0
    err = 1.0
    
    while s1 > 10.:
        F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo

        # Newton Th Tv
        it = 0
        while abs(h) > err and abs(k) > err:
            fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
            go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
            rac1 = np.sqrt((Tv / Th) ** 2 + 1)
            rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
            rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
            rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
            dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
            dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
            dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
            dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
            coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
            h = coeff * (-dgTv * fo + dfTv * go)
            k = coeff * (dgTh * fo - dfTh * go)
            Th += h
            Tv += k
            it += 1
            if it > 20:
                break

        if abs(f_x(Th, Tv, Lo, EAo, W, F, s1, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, s1, H)) > 0.03:
            test = 0
            break

        xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s1)
        zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s1)
        ind = int(xcoord * 2 + 0.5)
        Hmin = zcoord - (Alts[ind] + Hline_min)

        if Hmin < 0 or Hmin + Hline_min > Hline_max or np.sqrt(Th ** 2 + Tv ** 2) > (Tmax + 1000):
            test = 0
            break
        s1 -= Csize

    if test:
        Th, Tv = Tho, Tvo
        middle = min(int(Lo * 0.5 + Csize), end)
        s1 = middle
        while s1 < end:
            F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo

            # Newton Th Tv
            h, k = 100.0, 100.0
            it = 0
            while abs(h) > err and abs(k) > err:
                fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
                go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
                rac1 = np.sqrt((Tv / Th) ** 2 + 1)


def Find_Lomin(D, H, Xup, Zup, fact, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Hline_min, Hline_max, Csize, Dsupdep=0., Dsupend=0.):
    h = 100.0
    err = 1.0
    error = 50.
    k = 100.0
    it = 0
    test = 1
    diag = np.sqrt(D * D + H * H)
    col = int_max(np.ceil(D - 5) - 1, 0)
    line = np.ceil(H)
    Lsup = rastLosup[line, col]
    Th = rastTh[line, col]
    Tv = rastTv[line, col]
    Lo = Lsup + diag
    W = q1 * g * Lo
    s1 = 0.5 * Lo
    F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
    Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
    xcoord, zcoord, Hmin = 0., 0., 0.

    if np.isnan(Th) or np.isnan(Tv):
        test = 0

    if test:
        # Newton Th Tv
        while abs(h) > err and abs(k) > err:
            fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
            go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
            rac1 = np.sqrt((Tv / Th) ** 2 + 1)
            rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
            rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
            rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
            dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
            dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
            dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
            dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
            coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
            h = coeff * (-dgTv * fo + dfTv * go)
            k = coeff * (dgTh * fo - dfTh * go)
            Th += h
            Tv += k
            it += 1
            if double_min(Th, Tv) < 0:
                test = 0
                break
            if it > 20:
                test = 0
                break

        if test:
            # Find Lo so that Tcalc does not exceed Tmax
            Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
            incr = 0.01
            signe = (Tcalc - Tmax) / abs(Tcalc - Tmax)

            # Incrementation
            while abs(Tcalc - Tmax) > error and test:
                Lo += signe * incr
                W = q1 * g * Lo
                s1 = Lo * 0.5
                F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
                h = 100.0
                k = 100.0
                it = 0

                # Newton Th Tv
                while abs(h) > err and abs(k) > err:
                    fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
                    go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
                    rac1 = np.sqrt((Tv / Th) ** 2 + 1)
                    rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
                    rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
                    rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
                    dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
                    dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
                    dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
                    dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
                    coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
                    h = coeff * (-dgTv * fo + dfTv * go)
                    k = coeff * (dgTh * fo - dfTh * go)
                    Th += h
                    Tv += k
                    it += 1

                    if double_min(Th, Tv) < 0:
                        test = 0
                        break
                    if it > 20:
                        test = 0
                        break

                Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
                if signe * (Tcalc - Tmax) < 0:
                    incr *= 0.1
                    signe *= -1.

                if abs(Lo - np.sqrt(H * H + D * D)) > 100.:
                    test = 0
                    break

    if test:
        F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
        xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, Lo * 0.5, Lo * 0.5)
        zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, Lo * 0.5, Lo * 0.5)
        ind = int(floor(xcoord * 2 + 0.5))
        Hmin = zcoord - (Alts[ind] + Hline_min)
        if Hmin >= 0:
            Hmin = check_Hlinemin(Alts, H, D, Lo, fact, Th, Tv, Xup, Zup, Fo, Tmax, Hline_min, Hline_max, q1, q2, q3, Csize, EAo, Dsupdep, Dsupend)
            if Hmin < 0:
                test = 0
    else:
        test = 0

    return test, Lo, Th, Tv, Tcalc, F


def test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep=0., slope_prev=-9999.):
    test = 0
    D = Line[posi, 0] - Line[pg, 0]
    H = np.abs(Line[pg, 1] + Hg - (Line[posi, 1] + Hd))
    Xup, Zup = 0, 0
    fact = 0
    diag, slope, Lo, Th, Tv, F, Tcalc = 0, 0, 0, 0, 0, 0, 0

    if Line[pg, 1] + Hg >= Line[posi, 1] + Hd:
        Xup, Zup = Line[pg, 0], Line[pg, 1] + Hg
        fact = 1.
    else:
        Xup, Zup = Line[posi, 0], Line[posi, 1] + Hd
        fact = -1.

    if check_droite(fact, H, D, Xup, Zup, Line, Hline_min, Hline_max, Tmax, q1, q2, q3, Fo, pg, posi, Dsupdep):
        diag = np.sqrt(H * H + D * D)
        slope = -1 * fact * np.arctan(H / D)

        if slope < slope_min or slope > slope_max:
            test = 0
        else:
            # Check slopes around intermediate support
            if slope_prev > -9999 and (np.abs(slope - slope_prev) >= angle_intsup or (slope * slope_prev < 0 and np.abs(slope - slope_prev) >= 0.1)):
                test = 0
            else:
                test, Lo, Th, Tv, Tcalc, F = Find_Lomin(D, H, Xup, Zup, fact, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Hline_min, Hline_max, Csize, Dsupdep)

    return test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F


def get_Tabis(Tab, lineTab, nbconfig, intsup, indmax):
    i, j = 0, 0
    col = (intsup - 1) * 14 + 13
    colH = (intsup - 1) * 14 + 12
    idmax = 0
    idmax2 = indmax + 1
    idline = 0
    linemax = min(lineTab, nbconfig)
    Tabis = np.zeros((linemax, Tab.shape[1]), dtype=np.float32)

    Hmin = 100

    while i < linemax:
        for j in range(0, lineTab):
            if idmax <= Tab[j, col] < idmax2:
                idmax = np.ceil(Tab[j, col])
                if Tab[j, colH] < Hmin:
                    Hmin = Tab[j, colH]
                    idline = j

        Tabis[i] = Tab[idline]
        i += 1
        idmax2 = idmax
        idmax = 0
        Hmin = 100

    return Tabis


def get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax):
    i, j = 0, 0
    col = (intsup - 1) * 15 + 13
    colH = (intsup - 1) * 15 + 12
    idmax = 0
    idmax2 = indmax + 1
    idline = 0
    linemax = min(lineTab, nbconfig)
    Tabis = np.zeros((linemax, Tab.shape[1]), dtype=np.float32)

    Hmin = 100

    while i < linemax:
        for j in range(0, lineTab):
            if idmax <= Tab[j, col] < idmax2:
                idmax = np.ceil(Tab[j, col])
                if Tab[j, colH] < Hmin:
                    Hmin = Tab[j, colH]
                    idline = j

        Tabis[i] = Tab[idline]
        i += 1
        idmax2 = idmax
        idmax = 0
        Hmin = 100

    return Tabis


def OptPyl_Up(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
              angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
              slope_max, test_hfor, nbconfig=10):
    indmax = Line.shape[0] - 1
    test = 0
    D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    # Begin without intermediate support
    Hd = Line[indmax, 7] if test_hfor else Hend
    while Hd > 1:
        test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hd,
                                                                                 Hline_min, Hline_max,
                                                                                 slope_min, slope_max, Alts, Fo, Tmax, q1,
                                                                                 q2, q3, EAo, rastLosup, rastTh, rastTv,
                                                                                 Csize, angle_intsup, 0, slope_prev=-9999)
        if test:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
                Th * Th + (Tv - F - Lo * g * q1) ** 2)
            Span[0, 14], Span[0, 15] = Hd, indmax
            test = 1
        else:
            break
        Hd -= 1

    # Cut the line if no intermediate support allowed
    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hd = Line[posi, 7] if test_hfor else Hend
            while Hd > 1:
                test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd,
                                                                                         Hline_min, Hline_max,
                                                                                         slope_min, slope_max, Alts, Fo,
                                                                                         Tmax, q1, q2, q3, EAo, rastLosup,
                                                                                         rastTh, rastTv, Csize,
                                                                                         angle_intsup, 0, slope_prev=-9999)
                if test:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
                        Th * Th + (Tv - F - Lo * g * q1) ** 2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                else:
                    break
                Hd -= 1
            if test:
                break

    # Start intermediate support position optimization
    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * nbconfig * 100, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -14):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]
                for posi in range(indmaxmulti, indmin, -1):
                    if test_hfor:
                        Hdmax = Line[indmax, 7]
                    else:
                        Hdmax = Hend
                    Hd = 1
                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                            Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo,
                            newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                        if test1:
                            Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                                Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1
                            if test_hfor:
                                Hdmax2 = Line[indmax, 7]
                            else:
                                Hdmax2 = Hend
                            Hd2 = 1
                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                    Line, posi, indmax, Hd, Hd2, Hline_min, Hline_max, slope_min, slope_max,
                                    Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize,
                                    angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                                        Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break
                                Hd2 += 1
                            if best:
                                break
                        Hd += 1
                    if best:
                        break
                if best:
                    break
            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2
                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0
                    break
                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]
                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * nbconfig * 100, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break
    # Cut the line at the farthest position if sup_max > 0
    if not best and test:
        lineTab = 0
        for p in range(0, nblineTabis):
            lineTabis = p
            col = (intsup - 2) * 14
            pg = np.ceil(Tabis[p, 13 + col])
            Hg = Tabis[p, 12 + col]
            indminmulti = pg
            diff = 0.
            while diff < double_max(Csize, LminSpan):
                indminmulti += 1
                diff = Line[indminmulti, 0] - Line[pg, 0]
            newTmax = Tabis[p, 10 + col]
            Dsupdep = 0
            for c in range(col + 2, 1, -14):
                Dsupdep += Tabis[p, c]
            slope_prev = Tabis[p, 3 + col]
            for posi in range(indmax - 1, indminmulti - 1, -1):
                if test_hfor:
                    Hdmax = Line[indmax, 7]
                else:
                    Hdmax = Hend
                Hd = 1
                while Hd <= Hdmax:
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                        Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1,
                        q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                    if test1:
                        Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break
                    Hd += 1
        if lineTab == 0:
            intsup -= 2
            lineTab = 0
            Tab[lineTab] = Tabis[0]
        else:
            Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
            lineTab = 0
            intsup = sup_max

    # Save Span characteristics
    for i in range(0, intsup + 1):
        col = i * 14
        Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up_NoH(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                  angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                  slope_max, test_hfor, nbconfig=10):
    """
    Cable machine en haut
    Optimise le placement des pylones intermediaire sans bouger la hauteur de fixation du cable Forwarder pour chaque pylone sur un profil
    """

    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hd = Line[posi, 7] if test_hfor else Hend
            test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd,
                                                                                    Hline_min, Hline_max, slope_min,
                                                                                    slope_max, Alts, Fo, Tmax, q1, q2, q3,
                                                                                    EAo, rastLosup, rastTh, rastTv, Csize,
                                                                                    angle_intsup, 0, slope_prev=-9999)
            if test0:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hd, posi
                test = 1

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -14):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hd = Line[posi, 7]
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, 0,
                                                                                              slope_prev=-9999)
                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1

                        if test_hfor:
                            Hd2 = Line[indmax, 7]
                        else:
                            Hd2 = Hend

                        test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Hd2,
                                                                                                  Hline_min, Hline_max,
                                                                                                  slope_min, slope_max,
                                                                                                  Alts, Fo, Tdown, q1, q2,
                                                                                                  q3, EAo, rastLosup, rastTh,
                                                                                                  rastTv, Csize,
                                                                                                  angle_intsup,
                                                                                                  diag + Dsupdep, slope)
                        if test2:
                            best = 1
                            Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                            Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                                Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                            break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down_init(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                     angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                     slope_max, test_hfor, nbconfig=5):
    """
    Cable machine en bas
    Permet de recuperer la partie de profil ou il est possible de tendre un cable (avec hauteur de cable Forwarder variable)
    """

    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    while test and Hend > 1:
        Hend -= 1
        test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                                Hline_min, Hline_max, slope_min,
                                                                                slope_max, Alts, Fo, Tmax, q1, q2, q3,
                                                                                EAo, rastLosup, rastTh, rastTv, Csize,
                                                                                angle_intsup, 0, slope_prev=-9999)
        if test0:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
            Span[0, 14], Span[0, 15] = Hend, indmax
            test = 1
        else:
            break

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hdmax = Line[posi, 7]
            Hd = ceil(Hline_min)
            while Hd <= Hdmax:
                test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
                if test1:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                    break
                Hd += 1
            if test:
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hd = 1

                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                        if test1:
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1

                            Hdmax2 = Line[indmax, 7] if test_hfor else Hend
                            Hd2 = 1

                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Hd2, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break

                                Hd2 += 1

                            if best:
                                break

                        Hd += 1

                    if best:
                        break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down_init_NoH(Line, Alts, Span, Htower , Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                         angle_intsup, EAo,  sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                         slope_max, test_hfor, nbconfig=5):
    """
    Cable machine en bas
    Permet de recuperer la partie de profil ou il est possible de tendre un cable (avec hauteur de cable Forwarder fixe)
    """
    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(
            Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            if test_hfor:
                Hd = Line[posi, 7]
            else:
                Hd = Hend
            test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd, Hline_min,
                                                                                    Hline_max, slope_min, slope_max, Alts,
                                                                                    Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                                    rastTh, rastTv, Csize, angle_intsup, 0,
                                                                                    slope_prev=-9999)
            if test1:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(
                    Th * Th + (Tv - F - Lo * g * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hd, posi
                test = 1
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hd = 1

                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                                Hline_min, Hline_max,
                                                                                                slope_min, slope_max, Alts,
                                                                                                Fo, newTmax, q1, q2, q3,
                                                                                                EAo, rastLosup, rastTh,
                                                                                                rastTv, Csize,
                                                                                                angle_intsup, 0,
                                                                                                slope_prev=-9999)

                        if test1:
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1

                            Hdmax2 = Line[indmax, 7] if test_hfor else Hend
                            Hd2 = 1

                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi,
                                                                                                      indmax, Hd, Hd2,
                                                                                                      Hline_min,
                                                                                                      Hline_max,
                                                                                                      slope_min,
                                                                                                      slope_max, Alts,
                                                                                                      Fo, Tmax, q1,
                                                                                                      q2, q3, EAo,
                                                                                                      rastLosup, rastTh,
                                                                                                      rastTv, Csize,
                                                                                                      angle_intsup, 0,
                                                                                                      slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break

                                Hd2 += 1

                            if best:
                                break

                        Hd += 1

                    if best:
                        break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float32)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up2(Line, Alts, Span, Htower,  Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
               angle_intsup, EAo,  sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
               slope_max, test_hfor, nbconfig=10):
    """
    Cable machine en bas
    Optimise le placement des pylones intermediaire et la hauteur de fixation du cable Forwarder pour chaque pylone sur un profil
        
    """
    indmax = Line.shape[0] - 1
    test = 0
    test0 = test1 = test2 = 0
    indminmulti = indmaxmulti = pg = posi = lineTab = lineTabis = 0
    intsup = best = nblineTabis = indmin = 0
    Hg = Hd = Tdown = Hgmax = Hdmax = Hginit = 0
    slope_prev = Dsupdep = newTmax = diff = 0.0
    
    # Begin without intermediate support
    if test_hfor:
        Hg = Line[indmax, 7]
    else:
        Hg = Hend
    while Hg > 1:
        test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
            Line, 0, indmax, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
        if test0:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th*Th + Tv*Tv), sqrt(Th*Th + (Tv - F - Lo*g*q1)**2)
            Span[0, 14], Span[0, 15] = Hg, indmax
            test = 1
        else:
            break
        Hg -= 1

    # End without intermediate support
    # Start Cut the line if no intermediate support allowed
    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            if test_hfor:
                Hd = Line[posi, 7]
            else:
                Hd = Hend
            while Hd > 1:
                test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                    Line, 0, posi, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
                if test0:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th*Th + Tv*Tv), sqrt(Th*Th + (Tv - F - Lo*g*q1)**2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                else:
                    break
                Hd -= 1
            if test:
                break

    # End Cut the line if no intermediate support allowed
    # Start intermediate support position optimization
    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 15 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0

        test = 1
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = 0

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 15
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -15):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]
                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hg = Hginit
                    while Hg <= Hgmax:
                        Hd = ceil(Hline_min)
                        while Hd <= Hdmax:
                            test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                            if test1:
                                Tdown = sqrt(Th*Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                                Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                                Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hg, posi, Hd
                                lineTab += 1
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                    Line, posi, indmax, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 15] = Tab[lineTab - 1, 0:intsup * 15]
                                    Tab[lineTab, intsup * 15:(intsup * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hd, indmax, Htower
                                    break
                            Hd += 1
                        if best:
                            break
                        Hg += 1
                    if best:
                        break
                if best:
                    break
            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2
                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0
                    break
                Tabis = get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]
                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float32)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0
            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 15
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 14 + col]
                indminmulti = pg
                diff = 0.
                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]
                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0
                for c in range(col + 2, 1, -15):
                    Dsupdep += Tabis[p, c]
                slope_prev = Tabis[p, 3 + col]
                for posi in range(indmax - 1, indminmulti - 1, -1):
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                        Line, pg, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                    if test1:
                        Tdown = sqrt(Th*Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hg, posi, Htower
                        lineTab += 1

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]
            else:
                Tab = get_Tabis2(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 15
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up2_NoH(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                    angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                      slope_max, test_hfor, nbconfig=10):
    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2)
        Span[0, 14], Span[0, 15] = Line[indmax, 7] if test_hfor else Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.0
        while diff < Csize * LminSpan:
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]

        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hg = Line[posi, 7] if test_hfor else Hend
            test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
            if test0:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hg, posi
                test = 1
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.0
        while diff < Csize * LminSpan and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float32)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 15 * (sup_max + 1)), dtype=np.float32)
        lineTabis = 0
        test = 1
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hginit = Line[0, 7] if test_hfor else Hend
        best = 0
        slope_prev = -9999
        indmin = 0

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 15
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hginit = Tabis[p, 14 + col]

                    for c in range(col + 2, 1, -15):
                        Dsupdep += Tabis[p, c]

                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hd = Line[posi, 7]
                    Hg = Hginit
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * 9.81 * Lo) * (Tv - q1 * 9.81 * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hg, posi, Hd
                        lineTab += 1
                        test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)

                        if test2:
                            best = 1
                            Tab[lineTab, 0:intsup * 15] = Tab[lineTab - 1, 0:intsup * 15]
                            Tab[lineTab, intsup * 15:(intsup * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hd, indmax, Htower
                            break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * nbconfig * Tabis.shape[0] * 100, 15 * (sup_max + 1)), dtype=np.float32)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 15
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 14 + col]
                indminmulti = pg
                diff = 0.0

                while diff < Csize * LminSpan:
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -15):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * 9.81 * Lo) * (Tv - q1 * 9.81 * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hg, posi, Htower
                        lineTab += 1

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]
            else:
                Tab = get_Tabis2(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 15
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down(Line, Alts, Span, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig=5):
    indmax = Line.shape[0] - 1
    i = -1
    j = sup_max
    Dmax = Line[indmax, 0]
    test = 0
    Spanbis = np.zeros_like(Span)

    while not test:
        indmax = Line.shape[0] - 1
        if indmax == 1:
            test = 0
            break

        Span = OptPyl_Up2(Line, Alts, Span * 0, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig)

        if np.max(Span[:, 15]) == indmax:
            test = 1
            break
        else:
            Line = Line[1:]

    if test:
        for j in range(sup_max, -1, -1):
            if Span[j, 0] > 0:
                break

        i = -1

        while j > -1:
            i += 1
            Spanbis[i] = Span[j]
            Spanbis[i, 5] = Dmax - Span[j, 5]
            Spanbis[i, 15] = indmax - Span[j - 1, 15]
            j -= 1

        Spanbis[i, 15] = indmax
        Spanbis[:, 4] *= -1

    return Spanbis


def OptPyl_Down_NoH(Line, Alts, Span, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig=5):
    indmax = Line.shape[0] - 1
    i = -1
    j = sup_max
    Dmax = Line[indmax, 0]
    test = 0
    Spanbis = np.zeros_like(Span)

    while not test:
        indmax = Line.shape[0] - 1
        if indmax == 1:
            test = 0
            break

        Span = OptPyl_Up2_NoH(Line, Alts, Span * 0, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig)

        if np.max(Span[:, 15]) == indmax:
            test = 1
            break
        else:
            Line = Line[1:]

    if test:
        for j in range(sup_max, -1, -1):
            if Span[j, 0] > 0:
                break

        i = -1

        while j > -1:
            i += 1
            Spanbis[i] = Span[j]
            Spanbis[i, 5] = Dmax - Span[j, 5]
            Spanbis[i, 15] = indmax - Span[j - 1, 15]
            j -= 1

        Spanbis[i, 15] = indmax
        Spanbis[:, 4] *= -1

    return Spanbis


def skid_debusq_RF(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                   coeff, orig, Pmax_up, Pmax_down, damont, daval,
                   nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_des = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)
                coef_l = (Alt_pixel - Alt_RF) / Hdist

                if Out_distance[Y, X] > dist:
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_des[Y, X] = pixel
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_des[coordY, coordX] = pixel

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_des[Y, X] = -9999

    return Out_distance, L_des


def skid_debusq_Piste(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                      coeff, orig, Pmax_up, Pmax_down, damont, daval,
                      nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_des = np.zeros((nrows, ncols), dtype=np.int32)
    Dpis = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0
        dpist = Lien_RF[pixel, 2]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)
                coef_l = (Alt_pixel - Alt_RF) / Hdist

                if Out_distance[Y, X] > dist:
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_des[Y, X] = pixel
                    Dpis[Y, X] = int(dpist + 0.5)
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_des[coordY, coordX] = pixel
            Dpis[coordY, coordX] = int(dpist + 0.5)

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_des[Y, X] = -9999
                Dpis[Y, X] = -9999

    return Out_distance, L_des, Dpis


def skid_debusq_contour(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                        coeff, orig, Pmax_up, Pmax_down, damont, daval,
                        nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_RF = np.zeros((nrows, ncols), dtype=np.int32)
    L_Piste = np.zeros((nrows, ncols), dtype=np.int32)
    Dpis = np.zeros((nrows, ncols), dtype=np.int32)
    Dfor = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX] 
        testRF = 0
        lienRF, lienPiste = Lien_RF[pixel, 2], Lien_RF[pixel, 3]
        dpist, dfor = Lien_RF[pixel, 5], Lien_RF[pixel, 4]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                coef_l = (Alt_pixel - Alt_RF) / Hdist
                dist = sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)

                if (Out_distance[Y, X] + Dpis[Y, X] + Dfor[Y, X]) > (dist + dpist + dfor):
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_RF[Y, X] = lienRF 
                    L_Piste[Y, X] = lienPiste
                    Dpis[Y, X] = int(dpist + 0.5)
                    Dfor[Y, X] = int(dfor + 0.5)
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_RF[coordY, coordX] = lienRF 
            L_Piste[coordY, coordX] = lienPiste
            Dpis[coordY, coordX] = int(dpist + 0.5)
            Dfor[coordY, coordX] = int(dfor + 0.5)

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_RF[Y, X] = -9999
                L_Piste[Y, X] = -9999
                Dpis[Y, X] = -9999
                Dfor[Y, X] = -9999

    return Out_distance, L_RF, L_Piste, Dpis, Dfor


def seek_ind(Tab, x, y):
    nline = Tab.shape[0]
    y1 = 1
    ind = 1

    while y1 < nline:
        if Tab[y1, 0] == y:
            if Tab[y1, 1] == x:
                ind = y1
                break
        y1 += 1

    return ind


def seek_ind_i(Tab, x, y):
    nline = Tab.shape[0]
    y1 = 1
    ind = 1

    while y1 < nline:
        if Tab[y1, 0] == y:
            if Tab[y1, 1] == x:
                ind = y1
                break
        y1 += 1

    return ind


def Link_RF_res_pub(Tab_res_pub, cost_rast, RF, Res_pub, Link_RF, Csize, Max_distance=100000):
    nline, ncol = cost_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    dist_ac = Csize
    nb_pixel_res_pub = Tab_res_pub.shape[0]
    nb_pixel_RF = Link_RF.shape[0]
    pixel = 1

    while pixel < nb_pixel_res_pub:
        y1 = Tab_res_pub[pixel, 0]
        x1 = Tab_res_pub[pixel, 1]
        if RF[y1, x1] == 1:
            ind = seek_ind(Link_RF, x1, y1)
            Link_RF[ind, 2] = 0
            Link_RF[ind, 3] = pixel
            Link_RF[ind, 4] = 1
        pixel += 1

    while dist_ac <= Max_distance:
        test = 0
        pixel = 1
        while pixel < nb_pixel_RF:
            if Link_RF[pixel, 4] == 1:
                test = 1
                y1 = int(Link_RF[pixel, 0])
                x1 = int(Link_RF[pixel, 1])
                Link_RF[pixel, 4] = 2
                dist_ac = Link_RF[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if RF[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_RF, x, y)
                            if Link_RF[ind, 2] > Dist:
                                Link_RF[ind, 2] = Dist
                                Link_RF[ind, 3] = Link_RF[pixel, 3]
                                Link_RF[ind, 4] = 1
            pixel += 1

        if test == 0:
            break

    test = 0
    pixel = 1

    while pixel < nb_pixel_RF:
        if Link_RF[pixel, 2] == 100001:
            y1 = int(Link_RF[pixel, 0])
            x1 = int(Link_RF[pixel, 1])
            for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                    if Res_pub[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        ind = seek_ind_i(Tab_res_pub, x, y)
                        Link_RF[pixel, 2] = Dist
                        Link_RF[pixel, 3] = ind
                        Link_RF[pixel, 4] = 1
                        test = 1
        pixel += 1

    while test:
        test = 0
        pixel = 1
        while pixel < nb_pixel_RF:
            if Link_RF[pixel, 4] == 1:
                test = 1
                y1 = int(Link_RF[pixel, 0])
                x1 = int(Link_RF[pixel, 1])
                Link_RF[pixel, 4] = 2
                dist_ac = Link_RF[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if RF[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_RF, x, y)
                            if Link_RF[ind, 2] > Dist:
                                Link_RF[ind, 2] = Dist
                                Link_RF[ind, 3] = Link_RF[pixel, 3]
                                Link_RF[ind, 4] = 1
            pixel += 1

    return Link_RF[:, 0:-1]


def Link_tracks_res_pub(Tab_res_pub, Link_RF, cost_rast, Piste, RF, Res_Pub, Link_Piste, Csize, Max_distance=100000):
    nline, ncol = cost_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    dist_ac = Csize
    nb_pixel_res_pub = Tab_res_pub.shape[0]
    nb_pixel_RF = Link_RF.shape[0]
    nb_pixel_Piste = Link_Piste.shape[0]
    pixel = 1

    # Initialisation du raster depuis reseau public
    while pixel < nb_pixel_res_pub:
        y1 = Tab_res_pub[pixel, 0]
        x1 = Tab_res_pub[pixel, 1]
        if Piste[y1, x1] == 1:
            ind = seek_ind(Link_Piste, x1, y1)
            Link_Piste[ind, 2] = 0
            Link_Piste[ind, 3] = 0
            Link_Piste[ind, 4] = -9999
            Link_Piste[ind, 5] = pixel
            Link_Piste[ind, 6] = 1
        pixel += 1

    pixel = 1
    # Initialisation du raster depuis route_for
    while pixel < nb_pixel_RF:
        y1 = Link_RF[pixel, 0]
        x1 = Link_RF[pixel, 1]
        if Piste[y1, x1] == 1:
            ind = seek_ind(Link_Piste, x1, y1)
            Link_Piste[ind, 2] = 0
            Link_Piste[ind, 3] = Link_RF[pixel, 2]
            Link_Piste[ind, 4] = pixel
            Link_Piste[ind, 5] = Link_RF[pixel, 3]
            Link_Piste[ind, 6] = 1
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance:
        test = 0
        pixel = 1
        while pixel < nb_pixel_Piste:
            if Link_Piste[pixel, 6] == 1:
                test = 1
                y1 = int(Link_Piste[pixel, 0])
                x1 = int(Link_Piste[pixel, 1])
                Link_Piste[pixel, 6] = 2
                dist_ac = Link_Piste[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if Piste[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_Piste, x, y)
                            if Link_Piste[ind, 2] > Dist:
                                Link_Piste[ind, 2] = Dist
                                Link_Piste[ind, 3] = Link_Piste[pixel, 3]
                                Link_Piste[ind, 4] = Link_Piste[pixel, 4]
                                Link_Piste[ind, 5] = Link_Piste[pixel, 5]
                                Link_Piste[ind, 6] = 1
            pixel += 1

        if test == 0:
            break

    # Verifie si certaines pistes ne sont pas connectee
    test = 0
    pixel = 1

    # Initialisation du raster
    while pixel < nb_pixel_Piste:
        if Link_Piste[pixel, 2] == 100001:
            y1 = int(Link_Piste[pixel, 0])
            x1 = int(Link_Piste[pixel, 1])
            for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                    if Res_Pub[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        if Link_Piste[pixel, 2] > Dist:
                            ind = seek_ind_i(Tab_res_pub, x, y)
                            Link_Piste[pixel, 2] = Dist
                            Link_Piste[pixel, 3] = 0
                            Link_Piste[pixel, 4] = -9999
                            Link_Piste[pixel, 5] = ind
                            Link_Piste[pixel, 6] = 1
                            test = 1
                    if RF[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        if Link_Piste[pixel, 2] > Dist:
                            ind = seek_ind_i(Link_RF, x, y)
                            Link_Piste[pixel, 2] = Dist
                            Link_Piste[pixel, 3] = Link_RF[ind, 2]
                            Link_Piste[pixel, 4] = ind
                            Link_Piste[pixel, 5] = Link_RF[ind, 3]
                            Link_Piste[pixel, 6] = 1
                            test = 1
        pixel += 1

    # Traitement complet
    while test:
        test = 0
        pixel = 1
        while pixel < nb_pixel_Piste:
            if Link_Piste[pixel, 6] == 1:
                test = 1
                y1 = int(Link_Piste[pixel, 0])
                x1 = int(Link_Piste[pixel, 1])
                Link_Piste[pixel, 6] = 2
                dist_ac = Link_Piste[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if Piste[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_Piste, x, y)
                            if Link_Piste[ind, 2] > Dist:
                                Link_Piste[ind, 2] = Dist
                                Link_Piste[ind, 3] = Link_Piste[pixel, 3]
                                Link_Piste[ind, 4] = Link_Piste[pixel, 4]
                                Link_Piste[ind, 5] = Link_Piste[pixel, 5]
                                Link_Piste[ind, 6] = 1
            pixel += 1

    return Link_Piste[:, 0:-1]


def Dfwd_flat_forest_road(Link_RF, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = zone_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    nb_pixel_RF = Link_RF.shape[0]

    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (Max_distance + 1)
    L_forRF = np.ones_like(zone_rast, dtype=np.int32) * -9999

    x, y, x1, y1 = 0, 0, 0, 0
    test = 0
    count_sans_match = 0
    Dist = 0
    dist_ac = Csize
    h = nline
    b = 0
    l = ncol
    r = 0

    # Initialisation du raster
    pixel = 1
    while pixel < nb_pixel_RF:
        y1 = Link_RF[pixel, 0]
        x1 = Link_RF[pixel, 1]
        Out_distance[y1, x1] = 0
        L_forRF[y1, x1] = pixel
        for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct
                    if Out_distance[y, x] > Dist:
                        Out_distance[y, x] = int(Dist + 0.5)
                        L_forRF[y, x] = pixel
                        x1, y1 = x, y
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        y1, x1 = h, l
        test = 0
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] > Dist:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    L_forRF[y, x] = L_forRF[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline):
        for x in range(0, ncol):
            if Out_distance[y, x] > Max_distance:
                Out_distance[y, x] = -9999
                L_forRF[y, x] = -9999

    return Out_distance, L_forRF


def Dfwd_flat_forest_tracks(Link_Piste, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline = zone_rast.shape[0]
    ncol = zone_rast.shape[1]
    diag = 1.414214 * Csize
    direct = Csize
    nb_pixel_Piste = Link_Piste.shape[0]


    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (Max_distance + 1)
    L_forPiste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dpiste = np.ones_like(zone_rast, dtype=np.int32) * -9999

    x, y, x1, y1 = 0, 0, 0, 0
    test = 0
    count_sans_match = 0
    Dist = 0
    dist_ac = Csize
    h = nline
    b = 0
    l = ncol
    r = 0


    # Initialisation du raster
    pixel = 1
    while pixel < nb_pixel_Piste:
        y1 = Link_Piste[pixel, 0]
        x1 = Link_Piste[pixel, 1]
        Out_distance[y1, x1] = 0
        L_forPiste[y1, x1] = pixel
        Dpiste[y1, x1] = Link_Piste[pixel, 2]
        for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct
                    if Out_distance[y, x] >= Dist and Dpiste[y, x] + 2 * Out_distance[y, x] > 2 * Dist + Link_Piste[
                        pixel, 2]:
                        Out_distance[y, x] = int(Dist + 0.5)
                        L_forPiste[y, x] = pixel
                        Dpiste[y, x] = Link_Piste[pixel, 2]
                        if y < h: h = y
                        if x < l: l = x
                        if y > b: b = y
                        if x > r: r = x
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        y1, x1 = h, l
        test = 0
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] >= Dist and Dpiste[y, x] + 2 * Out_distance[y, x] > 2 * Dist + Dpiste[
                                    y1, x1]:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    L_forPiste[y, x] = L_forPiste[y1, x1]
                                    Dpiste[y, x] = Dpiste[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline):
        for x in range(0, ncol):
            if Out_distance[y, x] > Max_distance:
                Out_distance[y, x] = -9999
                L_forPiste[y, x] = -9999
                Dpiste[y, x] = -9999

    return Out_distance, L_forPiste, Dpiste


def fwd_azimuts_contour(Lien_RF, MNT, Aspect, Pente, Row_line, Col_line, D_line, Nbpix_line,
                        Fwd_max_up, Fwd_max_down, Fwd_max_inc, Forw_Lmax, nrows, ncols, Zone_ok):
    Max_distance = 100000
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    Dfor = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    Dpis = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_pis = np.zeros((nrows, ncols), dtype=np.int32) - 9999
    L_RF = np.zeros((nrows, ncols), dtype=np.int32) - 9999

    for pixel in range(1, Lien_RF.shape[0]):
        coordY = Lien_RF[pixel, 0]
        coordX = Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0
        lienRF = Lien_RF[pixel, 4]
        lienPiste = Lien_RF[pixel, 5]
        dpist = Lien_RF[pixel, 2]
        dfor = Lien_RF[pixel, 3]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y = coordY + Row_line[az, i]
                if Y < 0:
                    break
                if Y >= nrows:
                    break
                X = coordX + Col_line[az, i]
                if X < 0:
                    break
                if X >= ncols:
                    break
                if not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = sqrt(Hdist * Hdist + (Alt_pixel - Alt_RF) * (Alt_pixel - Alt_RF))

                if dist > Forw_Lmax:
                    break

                if MNT[Y, X] > Alt_RF:
                    if Pente[Y, X] > Fwd_max_down:
                        break
                else:
                    if Pente[Y, X] > Fwd_max_up:
                        break

                dif_angle = (az - Aspect[Y, X]) % 180.
                max_slope = fabs(Fwd_max_inc / cos((90. - dif_angle) / 180 * pi))

                if Pente[Y, X] > max_slope:
                    break

                if Dpis[Y, X] == (Max_distance + 1):
                    Out_distance[Y, X] = int(dist + 0.5)
                    Dpis[Y, X] = int(dpist + 0.5)
                    Dfor[Y, X] = int(dfor + 0.5)
                    L_RF[Y, X] = lienRF
                    L_pis[Y, X] = lienPiste
                    testRF = 1
                else:
                    if (Out_distance[Y, X] + Dpis[Y, X] * 0.1 + Dfor[Y, X]) > (dist + dfor + 0.1 * dpist):
                        Out_distance[Y, X] = int(dist + 0.5)
                        Dpis[Y, X] = int(dpist + 0.5)
                        Dfor[Y, X] = int(dfor + 0.5)
                        L_RF[Y, X] = lienRF
                        L_pis[Y, X] = lienPiste
                        testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            Dpis[coordY, coordX] = int(dpist + 0.5)
            Dfor[coordY, coordX] = int(dfor + 0.5)
            L_RF[coordY, coordX] = lienRF
            L_pis[coordY, coordX] = lienPiste

    for Y in range(0, nrows, 1):
        for X in range(0, ncols, 1):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_RF[Y, X] = -9999
                L_pis[Y, X] = -9999
                Dpis[Y, X] = -9999
                Dfor[Y, X] = -9999

    return Out_distance, L_RF, L_pis, Dpis, Dfor


def Fwd_add_contour(Lien_contour, cost_rast, zone_rast, Forw_portee, Csize):
    nline, ncol = zone_rast.shape[0], zone_rast.shape[1]
    diag = 1.414214 * Csize
    direct = Csize
    Dist, dist_ac = Csize, Csize
    Max_distance = int(Forw_portee + 0.5)
    nb_pixel_contour = Lien_contour.shape[0]
    h, b, l, r = nline, 0, ncol, 0

    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (100 + 1)
    Lien_RF = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Lien_piste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dpiste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dforet = np.ones_like(zone_rast, dtype=np.int32) * -9999

    y1, x1, test, count_sans_match, pixel = 0, 0, 0, 0, 1

    # Initialisation du raster
    while pixel < nb_pixel_contour:
        y1, x1 = Lien_contour[pixel, 0], Lien_contour[pixel, 1]
        Out_distance[y1, x1] = 0
        Lien_RF[y1, x1] = Lien_contour[pixel, 3]
        Lien_piste[y1, x1] = Lien_contour[pixel, 5]
        Dpiste[y1, x1] = Lien_contour[pixel, 4]
        Dforet[y1, x1] = Lien_contour[pixel, 2]

        for y in range(max(0, y1 - 1), min(nline, y1 + 2), 1):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2), 1):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct

                    if Dist <= Max_distance:
                        if Out_distance[y, x] == 101:
                            Out_distance[y, x] = int(Dist + 0.5)
                            Lien_RF[y, x] = Lien_RF[y1, x1]
                            Lien_piste[y, x] = Lien_piste[y1, x1]
                            Dpiste[y, x] = Dpiste[y1, x1]
                            Dforet[y, x] = Dforet[y1, x1]

                            if y < h:
                                h = y
                            if x < l:
                                l = x
                            if y > b:
                                b = y
                            if x > r:
                                r = x
                        else:
                            if Out_distance[y, x] + 0.1 * Dpiste[y, x] + Dforet[y, x] > Dist + 0.1 * Dpiste[y1, x1] + Dforet[y1, x1]:
                                Out_distance[y, x] = int(Dist + 0.5)
                                Lien_RF[y, x] = Lien_RF[y1, x1]
                                Lien_piste[y, x] = Lien_piste[y1, x1]
                                Dpiste[y, x] = Dpiste[y1, x1]
                                Dforet[y, x] = Dforet[y1, x1]

                                if y < h:
                                    h = y
                                if x < l:
                                    l = x
                                if y > b:
                                    b = y
                                if x > r:
                                    r = x

        pixel += 1

    # Traitement complet
    while dist_ac <= 100 and count_sans_match < 15 * Csize:
        test = 0
        y1, x1 = h, l

        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2), 1):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2), 1):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac

                                if Dist <= Max_distance:
                                    if Out_distance[y, x] == 101:
                                        Out_distance[y, x] = int(Dist + 0.5)
                                        Lien_RF[y, x] = Lien_RF[y1, x1]
                                        Lien_piste[y, x] = Lien_piste[y1, x1]
                                        Dpiste[y, x] = Dpiste[y1, x1]
                                        Dforet[y, x] = Dforet[y1, x1]
                                    else:
                                        if Out_distance[y, x] + 0.1 * Dpiste[y, x] + Dforet[y, x] > Dist + 0.1 * Dpiste[y1, x1] + Dforet[y1, x1]:
                                            Out_distance[y, x] = int(Dist + 0.5)
                                            Lien_RF[y, x] = Lien_RF[y1, x1]
                                            Lien_piste[y, x] = Lien_piste[y1, x1]
                                            Dpiste[y, x] = Dpiste[y1, x1]
                                            Dforet[y, x] = Dforet[y1, x1]

        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1

        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline, 1):
        for x in range(0, ncol, 1):
            if Out_distance[y, x] > 100:
                Out_distance[y, x] = -9999
                Lien_RF[y, x] = -9999
                Lien_piste[y, x] = -9999
                Dpiste[y, x] = -9999
                Dforet[y, x] = -9999

    return Out_distance, Lien_RF, Lien_piste, Dpiste, Dforet


def fill_Link(Lien_foret_piste, Lien_piste, Lien_RF, Lien_foret_RF, nrows, ncols):
    Lien_foret_res_pub = np.ones((nrows, ncols), dtype=np.int32) * -9999
    Keep = np.zeros((nrows, ncols), dtype=np.int8)

    for y in range(nrows):
        for x in range(ncols):
            pixel = Lien_foret_piste[y, x]

            if pixel > 0:
                Keep[Lien_piste[pixel, 0], Lien_piste[pixel, 1]] = 1
                Lien_foret_res_pub[y, x] = Lien_piste[pixel, 5]
                Lien_foret_RF[y, x] = Lien_piste[pixel, 4]
            else:
                pixel2 = Lien_foret_RF[y, x]

                if pixel2 > 0:
                    Keep[Lien_RF[pixel2, 0], Lien_RF[pixel2, 1]] = 1
                    Lien_foret_res_pub[y, x] = Lien_RF[pixel2, 3]

    return Lien_foret_res_pub, Lien_foret_RF, Keep


def get_line_carac_vol(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv, Vol_ha, Vol_AM):
    x, y = 0, 0
    i = 0
    nfor = 0
    nvam = 0
    Dmoy_car = 0
    Dmoy_car2 = 0
    Vtot = 0
    VAM = 0

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0 or x >= ncols:
            i += 1
            continue

        y = Row_ext[az, i] + coordY
        if y < 0 or y >= nrows:
            i += 1
            continue

        if Forest[y, x] == 1:
            nfor += 1
            Dmoy_car2 += D_ext[az, i]
            Rast_couv[y, x] = 1

        if Vol_ha[y, x] > 0:
            Vtot += Vol_ha[y, x] * Csize * Csize * 0.0001
            Dmoy_car += Vol_ha[y, x] * D_ext[az, i] * Csize * Csize * 0.0001

        if Vol_AM[y, x] > 0:
            nvam += 1
            VAM += Vol_AM[y, x]

        i += 1

    Forest_area = nfor * Csize * Csize

    if Vtot > 0:
        Dmoy_car = Dmoy_car / Vtot
    else:
        Vtot = -1
        if nfor > 0:
            Dmoy_car = Dmoy_car2 / nfor
        else:
            Dmoy_car = D_ext[az, i]

    if nvam > 0:
        VAM = VAM / nvam
    else:
        VAM = -1

    return int(Dmoy_car), int(Forest_area), int(Vtot), int(10 * VAM), Rast_couv


def get_prop(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Rast_couv):
    x, y = 0, 0
    i = 0
    nb1 = 0
    nb2 = 0

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0 or x >= ncols:
            i += 1
            continue

        y = Row_ext[az, i] + coordY
        if y < 0 or y >= nrows:
            i += 1
            continue

        if Rast_couv[y, x] == 1:
            nb1 += 1
        elif Rast_couv[y, x] > 1:
            nb2 += 1

        i += 1

    total = nb1 + nb2
    return nb1 / total if total > 0 else 0

