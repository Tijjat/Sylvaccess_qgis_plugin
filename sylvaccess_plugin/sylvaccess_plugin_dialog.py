# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Sylvaccess_pluginDialog
                                 A QGIS plugin
 This plugin is the Sylvaccess app made in qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Cosylval
        email                : yoann.zenner@viacesi.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from PyQt5 import QtWidgets, uic
from PyQt5.QtWidgets import QFileDialog
import os
from qgis.core import QgsMessageLog, Qgis
from scipy import spatial
import numpy as np
from osgeo import gdal, osr, ogr
import math

from math import sqrt,degrees,atan,cos,sin,radians,pi,atan2,ceil,floor,fabs
import shutil
import gc
import datetime
from scipy.interpolate import InterpolatedUnivariateSpline
import sys
import sylvaccess_cython3 as fc


# Chargement de l'interface utilisateur depuis le fichier .ui
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'sylvaccess_plugin_dialog_base.ui'))

class Sylvaccess_pluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        super(Sylvaccess_pluginDialog, self).__init__(parent)
        self.setupUi(self)

##################################################################
#.______     ______    __    __  .__________.  ______   .__   __.# 
#|   _  \   /  __  \  |  |  |  | |          | /  __  \  |  \ |  |# 
#|  |_)  | |  |  |  | |  |  |  | `---|  |---`|  |  |  | |   \|  |# 
#|   _  <  |  |  |  | |  |  |  |     |  |    |  |  |  | |  . `  |# 
#|  |_)  | |  `--'  | |  `--'  |     |  |    |  `--'  | |  |\   |# 
#|______/   \______/   \______/      |__|     \______/  |__| \__|# 
##################################################################        
        # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
        for i in range(1, 14):
            button = getattr(self, f"pushButton_{i}")
            button.clicked.connect(lambda _, num=i: self.open_folder(num))

        # Connexion des signaux des checkbox
        for i in range(1, 5):
            checkbox = getattr(self, f"checkBox_{i}")
            checkbox.stateChanged.connect(lambda _, num=i: self.checkbox_state_changed(num))

        # Connexion des signaux des boutons OK et Annuler
        self.button_box.accepted.connect(self.launch)
        self.button_box.rejected.connect(self.reject)
        self.spinBox_40.valueChanged.connect(self.spinBox_40_changed)

    # Connexion des signaux des boutons d'ouverture de fichier à la fonction open_folder
    def open_folder(self, button_number):
        # Définit les filtres génériques pour Shapefiles et fichiers raster
        shapefile_filter = "Shapefiles (*.shp);;All files (*)"
        raster_filter = "Raster files (*.tif *.asc *.txt);;All files (*)"

        # Définit les options de la boîte de dialogue
        options = QFileDialog.Options()
        #options |= QFileDialog.DontUseNativeDialog

        # Affiche le dialogue de sélection de fichier avec les filtres appropriés
        if button_number in [4, 5, 6]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, "Choisir un fichier", filter=shapefile_filter, options=options)
        elif button_number in [3, 11, 12, 13]:
            selected_file, _ = QFileDialog.getOpenFileName(
                None, "Choisir un fichier", filter=raster_filter, options=options)
        elif button_number in [1, 2, 7, 8, 9, 10]:  # Pour le bouton qui doit ouvrir un dossier
            selected_file = QFileDialog.getExistingDirectory(
                None, "Choisir un dossier", options=options)

        if selected_file:
            # Mise à jour du champ de texte approprié
            if button_number == 2:
                text_edit = getattr(self, f"lineEdit_2")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_17")
                text_edit.setText(selected_file)
            elif button_number == 4 :
                text_edit = getattr(self, f"lineEdit_4")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_14")
                text_edit.setText(selected_file)
            elif button_number == 13:
                text_edit = getattr(self, f"lineEdit_13")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_15")
                text_edit.setText(selected_file)
            elif button_number == 12 :
                text_edit = getattr(self, f"lineEdit_12")
                text_edit.setText(selected_file)
                text_edit = getattr(self, f"lineEdit_16")
                text_edit.setText(selected_file)
            else:
                text_edit = getattr(self, f"lineEdit_{button_number}")
                text_edit.setText(selected_file)

    # Fonction appelée lorsqu'une checkbox est cochée ou décochée
    def checkbox_state_changed(self, checkbox_number):
        # Récupère l'état de la checkbox
        checkbox = getattr(self, f"checkBox_{checkbox_number}")
        checkbox_state = checkbox.isChecked()

        if checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(True)
                # désactive les lineEdit pour éviter les erreurs
                self.lineEdit_14.setEnabled(False)
                self.lineEdit_15.setEnabled(False)
                self.lineEdit_16.setEnabled(False)
                self.lineEdit_17.setEnabled(False)
                self.spinBox_49.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(True)
            if checkbox_number == 3:
                self.porteur.setEnabled(True) 
            if checkbox_number == 4:
                self.skidder.setEnabled(True)
        elif not checkbox_state:
            if checkbox_number == 1:
                self.cable_opti.setEnabled(False)
            if checkbox_number == 2:
                self.cable.setEnabled(False)
            if checkbox_number == 3:
                self.porteur.setEnabled(False) 
            if checkbox_number == 4:
                self.skidder.setEnabled(False)


    def spinBox_40_changed(self):
        value = self.spinBox_40.value()
        self.spinBox_49.setValue(value)


###############################################################################################
# __          ___      .__   __.   ______  _______ .___  ___.  _______ .__   __. .___________.#
#|  |        /   \     |  \ |  |  /      ||   ____||   \/   | |   ____||  \ |  | |           |#
#|  |       /  ^  \    |   \|  | |  ,----'|  |__   |  \  /  | |  |__   |   \|  | `---|  |----`#
#|  |      /  /_\  \   |  . `  | |  |     |   __|  |  |\/|  | |   __|  |  . `  |     |  |     #
#|  `----./  _____  \  |  |\   | |  `----.|  |____ |  |  |  | |  |____ |  |\   |     |  |     #
#|_______/__/     \__\ |__| \__|  \______||_______||__|  |__| |_______||__| \__|     |__|     #
###############################################################################################                                                                                             
    # Fonction appelée lorsqu'on clique sur le bouton OK
    def launch(self):
        Wspace,Rspace,_,_,file_shp_Desserte,_,_,_,_,_,_,_,_ = Sylvaccess_pluginDialog.get_spatial(1,1,1,0,0,1,0,0,0,0,0,0,0,0,0)
        test_Skidder,test_Porteur,test_Cable,test_cable_optimise,pente = Sylvaccess_pluginDialog.get_general(1,1,1,1,1,1)
        prelevement,recalculer,_,foret2,VBP2,VAM2,pechage2 = Sylvaccess_pluginDialog.get_opti_cable(1,1,1,0,1,1,1,1)
        surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_pluginDialog.get_crit_opti(1,1,1,1,1,1,1,1,1)
        w_list = [surface, nbr_sup_int, sens_debardage, longueure_ligne, vol_ligne, indice_prelev, VAM3, dist_chariot]
        lim_list = [surface_poids, nbr_sup_int_poids, sens_debardage_poids, longueure_ligne_poids, vol_ligne_poids, indice_prelev_poids, VAM_poids, dist_chariot_poids]  
        try:os.mkdir(Rspace)
        except:pass
        for i in range (1,5):
            if not getattr(self, f"lineEdit_{i}").text():
                console_warning("Veuillez remplir tous les champs obligatoires")
                return
        Sylvaccess_pluginDialog.check_files()
        write_file()
        if (test_Skidder + test_Porteur) > 0:
            # Verifie si une partie de la desserte correspond a un projet
            testExist = check_field_EXIST(file_shp_Desserte,"EXIST") 
                    
                    ###################################################################################################################
                    ### Si pas de projet desserte
                    ###################################################################################################################
            if not testExist: 
                if test_Skidder:  
                    Skidder()                    
                    gc.collect()
                
                if test_Porteur:
                    Porteur()
                    gc.collect()
            
            ###################################################################################################################
            ### Si projet desserte
            ###################################################################################################################
            else:                        
                file_shp_Desserte_Exist = create_new_road_network(file_shp_Desserte,Wspace)
                
                #Premiere simu sans projet
    
                console_info("\nSIMULATION DEPUIS LA DESSERTE EXISTANTE")
                if test_Skidder:   
                    try:os.mkdir(Rspace+"Skidder/")
                    except:pass
                    Skidder(file_shp_Desserte_Exist)                    
                    gc.collect()
                    projdir = Rspace+"Skidder/1_Existant/"

                    
                    os.rename(Rspace+"Skidder/Skidder/",projdir)
                
                if test_Porteur:
                    Rspace_f = Rspace+"Porteur/"
                    old=Rspace+"Porteur/Porteur/"
                    new= Rspace+"Porteur/1_Existant/"  
                    try:os.mkdir(Rspace_f)
                    except:pass
                    Porteur(file_shp_Desserte_Exist)
                    gc.collect()
                    os.rename(old,new)  
                    
                os.remove(Wspace+"Temp/Lien_piste.npy")
                os.remove(Wspace+"Temp/Lien_RF.npy")
                os.remove(Wspace+"Temp/Tab_res_pub.npy")
                os.remove(Wspace+"Temp/Route_for.npy")
                os.remove(Wspace+"Temp/Piste.npy")
                
                #Deuxieme simu avec projet
                console_info("\nSIMULATION INCLUANT LE PROJET DE DESSERTE")
                if test_Skidder: 
                    Skidder()                    
                    gc.collect()
                    projdir = Rspace+"Skidder/2_Projet/"
                    
                    os.rename(Rspace+"Skidder/Skidder/",projdir)
                    make_dif_files(Rspace,0)     
                    
                if test_Porteur:
                    Rspace_f = Rspace+"Porteur/"
                    old=Rspace+"Porteur/Porteur/"
                    new= Rspace+"Porteur/2_Projet/"                                
                    Porteur()
                    gc.collect()         
                    os.rename(old,new)   
                    make_dif_files(Rspace,1)                       
        
        if test_Cable:
            Cable()
            test_cable_optimise=0
            gc.collect()
        if test_cable_optimise:
            line_selection(Wspace,w_list,lim_list,recalculer,foret2,VBP2,VAM2,pechage2,prelevement,pente) 
            gc.collect()  
        try:
            shutil.rmtree(Wspace+"Temp")
        except:
            pass


    # Fonction qui vérifie que tous les fichiers nécessaires sont bien présents
    def check_files(self):
        verif=True
        test_Skidder = self.checkBox_4.isChecked()
        test_Porteur = self.checkBox_3.isChecked()
        test_cable_optim = self.checkBox_1.isChecked()
        test_Cable = self.checkBox_2.isChecked()
        file_MNT = getattr(self, f"lineEdit_3".text())
        file_shp_Desserte = getattr(self, f"lineEdit_5".text())
        file_shp_Foret = getattr(self, f"lineEdit_4".text())
        file_vol_BP = getattr(self, f"lineEdit_13".text())
        file_vol_AM = getattr(self, f"lineEdit_12".text())
        file_HA = getattr(self, f"lineEdit_14".text())
        new_calc = self.checkBox_6.isChecked()
        file_shp_Cable_dep = getattr(self, f"lineEdit_6".text())

        msg="\nLES PROBLEMES SUIVANTS ONT ETE IDENTIFIES CONCERNANT LES ENTREES SPATIALES: \n"
        #Check MNT
        if test_Skidder+test_Porteur+test_Cable>0:
            try:
                _,values,_,Extent = raster_get_info(file_MNT)   
                if values[5]==None:
                    verif=False
                    msg+=" -   Raster MNT: Aucune valeur de NoData definie\n" 
            except:
                msg+=" -   Raster MNT:  Le chemin d'acces est manquant ou incorrect. Ce raster est obligatoire pour lancer Sylvaccess\n" 
                
        #Check file_shp_Desserte   
        if test_Skidder+test_Porteur>0:
            try:    
                if not check_field(file_shp_Desserte,"CL_SVAC"):
                    verif=False
                    msg+=" -   Couche desserte: Le champs 'CL_SVAC' est manquant\n"  
            except:
                verif=False
                msg+=" -   Couche desserte: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour les modules skidder et porteur\n" 
            

        #Check file_shp_Cable_Dep    
        if test_Cable:   
            try: 
                if not check_field(file_shp_Cable_dep,"CABLE"):
                    verif=False
                    msg+=" -   Couche desserte: Le champs 'CABLE' est manquant\n"  
            except:
                verif=False
                msg+=" -   Couche départs de cable potentiels: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour le module cable\n" 

            
        #Check file_shp_Foret   
        if test_Skidder+test_Porteur+test_Cable>0:    
            try:     
                if not check_field(file_shp_Foret,"FORET"):
                    verif=False
                    msg+=" -   Couche foret: Le champs 'FORET' est manquant\n" 
            except:
                verif=False
                msg+=" -   Couche foret: Le chemin d'acces est manquant ou incorrect. Cette couche est obligatoire pour lancer Sylvaccess\n"     
                    
        #Check file_shp_Foret for cable optim
        if not test_Cable and test_cable_optim and new_calc and file_shp_Foret!="":
            try:     
                if not check_field(file_shp_Foret,"FORET"):
                    verif=False
                    msg+=" -   Couche foret (onglet optimisation cable): Le champs 'FORET' est manquant\n" 
            except:
                verif=False
                msg+=" -   Couche foret (onglet optimisation cable): Le chemin d'acces est manquant ou incorrect. \n"     
            
        #Check file_vol_BP,file_vol_AM,file_HA
        FR_name = ["Raster Volume/ha","Raster volume arbre moyen","Raster hauteur des arbres"]
        for i,f in enumerate([file_vol_BP,file_vol_AM,file_HA]):
            if f!="":
                try:
                    _,values2,_,Extent2 = raster_get_info(f)    
                    if values2[5]==None:
                        verif=False
                        msg+=" -   "+FR_name[i]+": Aucune valeur de NoData definie\n" 
                    if not values[4]==values2[4]:
                        verif=False
                        msg+=" -   "+FR_name[i]+": La taille de cellules du raster doit etre la meme que celle du MNT\n" 
                    if not np.all(Extent==Extent2):
                        verif=False
                        msg+=" -   "+FR_name[i]+": L'etendue du raster doit etre la meme que celle du MNT\n" 
                except:
                    verif=False
                    msg+=" -   "+FR_name[i]+": Le chemin d'access est incorrect\n"     

        if not verif:
            msg+="\n"
            msg+="MERCI DE CORRIGER AVANT DE RELANCER SYLVACCESS\n"
            console_warning(msg)
        return verif


#####################################################################################################################
#  _______  _______ .___________.   ____    ____  ___      .______    __       ___      .______    __       _______ #
# /  _____||   ____||           |   \   \  /   / /   \     |   _  \  |  |     /   \     |   _  \  |  |     |   ____|#
#|  |  __  |  |__   `---|  |----`    \   \/   / /  ^  \    |  |_)  | |  |    /  ^  \    |  |_)  | |  |     |  |__   #
#|  | |_ | |   __|      |  |          \      / /  /_\  \   |      /  |  |   /  /_\  \   |   _  <  |  |     |   __|  #
#|  |__| | |  |____     |  |           \    / /  _____  \  |  |\  \-.|  |  /  _____  \  |  |_)  | |  `----.|  |____ #
# \______| |_______|    |__|            \__/ /__/     \__\ | _| `.__||__| /__/     \__\ |______/  |_______||_______|#
#####################################################################################################################


    def get_general(self,ski,por,cab,opti,pente):
        if ski:
            ski = getattr(self, f"checkBox_4").isChecked()
        if por:
            por = getattr(self, f"checkBox_3").isChecked()
        if cab:
            cab = getattr(self, f"checkBox_2").isChecked()
        if opti:
            opti = getattr(self, f"checkBox_1").isChecked()
        if pente:
            pente = self.spinBox_1.value()


    def get_spatial(self,Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP):
        if Wspace: 
            Wspace = getattr(self, f"lineEdit_1").text()
        if Rspace:
            Rspace = getattr(self, f"lineEdit_2").text()
        if mnt:
            mnt = getattr(self, f"lineEdit_3").text()
        if foret:
            foret = getattr(self, f"lineEdit_4").text()
        if desserte:
            desserte = getattr(self, f"lineEdit_5").text()
        if dep_cable:
            dep_cable = getattr(self, f"lineEdit_6").text()
        if ski_no_t_d:
            ski_no_t_d = getattr(self, f"lineEdit_7").text()
        if ski_no_t:
            ski_no_t = getattr(self, f"lineEdit_8").text()
        if por_obstacle:
            por_obstacle = getattr(self, f"lineEdit_9").text()
        if cab_obstacle:
            cab_obstacle = getattr(self, f"lineEdit_10").text()
        if HA:
            HA = getattr(self, f"lineEdit_11").text()
        if VAM:
            VAM = getattr(self, f"lineEdit_12").text()
        if VBP:
            VBP = getattr(self, f"lineEdit_13").text()

        return Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP


    def get_skidder(self,pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes_s):
        if pente_max:
            pente_max = self.spinBox_3.value()
        if distance_max_amont:
            distance_max_amont = self.spinBox_4.value()
        if distance_max_aval:
            distance_max_aval = self.spinBox_5.value()
        if distance_max_hors_frt_dsrt:
            distance_max_hors_frt_dsrt = self.spinBox_6.value() 
        if pente_amont_max:
            pente_amont_max = self.spinBox_7.value()
        if pente_aval_max:
            pente_aval_max = self.spinBox_1.value()
        if limite:
            if self.radioButton_1.isChecked():
                limite = True
            else:
                limite = False
        if bornes_s:
            bornes_s = self.plainTextEdit_1.toPlainText()
            if not bornes_s:
                console_warning("Veuillez remplir les bornes minimales des classes de débardages pour le skidder")
                return
        return pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes_s   


    def get_porteur(self,pente_max,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes_p):
        if pente_max:
            pente_max = self.spinBox_8.value()
        if pente_max_remonant:
            pente_max_remonant = self.spinBox_9.value()
        if pente_max_descendant:
            pente_max_descendant = self.spinBox_12.value()
        if distance_max_pente_sup:
            distance_max_pente_sup = self.spinBox_10.value()
        if distance_max_hors_frt:
            distance_max_hors_frt = self.spinBox_11.value()
        if taille_grue:
            taille_grue = self.doublespinBox_1.value()
        if bornes_p:
            bornes_p = self.plainTextEdit_2.toPlainText()
            if not bornes_p:
                console_warning("Veuillez remplir les bornes minimales des classes de débardages pour le porteur")
                return
        return pente_max,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes_p


    def get_type_cable(self, type_machine,supports_inter,hauteur,longueure_max,longueure_min):
        if type_machine:
            type_machine = self.comboBox_1.currentText()
        if supports_inter:
            supports_inter = self.spinBox_14.value()
        if hauteur:
            hauteur = self.doublespinBox_2.value()
        if longueure_max:
            longueure_max = self.spinBox_16.value()
        if longueure_min:
            longueure_min = self.spinBox_17.value()
        return type_machine,supports_inter,hauteur,longueure_max,longueure_min


    def get_type_chariot(self, type_chariot,masse,pente_min,pente_max_amont,pente_max_aval):
        if type_chariot:
            type_chariot = self.comboBox_2.currentText()
        if masse:
            masse = self.spinBox_22.value()
        if pente_min:
            pente_min = self.spinBox_23.value()
        if pente_max_amont:
            pente_max_amont = self.spinBox_24.value()
        if pente_max_aval:
            pente_max_aval = self.spinBox_25.value()
        return type_chariot,masse,pente_min,pente_max_amont,pente_max_aval      


    def get_proprietes_cable(self,diamètre,masse_li,tension_rupt,elasticité):
        if diamètre:
            diamètre = self.doublespinBox_3.value()
        if masse_li:
            masse_li = self.doublespinBox_4.value()
        if tension_rupt:
            tension_rupt = self.spinBox_26.value()
        if elasticité:
            elasticité = self.spinBox_27.value()
        return diamètre,masse_li,tension_rupt,elasticité


    def get_param_modelisation(self,hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite):
        if hauteur_sup:
            hauteur_sup = self.doublespinBox_5.value()
        if hauteur_mat:
            hauteur_mat = self.doublespinBox_8.value()
        if hauteur_min_cable:
            hauteur_min_cable = self.doublespinBox_6.value()
        if hauteur_max_cable:
            hauteur_max_cable = self.doublespinBox_9.value()
        if pechage:
            pechage = self.spinBox_40.value()
        if masse_max:
            masse_max = self.spinBox_39.value()
        if securite:
            securite = self.doublespinBox_10.value()
        return hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite


    def get_options(self,opti,precision):
        if opti:
            opti = self.checkBox_5.isChecked()
        if precision:
            precision = self.spinBox_41.value()
        return opti,precision


    def get_opti_cable(self,prelevement,recalculer,Rspace_c,foret_c,VBP_c,VAM_c,pechage_c):
        if prelevement:
            prelevement = self.spinBox_48.value()
        if recalculer:
            recalculer = self.checkBox_6.isChecked()
        if Rspace_c:
            Rspace_c = getattr(self, f"lineEdit_17").text()
        if foret_c:
            foret_c = getattr(self, f"lineEdit_14").text()
        if VBP_c:
            VBP_c = getattr(self, f"lineEdit_15").text()
        if VAM_c:
            VAM_c = getattr(self, f"lineEdit_16").text()
        if pechage_c:
            pechage_c = self.spinBox_49.value()
        return prelevement,recalculer,Rspace_c,foret_c,VBP_c,VAM_c,pechage_c


    def get_crit_opti(self,surface,nbr_sup_int,sens_debardage,longueure_ligne,vol_ligne,indice_prelev,VAM,dist_chariot):
        surface_poids,nbr_sup_int_poids,sens_debardage_poids,longueure_ligne_poids,vol_ligne_poids,indice_prelev_poids,VAM_poids,dist_chariot_poids = 0,0,0,0,0,0,0,0   
        if surface and self.checkBox_7.isChecked():
            surface = self.doublespinBox_11.value()
            surface_poids = self.spinBox_18.value()
        else:
            surface = 0
        if nbr_sup_int and self.checkBox_8.isChecked():
            nbr_sup_int = self.spinBox_46.value()
            nbr_sup_int_poids = self.spinBox_19.value()
        else:
            nbr_sup_int = 0
        if sens_debardage and self.checkBox_9.isChecked():
            sens_debardage = self.spinBox_45.value()
            sens_debardage_poids = self.spinBox_20.value()
        else:
            sens_debardage = 0
        if longueure_ligne and self.checkBox_10.isChecked():
            longueure_ligne = self.spinBox_44.value()
            longueure_ligne_poids = self.spinBox_21.value()
        else:
            longueure_ligne = 0
        if vol_ligne and self.checkBox_11.isChecked():
            vol_ligne = self.spinBox_43.value()
            vol_ligne_poids = self.spinBox_31.value()
        else:
            vol_ligne = 0
        if indice_prelev and self.checkBox_12.isChecked():
            indice_prelev = self.doublespinBox_12.value()
            indice_prelev_poids = self.spinBox_32.value()
        else:
            indice_prelev = 0
        if VAM and self.checkBox_13.isChecked():
            VAM = self.doublespinBox_13.value()
            VAM_poids = self.spinBox_33.value()
        else:
            VAM = 0
        if dist_chariot and self.checkBox_14.isChecked():
            dist_chariot = self.spinBox_50.value()
            dist_chariot_poids = self.spinBox_51.value()
        else:
            dist_chariot = 0
        return surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM,VAM_poids,dist_chariot,dist_chariot_poids


# Fonctions qui gère les calculs liés au porteur
def Porteur():
    console_info("Porteur")


#################################################
#.______   .______   __  .__   __. .___________.#
#|   _  \  |   _  \ |  | |  \ |  | |           |#
#|  |_)  | |  |_)  ||  | |   \|  | `---|  |----`#
#|   ___/  |      / |  | |  . `  |     |  |     #
#|  |      |  |\  \-|  | |  |\   |     |  |     #
#| _|      | _| `.__|__| |__| \__|     |__|     #
#################################################


# Fonctions qui affiche un message d'erreur dans la console
def console_warning(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Warning)

# Fonctions qui affiche un message d'information dans la console
def console_info(message):
    message = str(message)
    QgsMessageLog.logMessage(message,'Sylvaccess',Qgis.Info)


#########################################################################
#  _______  _______ .__   __.  _______ .______        ___       __      #
# /  _____||   ____||  \ |  | |   ____||   _  \      /   \     |  |     #
#|  |  __  |  |__   |   \|  | |  |__   |  |_)  |    /  ^  \    |  |     #
#|  | |_ | |   __|  |  . `  | |   __|  |      /    /  /_\  \   |  |     #
#|  |__| | |  |____ |  |\   | |  |____ |  |\  \--./  _____  \  |  `----.#
# \______| |_______||__| \__| |_______|| _| `.___/__/     \__\ |_______|#
#########################################################################
    

def heures(Hdebut):
    Hfin = datetime.datetime.now()
    duree = Hfin - Hdebut
    ts = duree.seconds
    nb_days = int(ts/3600./24.)
    ts -= nb_days*3600*24
    nb_hours = int(ts/3600)
    ts -= nb_hours*3600
    nb_minutes = int(ts/60)
    ts -= nb_minutes*60  
    if nb_days>0:
        str_duree = str(nb_days)+'j '+str(nb_hours)+'h '+str(nb_minutes)+'min '+str(ts)+'s'
    elif nb_hours >0:
        str_duree = str(nb_hours)+'h '+str(nb_minutes)+'min '+str(ts)+'s'
    elif nb_minutes>0:
        str_duree = str(nb_minutes)+'min '+str(ts)+'s'
    else:
        str_duree = str(ts)+'s'        
        str_debut = str(Hdebut.day)+'/'+str(Hdebut.month)+'/'+str(Hdebut.year)+' '+str(Hdebut.hour)+':'+str(Hdebut.minute)+':'+str(Hdebut.second)
        str_fin = str(Hfin.day)+'/'+str(Hfin.month)+'/'+str(Hfin.year)+' '+str(Hfin.hour)+':'+str(Hfin.minute)+':'+str(Hfin.second)

    return str_duree,str_fin,str_debut


def get_info_ascii(file_name):
    fs = open(file_name, 'r')
    head_text=''
    line = 1
    while line<7:
        head_text = head_text+fs.readline()
        line=line+1
    fs.close()
    Csize = np.genfromtxt(file_name, dtype=None,usecols=(1))[4]
    return head_text, Csize


def save_integer_ascii(file_name,head_text,data):
    np.savetxt(file_name, data, fmt='%i', delimiter=' ')
    with open(file_name, "r+") as f:
        old = f.read()
        f.seek(0)
        f.write(head_text + old)
        f.close()


def save_float_ascii(file_name,head_text,data):
    np.savetxt(file_name, data, fmt='%f', delimiter=' ')
    with open(file_name, "r+") as f:
        old = f.read()
        f.seek(0)
        f.write(head_text + old)
        f.close()


def replace_all(text, dic):
    for i, j in dic.iteritems(): text = text.replace(i, j)
    return text


def clear_big_nparray():    
    """clear all globals over 100 Mo size and their associated memory space"""
    for uniquevar in [var for var in dir() if isinstance(globals()[var],np.ndarray)]:
        if globals()[uniquevar].nbytes/1000000>50:
            del globals()[uniquevar]
    gc.collect()


def read_info(info_file):
    names = np.genfromtxt(info_file, dtype=None,usecols=(0),encoding ='latin1')
    values = np.genfromtxt(info_file, dtype=None,usecols=(1),encoding ='latin1')  
    return list(names),list(values)


def raster_get_info(in_file_name):
    source_ds = gdal.Open(in_file_name)    
    src_proj = osr.SpatialReference(wkt=source_ds.GetProjection())
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform()
    ymin = ymax+src_nrows*Csize_y
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [src_ncols,src_nrows,xmin,ymin,Csize_x,nodata]
    Extent = [xmin,xmin+src_ncols*Csize_x,ymin,ymax]
    return names,values,src_proj,Extent


def write_file():
    Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP = Sylvaccess_pluginDialog.get_spatial(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
    ski,por,cab,opti,pente = Sylvaccess_pluginDialog.get_general(1,1,1,1,1,1)
    pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,pente_amont_max,pente_aval_max,limite,bornes=Sylvaccess_pluginDialog.get_skidder(1,1,1,1,1,1,1,1,1)
    pente_max2,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes2=Sylvaccess_pluginDialog.get_porteur(1,1,1,1,1,1,1,1)
    type_machine,supports_inter,hauteur,longueure_max,longueure_min=Sylvaccess_pluginDialog.get_type_cable(1,1,1,1,1,1)
    type_chariot,masse,pente_min,pente_max_amont,pente_max_aval = Sylvaccess_pluginDialog.get_type_chariot(1,1,1,1,1,1,1)
    diamètre,masse_li,tension_rupt,elasticité = Sylvaccess_pluginDialog.get_proprietes_cable(1,1,1,1,1)
    hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,masse_max,securite = Sylvaccess_pluginDialog.get_param_modelisation(1,1,1,1,1,1,1,1)
    opti2,precision = Sylvaccess_pluginDialog.get_options(1,1,1)
    prelevement,recalculer,Rspace2,foret2,VBP2,VAM2,pechage2 = Sylvaccess_pluginDialog.get_opti_cable(1,1,1,1,1,1,1,1)
    surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_pluginDialog.get_crit_opti(1,1,1,1,1,1,1,1,1)
    var_list= [Wspace,Rspace,mnt,foret,desserte,dep_cable,ski_no_t_d, ski_no_t,por_obstacle,cab_obstacle,HA,VAM,VBP,ski,por,cab,opti,pente,pente_max,distance_max_amont,distance_max_aval,distance_max_hors_frt_dsrt,
               pente_amont_max,pente_aval_max,limite,bornes,pente_max2,pente_max_remonant,pente_max_descendant,distance_max_pente_sup,distance_max_hors_frt,taille_grue,bornes2,type_machine,supports_inter,hauteur,
               longueure_max,longueure_min,type_chariot,masse,pente_min,pente_max_amont,pente_max_aval,diamètre,masse_li,tension_rupt,elasticité,hauteur_sup,hauteur_mat,hauteur_min_cable,hauteur_max_cable,pechage,
               masse_max,securite,opti2,precision,prelevement,recalculer,Rspace2,foret2,VBP2,VAM2,pechage2,surface,surface_poids,nbr_sup_int,nbr_sup_int_poids,sens_debardage,sens_debardage_poids,longueure_ligne,
               longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM3,VAM_poids,dist_chariot,dist_chariot_poids]
    file_name = Rspace2+"all_param.txt"
    text=var_list[0]
    for var in var_list[1:]:
        text+="\n"
        text+= str(var)
    fichier = open(file_name, "w")
    fichier.write(text)
    fichier.close()


def read_raster(file_name):
    source_ds = gdal.Open(file_name)
    source_ds.FlushCache() # Flush 
    Array = source_ds.GetRasterBand(1).ReadAsArray()
    Array[Array==0]=-9999
    return Array




#############################
#  _______  __      _______.#
# /  _____||  |    /       |#
#|  |  __  |  |   |   (----`#
#|  | |_ | |  |    \   \    #
#|  |__| | |  | .---)   |   #
# \______| |__| |______/    #
#############################                            


def check_field(filename,fieldname):
    verif=False    
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break    
    source_ds.Destroy() 
    return verif


def check_field_EXIST(filename,fieldname):    
    verif=False
    source_ds = ogr.Open(filename)
    layer = source_ds.GetLayer()    
    ldefn = layer.GetLayerDefn()
    for n in range(ldefn.GetFieldCount()):
        fdefn = ldefn.GetFieldDefn(n)
        if fdefn.name==fieldname:
            verif= True
            break
    if verif:
        vals = []
        for feat in layer:
            val = feat.GetField(fieldname)
            if val is not None:
                vals.append(feat.GetField(fieldname))      
        nbval = np.unique(vals).shape[0]
        if nbval==1:
            verif=False
    source_ds.Destroy() 
    return verif


def generate_HeadText(names,values):    
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    return head_text


def save_raster_info(values,Rspace_c):   
    np.savetxt(Rspace_c+"Area_extent.txt", values, fmt='%f', delimiter=';')


def loadrasterinfo_from_file(Rspace_c):
    values = list(np.loadtxt(Rspace_c+"Area_extent.txt"))
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']    
    ncols = values[0]
    nrows = values[1]
    xmin=values[2]
    ymin = values[3]    
    Csize = values[4] 
    Extent = [xmin,xmin+ncols*Csize,ymin,ymin+nrows*Csize]
    return names,values,Extent


def load_float_raster(raster_file,Dir_temp):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)
    cols = dataset.RasterXSize
    rows = dataset.RasterYSize    
    geotransform = dataset.GetGeoTransform()
    xmin = geotransform[0]
    xmax = xmin + geotransform[1]*cols
    ymax = geotransform[3]
    ymin = geotransform[3] + geotransform[5]*rows
    Extent = [xmin,xmax,ymin,ymax]
    Csize = abs(geotransform[1])
    proj = dataset.GetProjection()
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()
    names = ['ncols', 'nrows', 'xllcorner', 'yllcorner', 'cellsize','NODATA_value']
    values = [round(cols,2), round(rows,2), round(xmin,2), round(ymin,2), round(Csize,2),round(nodatavalue,2)]
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    f = open(Dir_temp+'info_extent.txt',"w")
    f.write(head_text)
    f.close()
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array),Extent,Csize,proj 


def load_float_raster_simple(raster_file):
    dataset = gdal.Open(raster_file,gdal.GA_ReadOnly)    
    dataset_val = dataset.GetRasterBand(1)
    nodatavalue = dataset_val.GetNoDataValue()    
    Array = dataset_val.ReadAsArray()
    Array[Array==nodatavalue]=-9999
    dataset.FlushCache()
    return np.float_(Array)


def get_source_src(file_name):
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()
    return source_layer.GetSpatialRef()


def shapefile_to_np_array(file_name,Extent,Csize,attribute_name,order_field=None,order=None):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)
    # Get information from source shapefile
    orig_data_source = ogr.Open(file_name)
    source_ds = ogr.GetDriverByName("Memory").CopyDataSource(orig_data_source, "")
    source_layer = source_ds.GetLayer()
    if order:
        source_layer_ordered = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' ORDER BY '+order_field+' '+order)
    else:source_layer_ordered=source_layer
    source_srs = source_layer.GetSpatialRef()
    # Initialize the new memory raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], source_layer_ordered,options=["ATTRIBUTE="+attribute_name,"ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        return mask_arr


def select_in_shapefile(source_shapefile,out_Shape_Path,expression):
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    #Get information from source shapefile
    source_ds = ogr.Open(source_shapefile)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    source_type = source_layer.GetGeomType()
    try: source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' '+expression)   
    except: console_info("Erreur de syntaxe dans l'expression")
    # Initialize the output shapefile
    if os.path.exists(out_Shape_Path):
        driver.DeleteDataSource(out_Shape_Path)
    target_ds = driver.CreateDataSource(out_Shape_Path)
    layerName = os.path.splitext(os.path.split(out_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    target_ds.Destroy()
    source_ds.Destroy()


def linestring_to_point(Line_shapefile,Point_Shape_Path):
    #Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Get line info
    source_ds = ogr.Open(Line_shapefile)
    source_layer = source_ds.GetLayer()
    source_srs = source_layer.GetSpatialRef()
    geoLocations = []
    ind = 1
    for feat in source_layer:
        geom = feat.GetGeometryRef()
        points = geom.GetPointCount()          
        for p in range(points):
            lon, lat,_ = geom.GetPoint(p)
            geoLocations.append([lon,lat,ind])
        ind +=1
    geoLocations = np.array(geoLocations)
    fins_ligne = fin_ligne(geoLocations)
    # Create output point shapefile
    if os.path.exists(Point_Shape_Path):driver.DeleteDataSource(Point_Shape_Path)
    target_ds = driver.CreateDataSource(Point_Shape_Path)
    layerName = os.path.splitext(os.path.split(Point_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_srs, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('IND_LINE', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('FIN_LIGNE', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind = 0
    for pointIndex, geoLocation in enumerate(geoLocations):
        # Create point
        geometry = ogr.Geometry(ogr.wkbPoint)
        geometry.SetPoint(0, geoLocation[0], geoLocation[1])
        # Create feature
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(pointIndex)
        feature.SetField('IND_LINE',int(geoLocation[2]))
        if pointIndex==fins_ligne[ind]:
            feature.SetField('FIN_LIGNE',1)
            ind +=1
            if ind > len(fins_ligne)-1:
                ind-=1
        else:
            feature.SetField('FIN_LIGNE',0)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        geometry.Destroy()
        feature.Destroy()
    # Cleanup
    target_ds.Destroy()
    return geoLocations,source_srs


def fin_ligne(point_coords):
    fin_ligne = []
    for i in range(point_coords.shape[0]-1):
        ind = np.sum((point_coords[:,0]==point_coords[i,0])*(point_coords[:,1]==point_coords[i,1]))
        if ind ==1:
            if i>0 and i+1<point_coords.shape[0]:
                if point_coords[i-1,2]!=point_coords[i,2] or point_coords[i+1,2]!=point_coords[i,2]:
                    fin_ligne.append(i)
            elif i==0 and point_coords[i+1,2]==point_coords[i,2]:fin_ligne.append(i)
            elif i==point_coords.shape[0]-1 and point_coords[i-1,2]==point_coords[i,2]:fin_ligne.append(i)
    return fin_ligne  


def points_to_lineshape(point_coords,Line_Shape_Path,projection):
    #Recupere le driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output line shapefile 
    if os.path.exists(Line_Shape_Path):driver.DeleteDataSource(Line_Shape_Path)
    target_ds = driver.CreateDataSource(Line_Shape_Path)
    layerName = os.path.splitext(os.path.split(Line_Shape_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, projection, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('DIRECTION', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind = 0
    while ind<point_coords.shape[0]-1:        
        if point_coords[ind+1,2]==point_coords[ind,2]:
            line = ogr.Geometry(ogr.wkbLineString)
            line.AddPoint(point_coords[ind,0],point_coords[ind,1])
            line.AddPoint(point_coords[ind+1,0],point_coords[ind+1,1])
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(line)
            feature.SetFID(ind)
            direction = calculate_direction(point_coords[ind,0],point_coords[ind,1], point_coords[ind+1,0],point_coords[ind+1,1])
            if ind+2< point_coords.shape[0] and point_coords[ind+1,2]==point_coords[ind+2,2]:
                feature.SetField('DIRECTION',direction)
            else:
                if direction <0:feature.SetField('DIRECTION',direction%180)
                else:feature.SetField('DIRECTION',direction%(-180))
            layer.CreateFeature(feature)
            ind +=1
            line.Destroy()
            feature.Destroy()
        else:
            ind +=1
    target_ds.Destroy()


def calculate_direction(x1,y1,x2,y2):
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    return int(Angle+0.5)


def get_head_text(ASCII_file):
    names = np.genfromtxt(ASCII_file, dtype=None,usecols=(0))[0:6]
    values = np.genfromtxt(ASCII_file, dtype=np.float,usecols=(1))[0:6]
    Extent = [values[2],values[2]+values[4]*values[0],values[3],values[3]+values[4]*values[1]]
    return names,values,Extent


def generate_head_text(names,values,Csize):
    rap = int(Csize/values[4])
    values[0],values[1],values[4]= int(values[0]/rap+0.5),int(values[1]/rap+0.5),Csize
    head_text=""
    for i,item in enumerate(names):
        head_text = head_text+item+(14-len(item))*" "+str(values[i])+"\n"
    return head_text


def buffer_shp(infile,outfile,buffdist):
    try:
        ds_in=ogr.Open( infile )
        lyr_in=ds_in.GetLayer( 0 )
        drv=ds_in.GetDriver()
        if os.path.exists( outfile ):
            drv.DeleteDataSource(outfile)
        ds_out = drv.CreateDataSource( outfile )
        layer = ds_out.CreateLayer(lyr_in.GetLayerDefn().GetName(),lyr_in.GetSpatialRef(), ogr.wkbPolygon)
        for i in range ( lyr_in.GetLayerDefn().GetFieldCount() ):
            field_in = lyr_in.GetLayerDefn().GetFieldDefn( i )
            fielddef = ogr.FieldDefn( field_in.GetName(), field_in.GetType() )
            layer.CreateField ( fielddef )
        for feat in lyr_in:
            geom = feat.GetGeometryRef()
            feature = feat.Clone()
            feature.SetGeometry(geom.Buffer(float(buffdist)))
            layer.CreateFeature(feature)
            del geom
        ds_out.Destroy()
    except:
        return False
    return True


def shapefile_obs_to_np_array(file_list,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Obstacle = np.zeros((nrows,ncols),dtype=np.int)
    #Loop on all shaefile
    for shp in file_list:        
        # Get shapefile info
        source_ds = ogr.Open(shp)
        source_layer = source_ds.GetLayer()    
        source_srs = source_layer.GetSpatialRef()
        source_type = source_layer.GetGeomType()
        # Create copy
        target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
        layerName = os.path.splitext(os.path.split(shp)[1])[0]
        layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
        layerDefinition = layer.GetLayerDefn()
        new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
        layer.CreateField(new_field)
        ind=0
        for feat in source_layer:
            geometry = feat.GetGeometryRef()
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetFID(ind)
            feature.SetField('Transfo',1)
            # Save feature
            layer.CreateFeature(feature)
            # Cleanup
            feature.Destroy()
            ind +=1
        # Initialize raster
        maskvalue = 1    
        xres=float(Csize)
        yres=float(Csize)
        geotransform=(xmin,xres,0,ymax,0, -yres)         
        target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
        target_ds.SetGeoTransform(geotransform)
        if source_srs:
            # Make the target raster have the same projection as the source
            target_ds.SetProjection(source_srs.ExportToWkt())
        else:
            # Source has no projection (needs GDAL >= 1.7.0 to work)
            target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        # Rasterize
        err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
        if err != 0:
            raise Exception("error rasterizing layer: %s" % err)
        else:
            target_ds.FlushCache()
            mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
        Obstacle = Obstacle + mask_arr
        target_ds1.Destroy()
        source_ds.Destroy()
    Obstacle = np.int8(Obstacle>0)
    return Obstacle


def shapefile_to_int8array(file_name,Extent,Csize):
    #Get raster dimension
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)        
    #Create obstacle raster
    Array = np.zeros((nrows,ncols),dtype=np.int8)      
    # Get shapefile info
    source_ds = ogr.Open(file_name)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    source_type = source_layer.GetGeomType()
    # Create copy
    target_ds1 = ogr.GetDriverByName("Memory").CreateDataSource("")
    layerName = "shp"
    layer = target_ds1.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Transfo', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Transfo',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Initialize raster
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)         
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=Transfo","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        Array = target_ds.GetRasterBand(1).ReadAsArray()
    target_ds1.Destroy()
    source_ds.Destroy()
    return Array


def raster_to_ASCII_int(raster_name,ascii_name):
    source_ds = gdal.Open(raster_name)
    content = source_ds.GetRasterBand(1).ReadAsArray()
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform() 
    ymin = ymax + Csize_y*source_ds.RasterYSize
    names = ['ncols','nrows','xllcorner','yllcorner','cellsize','NODATA_value']
    values = [source_ds.RasterXSize,source_ds.RasterYSize,xmin,ymin,Csize_x,-9999]
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    content[content==nodata]=-10000
    head_text=generate_head_text(names,values,Csize_x)
    save_integer_ascii(ascii_name,head_text,np.int_(content+0.5))


def raster_to_ASCII(raster_name,ascii_name):
    source_ds = gdal.Open(raster_name)
    content = source_ds.GetRasterBand(1).ReadAsArray()
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform()   
    ymin = ymax + Csize_y*source_ds.RasterYSize
    names = ['ncols','nrows','xllcorner','yllcorner','cellsize','NODATA_value']
    values = [source_ds.RasterXSize,source_ds.RasterYSize,xmin,ymin,Csize_x,-9999]
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    content[content==nodata]=-9999    
    head_text=generate_head_text(names,values,Csize_x)
    save_float_ascii(ascii_name,head_text,content)


def resample_raster(in_file_name,out_file_name,newCsize,methode=gdal.GRA_Bilinear):
    # Get info from source
    source_ds = gdal.Open(in_file_name)    
    driver = source_ds.GetDriver()
    src_proj = source_ds.GetProjection()
    src_ncols = source_ds.RasterXSize
    src_nrows = source_ds.RasterYSize
    xmin,Csize_x,_,ymax,_,Csize_y = source_ds.GetGeoTransform()
    xmin,ymax = int(xmin+0.5),int(ymax+0.5)    
    Bandnb = source_ds.RasterCount    
    # Create ouptut raster
    xres=float(newCsize)
    yres=float(newCsize)
    xmax,ymin = xmin+int(float(src_ncols)*float(Csize_x)+0.5),ymax+int(float(src_nrows)*float(Csize_y)-0.5)
    nrows,ncols = int((ymax-ymin)/float(newCsize)+0.5),int((xmax-xmin)/float(newCsize)+0.5) 
    geotransform=(xmin,xres,0,ymax,0,-yres)    
    if os.path.exists(out_file_name):driver.Delete(out_file_name)
    target_ds = driver.Create(out_file_name, int(ncols), int(nrows), Bandnb, gdal.GDT_Float32)    
    target_ds.SetGeoTransform(geotransform)
    if src_proj:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(src_proj)
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        src_proj = 'LOCAL_CS["arbitrary"]'    
    gdal.ReprojectImage(source_ds, target_ds, src_proj, src_proj, methode)
    target_ds.GetRasterBand(1).SetNoDataValue(0)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache() # Flush 


def get_proj_from_road_network(road_network_file):
    source_ds = ogr.Open(road_network_file)
    source_layer = source_ds.GetLayer()    
    source_srs = source_layer.GetSpatialRef()
    return source_srs.ExportToWkt()


def ArrayToGtiff(Array,file_name,Extent,nrows,ncols,road_network_proj,nodata_value,raster_type='INT32'):
    xmin,xmax,ymin,ymax=Extent[0],Extent[1],Extent[2],Extent[3]
    xres=(xmax-xmin)/float(ncols)
    yres=(ymax-ymin)/float(nrows)
    geotransform=(xmin,xres,0,ymax,0, -yres)
    if raster_type=='INT32':
        #-2147483648 to 2147483647
        DataType = gdal.GDT_Int32    
    elif raster_type=='UINT8':
        #0 to 255
        DataType = gdal.GDT_Byte
    elif raster_type=='UINT16':
        #0 to 65535    
        DataType = gdal.GDT_UInt16
    elif raster_type=='INT16':
        #-32768 to 32767 
        DataType = gdal.GDT_Int16
    elif raster_type=='FLOAT32':
        #Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
        DataType = gdal.GDT_Float32
    elif raster_type=='FLOAT16':
        #Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
        DataType = gdal.GDT_Float16
    target_ds = gdal.GetDriverByName('GTiff').Create(file_name+'.tif', int(ncols), int(nrows), 1, DataType)
    target_ds.SetGeoTransform(geotransform)
    target_ds.SetProjection(road_network_proj)
    target_ds.GetRasterBand(1).WriteArray( Array )
    target_ds.GetRasterBand(1).SetNoDataValue(nodata_value)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache()


def focal_stat(in_file_name,out_file_name,methode='MEAN',nbcell=3):    
    # Get info of the input raster
    source_ds = gdal.Open(in_file_name)
    nodata = source_ds.GetRasterBand(1).GetNoDataValue()
    driver = source_ds.GetDriver()
    src_proj = source_ds.GetProjection()
    nrows,ncols = source_ds.RasterYSize,source_ds.RasterXSize
    geotransform = source_ds.GetGeoTransform()
    Bandnb = source_ds.RasterCount   
    Data = source_ds.GetRasterBand(1).ReadAsArray()  
    #Make analysis
    if methode=='MEAN':
        outData = fc.focal_stat_mean(np.float_(Data),float(nodata),nbcell)
    elif methode=='MIN':
        outData = fc.focal_stat_min(np.float_(Data),float(nodata),nbcell)
    elif methode=='MAX':
        outData = fc.focal_stat_max(np.float_(Data),float(nodata),nbcell) 
    elif methode=='NB':
        outData = fc.focal_stat_nb(np.float_(Data),float(nodata),nbcell)   
    elif methode=='SUM':
        outData = fc.focal_stat_sum(np.float_(Data),float(nodata),nbcell)   
    #Inititialiaze output raster
    if os.path.exists(out_file_name):driver.Delete(out_file_name)
    target_ds = driver.Create(out_file_name, int(ncols), int(nrows), Bandnb, gdal.GDT_Float32)    
    target_ds.SetGeoTransform(geotransform)
    if src_proj:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(src_proj)
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
        src_proj = 'LOCAL_CS["arbitrary"]' 
    target_ds.GetRasterBand(1).WriteArray(outData)
    target_ds.GetRasterBand(1).SetNoDataValue(nodata)
    target_ds.GetRasterBand(1).GetStatistics(0,1)
    target_ds.FlushCache() # Flush


####################################################
#  ______     ___      .______    __       _______ #
# /      |   /   \     |   _  \  |  |     |   ____|#
#|  ,----'  /  ^  \    |  |_)  | |  |     |  |__   #
#|  |      /  /_\  \   |   _  <  |  |     |   __|  #
#|  `----./  _____  \  |  |_)  | |  `----.|  |____ #
# \______/__/     \__\ |______/  |_______||_______|#
####################################################
 
                                                  
# Fonctions qui gère les calculs liés au cable
def Cable():
    console_info("Cable")
    Wspace,Rspace,file_MNT,file_shp_Foret,_,file_shp_Cable_dep,_,_,_,Dir_Obs_cable,file_Htree,file_Vol_AM,file_Vol_ha = Sylvaccess_pluginDialog.get_spatial(1,1,1,1,1,0,1,0,0,0,1,1,1,1)
    _,_,_,_,Pente_max_bucheron = Sylvaccess_pluginDialog.get_general(1,0,0,0,0,1)
    Cable_type,sup_max,Htower,Lmax,Lmin=Sylvaccess_pluginDialog.get_type_cable(1,1,1,1,1,1)
    Carriage_type,Pchar,slope_grav,slope_Wliner_up,slope_Wliner_down = Sylvaccess_pluginDialog.get_type_chariot(1,1,1,1,1,1,1)
    d,masse_li,rupt_res,E = Sylvaccess_pluginDialog.get_proprietes_cable(1,1,1,1,1)
    Hintsup,Hend,Hline_min,Hline_max,Lhor_max,Load_max,safe_fact = Sylvaccess_pluginDialog.get_param_modelisation(1,1,1,1,1,1,1,1)
    test_cable_optimise,precision = Sylvaccess_pluginDialog.get_options(1,1,1)
    prelevement, _, _, _, _, _, _ = Sylvaccess_pluginDialog.get_opti_cable(1,1, 0, 0, 0, 0, 0, 0)
    surface, surface_poids, nbr_sup_int, nbr_sup_int_poids, sens_debardage, sens_debardage_poids, longueure_ligne,longueure_ligne_poids,vol_ligne,vol_ligne_poids,indice_prelev,indice_prelev_poids,VAM,VAM_poids,dist_chariot,dist_chariot_poids= Sylvaccess_pluginDialog.get_crit_opti(1,1,1,1,1,1,1,1,1)

    masse_li2 = 0.5
    masse_li3 = 0.5
    LminSpan = 50
    Max_angle = 30
    coeff_frot = 0.15
    angle_transv = 60
    slope_trans = 30
    Lslope = 75
    PropSlope = 0.15
    VariaH = 0
    lim_list = [surface, nbr_sup_int, sens_debardage, longueure_ligne, vol_ligne, indice_prelev, VAM, dist_chariot]
    w_list = [surface_poids, nbr_sup_int_poids, sens_debardage_poids, longueure_ligne_poids, vol_ligne_poids, indice_prelev_poids, VAM_poids, dist_chariot_poids]

    
    Hdebut = datetime.datetime.now()
    Dir_temp = Wspace+"Temp/"  
    ### Check if temporary files have been generated and have the same extent
    try:
        _,values,proj,Extent = raster_get_info(file_MNT)
        Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    except:
        console_info("Erreur: veuillez definir une projection pour le raster MNT")
        return ""
    try: 
        _,v1=read_info(Dir_temp+'info_extent.txt')
        for i,item in enumerate(values):
            if v1[i]!=round(item,2):
                prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,Pente_max_bucheron)
            if i+1>4:break
    except:
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,Pente_max_bucheron)
    
    # Inputs
    try:
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))                
        MNT= np.load(Dir_temp+"MNT.npy") 
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy") 
        try:
            Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        except:
            Aspect = np.uint16(fc.exposition(MNT,Csize,-9999))    
        try:
            CoordRoute= np.load(Dir_temp+"CoordRoute.npy") 
        except:
            TableX,TableY=create_coord_pixel_center_raster(values,nrows,ncols,Csize,Dir_temp)
            CoordRoute = np.zeros((Lien_RF.shape[0],2),dtype=np.float)
            for i,pixel in enumerate(Lien_RF):
                CoordRoute[i,0]=TableX[pixel[1]]
                CoordRoute[i,1]=TableY[pixel[0]] 
            np.save(Dir_temp+"CoordRoute.npy",CoordRoute) 
            del TableX,TableY
        try:
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
        except:
            Pente = np.uint16(prepa_obstacle_cable(Dir_Obs_cable,file_MNT,Dir_temp))
            Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))  
    except: 
        prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_dep,Dir_Obs_cable,Pente_max_bucheron)
        Forest = np.int8(np.load(Dir_temp+"Foret.npy"))
        Aerian_obs= np.int8(np.load(Dir_temp+"Obstacles_cables.npy"))         
        MNT= np.load(Dir_temp+"MNT.npy") 
        Lien_RF= np.load(Dir_temp+"Lien_RF_c.npy")  
        CoordRoute= np.load(Dir_temp+"CoordRoute.npy")
        Aspect = np.uint16(np.load(Dir_temp+"Aspect.npy"))
        Pente = np.uint16(np.load(Dir_temp+"Pente.npy")+0.5)    

    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])    
    
     
    ### Import optional files
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
        Vol_ha[Pente>Pente_max_bucheron]=0 
        test_vp = True
    else:test_vp = False
    if file_Vol_AM != "":
        Vol_AM = load_float_raster_simple(file_Vol_AM) 
        Vol_AM[Pente>Pente_max_bucheron]=0
        test_vam = True
    else:test_vam = False 
    if file_Htree != "":
        Hfor = load_float_raster_simple(file_Htree) 
        test_hfor = True
    else:
        Hfor=0
        test_hfor = False
    if test_vp or test_vam:
        if not test_vp:
            Vol_ha = np.zeros_like(MNT)
        if not test_vam:
            Vol_AM = np.zeros_like(MNT)


    Lmax2 = round(Lmax-(sqrt(2)*(max(np.max(Hfor)*0.6666,Hend)+5)),0) #In order to take into account anchorage
    Row_line,Col_line,D_line,Nbpix_line, Row_ext,Col_ext,D_ext,Dir_list=create_buffer(Csize,Lmax2,Lhor_max)    
    road_network_proj=get_proj_from_road_network(file_shp_Cable_dep)
    Skid_direction = 0
    Rspace_c,_,slope_min_up,slope_max_up,slope_min_down,slope_max_down=get_cable_configs(Rspace,slope_Wliner_up,
                                                                                       slope_Wliner_down,slope_grav,
                                                                                       Cable_type,Carriage_type,
                                                                                       Skid_direction) 
    try:os.mkdir(Rspace_c)
    except:pass
    Rspace_c+="/"
    Rspace_sel = Rspace_c+"FilesForOptimisation"
    try:os.mkdir(Rspace_sel)
    except:pass
    Rspace_sel+="/"
    save_raster_info(values,Rspace_sel)
    ### Calculation of useful variables
    g = 9.80665     # m.s-2
    angle_intsup = radians(Max_angle) 
    Fo =  g*(Load_max+Pchar)
    Lsans_foret = min(Lmax*0.1,Lmin)          # Longueur max contigue sans foret
    Ao = 0.25*pi*(d**2) 
    Tmax = float(rupt_res)*g/float(safe_fact)
    EAo = E*Ao
    idLinemin = np.max([1,int(LminSpan/Csize+1.5),int(10/Csize+0.5)])
    
    # D H diag slope fact indmin indmax LoL ThL TvL TupL TdownL LoUg ThUg TvUg ind_fin_span free xmidL zmidL 
    # 0 1 2    3     4    5      6      7   8   9   10   11     12   13   14   15           16   17    18  
    Span = np.zeros((sup_max+1,16),dtype=np.float)
    rastLosup,rastTh,rastTv= check_tabconv(Dir_temp,d,E,Tmax,Lmax2,Fo,masse_li,masse_li2,masse_li3,Csize)    
    
    ### Preparation of forest roads
    nbconfig = 5       
    if precision > 1:Dir_list = range(0,360,2)
    if precision == 3:
        step_route = 2
        nbconfig = 1       
    else:
        step_route = 1
    nb_pixel_route = int((Lien_RF.shape[0]-1)/float(step_route))    
    
    Fin_ligne_forcee = np.int8(np.greater(Aerian_obs+(MNT<0),0))
    
    console_info("    - Initialisation achevee, debut de traitement...")
    str_nb_pixel_route=  " / "+str(nb_pixel_route-1)+ " pixels traites"
    
    Tab = np.zeros((min(1000000,int(nb_pixel_route*(360)/step_route)),18+5*sup_max),dtype=np.int)
    File_Tab = []
    Tab_nb=0
    
    testExist = False
    if np.sum(Lien_RF[:,2]==1)>0:
        testExist = True
    
    ##############################################################################################################################################
    ### 2. PROCESSING OF THE AREA: TEST ALL POSSIBLE LINES
    ##############################################################################################################################################
    
    # Loop on forest road pixels
    Route = range(1,Lien_RF.shape[0]-1,step_route)
    id_line = 0
    Rast_couv = np.zeros((nrows,ncols),dtype=np.int8)
    if testExist:
        Rast_couv2 = np.zeros((nrows,ncols),dtype=np.int8)
    test=0
    for idpix,pixel in enumerate(Route):  
        # console_info process
        sys.stdout.write("\r%d" % idpix + str_nb_pixel_route)
        sys.stdout.flush()
        #Get point coordinates
        coordY = Lien_RF[pixel,0]
        coordX = Lien_RF[pixel,1]
        direction = Lien_RF[pixel,4]
        if MNT[coordY,coordX]>-9999 and not Aerian_obs[coordY,coordX]:             
            RoadState = Lien_RF[pixel,2]
            posiY = CoordRoute[pixel,1]
            posiX = CoordRoute[pixel,0]   
            for az in Dir_list:                                          
                test,Lline,Line = get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax2,Lmin,Csize,
                                             Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
                                             Fo,Tmax,masse_li,masse_li2,masse_li3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope)   
                if test==1:           
                    Span*=0    
                    Falt = InterpolatedUnivariateSpline(Line[:,0],Line[:,1])
                    Alts = Falt(np.arange(0.,Lline,0.5))
                    ### Optimize line
                    if Line[0,1]+Htower>=np.max(Line[idLinemin:,1])+Hend:   
                        if direction==2:
                            continue
                        #console_info az,"up",Line[-1,0] 
                        if VariaH:
                            Span = fc.OptPyl_Up(Line,Alts,Span,Htower,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,
                                                 Csize,angle_intsup,EAo,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                 LminSpan,slope_min_up,slope_max_up,test_hfor,nbconfig)
                        else:
                            Span = fc.OptPyl_Up_NoH(Line,Alts,Span,Htower,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,
                                                     Csize,angle_intsup,EAo,sup_max,rastLosup,rastTh,rastTv,Tmax,
                                                     LminSpan,slope_min_up,slope_max_up,test_hfor,nbconfig)
                        config = 1
                    else:    
                        if direction==1:
                            continue
                        #console_info az,"down",Line[-1,0]
                        if VariaH:
                            Span = fc.OptPyl_Down_init(Line,Alts,Span,Htower, Hend,masse_li,masse_li2,masse_li3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo, 
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,test_hfor)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = fc.OptPyl_Down(Line2,Alts,Span*0,Htower,Hintsup,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,Csize,angle_intsup,
                                                   EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan, min(-slope_min_down,-slope_max_down),
                                                   max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                        else:
                            Span = fc.OptPyl_Down_init_NoH(Line,Alts,Span,Htower, Hend,masse_li,masse_li2,masse_li3,Fo,
                                             Hline_min,Hline_max,Csize,angle_intsup,EAo,
                                             sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,
                                             slope_min_down, slope_max_down,test_hfor,nbconfig)
                            if Span[0,0]==0 or np.sum(Span[:,2])<Lmin:
                                test=0
                                continue
                            indmax=min(int(np.max(Span[:,15]))+2,Line.shape[0])
                            Line2=return_profile(Line[:indmax+1])
                            Falt = InterpolatedUnivariateSpline(Line2[:,0],Line2[:,1])
                            Alts = Falt(np.arange(0.,Lline,0.5))    
                            Span = fc.OptPyl_Down_NoH(Line2,Alts,Span*0,Htower,Hintsup,Hend,masse_li,masse_li2,masse_li3,Fo,Hline_min,Hline_max,Csize,
                                                       angle_intsup,EAo,E,d,sup_max,rastLosup,rastTh,rastTv,Tmax,LminSpan,min(-slope_min_down,-slope_max_down),
                                                       max(-slope_min_down,-slope_max_down),Lmax2,test_hfor,nbconfig)
                            config=-1
                    ind_max_Line = int(np.max(Span[:,15]))                    
                    if Span[0,0]==0 or np.sum(Span[:,2])<Lmin or Line[ind_max_Line,8]==0:
                        test=0
                        continue                    
                    nbintsup = np.sum(Span[:,0]>0)-1
                    ### Save Line carac
                    Line = Line[0:ind_max_Line+1]
                    Lline = Line[ind_max_Line,0]                    
                    if test_vp or test_vam:    
                        if RoadState==2:
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv = fc.get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv,Vol_ha,Vol_AM)
                        else: 
                            Distance_moyenne,Surface,Vtot,VAM,Rast_couv2 = fc.get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2,Vol_ha,Vol_AM)
                    else:
                        if RoadState==2:
                            Distance_moyenne,Surface,Rast_couv = fc.get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv)
                        else:
                            Distance_moyenne,Surface,Rast_couv2 = fc.get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv2)
                    #pixel, direction
                    Tab[id_line,0],Tab[id_line,1] = pixel,az
                    #Xstart,Ystart,Zstart,Hcable_start
                    Tab[id_line,2],Tab[id_line,3],Tab[id_line,4],Tab[id_line,5]=Line[0,3],Line[0,4],Line[0,1],Htower
                    #Xend,Yend,Zend,Hcable_end
                    Tab[id_line,6],Tab[id_line,7],Tab[id_line,8],Tab[id_line,9] = Line[ind_max_Line,3],Line[ind_max_Line,4],Line[ind_max_Line,1],Span[nbintsup,14]
                    #Road existing or not,Ltot,Config
                    Tab[id_line,10],Tab[id_line,11],Tab[id_line,12] = int(RoadState),int(np.sum(Span[:,2])+0.5),config
                    #Surface foret Dmoy chariot
                    Tab[id_line,13],Tab[id_line,14]=Surface,Distance_moyenne
                    #Vtot IPC
                    if test_vp:
                        Tab[id_line,15]=Vtot
                    #VAM               
                    if test_vam:
                        Tab[id_line,16]=VAM*10
                    #Int sup info  
                    Tab[id_line,17]=nbintsup
                    for pyl in range(0,nbintsup):
                        Tab[id_line,18+5*pyl]=Line[int(Span[pyl,15]),3]#X
                        Tab[id_line,19+5*pyl]=Line[int(Span[pyl,15]),4]#Y
                        Tab[id_line,20+5*pyl]=Line[int(Span[pyl,15]),1]#Alts
                        Tab[id_line,21+5*pyl]=Span[pyl,14]#Hcable
                        Tab[id_line,22+5*pyl]=atan(abs(Span[pyl,3]-Span[pyl+1,3]))*Span[pyl,10]+Fo#Press
                    id_line+=1
                    if id_line == 1000000:                        
                        np.save(Dir_temp+"Tab"+str(Tab_nb)+".npy",Tab[Tab[:,11]>0])
                        File_Tab.append(Dir_temp+"Tab"+str(Tab_nb)+".npy")
                        Tab_nb +=1
                        id_line=0
                        Tab = np.zeros((1000000,18+5*sup_max),dtype=np.int)

   
    console_info("\n    - Sauvegarde des resultats")
   
    ### Save Forest,Vol_ha,VolAm,Pente
    np.save(Rspace_sel+"Forest.npy",Forest)
    if test_vp:
        np.save(Rspace_sel+"Vol_ha.npy",Vol_ha)
    if test_vam:
        np.save(Rspace_sel+"Vol_AM.npy",Vol_AM)
    np.save(Rspace_sel+"Pente.npy" ,Pente)
    np.save(Rspace_sel+"Lien_RF_c.npy",Lien_RF)
    ### Del useless    
    try:
        del Line2
    except:
        pass
    del rastLosup,rastTh,rastTv,Row_line,Col_line,D_line,Nbpix_line,CoordRoute,Aerian_obs,Lien_RF
    gc.collect()
    ### Save results
    Tab = Tab[Tab[:,11]>0]
    if Tab_nb>0:
        for files in File_Tab:
            Tabbis = np.load(files)
            Tab = np.concatenate((Tab,Tabbis))
    np.save(Rspace_sel+"Tab_all_lines.npy",Tab)    
    
    if testExist :        
        Rast_couv += 10*Rast_couv2
        Rast_couv[Rast_couv==11]=2
        Rast_couv[Rast_couv==1]=2
        Rast_couv[Rast_couv==10]=1
    
    if not test_vp:
        Vol_ha=np.zeros_like(MNT)    
    else:
        Vol_ha = load_float_raster_simple(file_Vol_ha) 
    generate_info_cable_simu(Rspace_c,Tab,Rast_couv,Vol_ha,Csize,Forest,Pente,Pente_max_bucheron)
    
    ### Del useless   
    del Forest,Pente,Line,Alts,Span,MNT,Fin_ligne_forcee,Aspect,Falt
    try:
        del Vol_ha,Vol_AM,Rast_couv2 
    except:
        pass
    
    #Save Global res        
    header = 'ID_pixel Azimuth X_debut Y_debut Alt_debut Hcable_debut X_fin Y_fin Alt_fin Hcable_fin '
    header += 'Etat_RouteFor Longueur_reelle Configuration '
    header +='Surface_foret Distance_moy_chariot Volume_total VAM NB_int_sup'
    for num in range(1, sup_max + 1):
        header +=' '+'Xcoord_intsup'+str(num)+' Ycoord_intsup'+str(num)+' Alt_intsup'+str(num)
        header +=' '+'Hcable_intsup'+str(num)+' Pression_intsup'+str(num)
    filename=Rspace_c+"Database_toutes_lignes.gzip"
    shape_name = Rspace_c+"Toutes_les_lignes.shp"
    rast_name = Rspace_c+'Zone_accessible'
            
    
    ArrayToGtiff(Rast_couv,rast_name,Extent,nrows,ncols,road_network_proj,0,'UINT8')
    header+='\n'
    save_integer_ascii(filename,header,Tab)
    source_src=get_source_src(file_shp_Cable_dep) 
    Line_to_shapefile(Tab[0:2],Rspace_sel+"info_proj.shp",source_src,0)
    if Tab.shape[0]<1000000:         
        Line_to_shapefile(Tab,shape_name,source_src,prelevement)
    
    ##############################################################################################################################################
    ### 3. CREATE SIMULATION PARAMETER FILE
    ##############################################################################################################################################
    str_duree,str_fin,str_debut=heures(Hdebut)
    
    if Carriage_type==1:
        carriage_name = 'Automoteur'
    else:
        carriage_name = 'Classique'
    if Cable_type < 3:
        cable_name= 'Cable mat'
    else:
        cable_name= 'Cable long/conventionnel'
        
    file_name = str(Rspace_c)+"Parametre_simulation.txt"
    resume_texte = "SYLVACCESS - CABLE\n\n\n"
    resume_texte = resume_texte+"Version du programme: 3.5.1 de 12/2021\n"
    resume_texte = resume_texte+"Auteur: Sylvain DUPIRE. Irstea\n\n"
    resume_texte = resume_texte+"Date et heure de lancement du script:                                      "+str_debut+"\n"
    resume_texte = resume_texte+"Date et heure a la fin de l'execution du script:                           "+str_fin+"\n"
    resume_texte = resume_texte+"Temps total d'execution du script:                                         "+str_duree+"\n\n"
    resume_texte = resume_texte+"PROPRIETES DU MATERIEL MODELISE:\n"
    resume_texte = resume_texte+"   - Type de machine:                                                      "+str(cable_name)+"\n"
    resume_texte = resume_texte+"   - Hauteur du mat ou du cable porteur au niveau de la place de depot:    "+str(Htower)+" m\n"
    resume_texte = resume_texte+"   - Nombre maximum de support(s) intermediaire(s):                        "+str(sup_max)+"\n"
    resume_texte = resume_texte+"   - Longueur maximale du cable porteur:                                   "+str(Lmax)+" m\n"
    resume_texte = resume_texte+"   - Longueur minimale d'une ligne:                                        "+str(Lmin)+" m\n"
    resume_texte = resume_texte+"   - Longueur minimale entre deux supports:                                "+str(LminSpan)+" m\n"
    resume_texte = resume_texte+"   - Type de chariot:                                                      "+str(carriage_name)+"\n"
    resume_texte = resume_texte+"   - Masse a vide du chariot:                                              "+str(Pchar)+" kg\n"
    resume_texte = resume_texte+"   - Masse maximale de la charge:                                          "+str(Load_max)+" kg\n"
    if Carriage_type==1:   
        resume_texte = resume_texte+"   - Pente max du cable porteur pour un debardage vers l'amont:            "+str(slope_Wliner_up)+" %\n"    
        resume_texte = resume_texte+"   - Pente max du cable porteur pour un debardage vers l'aval:             "+str(slope_Wliner_down)+" %\n"   
    else: 
        resume_texte = resume_texte+"   - Pente min du cable porteur pour que le chariot descende par gravite:  "+str(slope_grav)+" %\n"  
    resume_texte = resume_texte+"\n"
    resume_texte = resume_texte+"PROPRIETES DU CABLE PORTEUR:\n"    
    resume_texte = resume_texte+"   - Diametre du cable porteur:                                            "+str(d)+" mm\n"
    resume_texte = resume_texte+"   - Masse lineique du cable porteur:                                      "+str(masse_li)+" kg.m-1\n"
    resume_texte = resume_texte+"   - Module de Young (Elasticite):                                         "+str(E)+" N.mm-2\n"
    resume_texte = resume_texte+"   - Tension de rupture du cable porteur                                   "+str(rupt_res)+" kgF\n\n"
    if Carriage_type!=1:
        resume_texte = resume_texte+"PROPRIETES DES CABLES TRACTEUR ET RETOUR:\n"  
        resume_texte = resume_texte+"   - Masse lineique du cable tracteur:                                     "+str(masse_li2)+" kg.m-1\n"
        resume_texte = resume_texte+"   - Masse lineique du cable retour:                                       "+str(masse_li3)+" kg.m-1\n"
        resume_texte = resume_texte+"\n"        
    resume_texte = resume_texte+"PARAMETRES DE MODELISATION:\n"
    resume_texte = resume_texte+"   - Distance laterale de pechage des bois:                                "+str(Lhor_max)+" m\n"
    resume_texte = resume_texte+"   - Hauteur du cable porteur au niveau des pylone intermediaire:          "+str(Hintsup)+" m\n"
    resume_texte = resume_texte+"   - Hauteur du cable porteur en fin de ligne:                             "+str(Hend)+" m\n"
    resume_texte = resume_texte+"   - Hauteur minimale du cable en tout point (en charge):                  "+str(Hline_min)+" m\n"
    resume_texte = resume_texte+"   - Hauteur maximale du cable en tout point:                              "+str(Hline_max)+" m\n"
    resume_texte = resume_texte+"   - Angle maximum du cable porteur au niveau d'un pylone intermediaire:   "+str(Max_angle)+" degres\n"
    resume_texte = resume_texte+"   - Facteur de securite:                                                  "+str(safe_fact)+"\n"
    resume_texte = resume_texte+"   - Valeur de l'angle de frottement:                                      "+str(coeff_frot)+" rad\n\n"
    resume_texte = resume_texte+"   - Resolution du MNT utilise:                                            "+str(Csize)+" m\n"
    resume_texte = resume_texte+"   - Prelevement du volume sur pied applique:                              "+str(prelevement*100)+" %\n"
    try:
        resume_texte = resume_texte+"   - Projection:                                                           "+str(proj.GetAttrValue("PROJCS", 0))+"\n"
    except:
        resume_texte = resume_texte+"   - Projection:                                                           inconnue\n"
    if Dir_Obs_cable=="":
        reponse = "Non"
    else:
        reponse = "Oui"
    resume_texte = resume_texte+"   - Prise en compte d'obstacle pour le cable:                             "+str(reponse)+"\n"
    if file_Vol_ha=="":
        reponse = "Non"
    else:
        reponse = "Oui"
    resume_texte = resume_texte+"   - Information sur le volume de bois fournie en entree:                  "+str(reponse)+"\n"
    
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    
    file_name = Rspace_sel+"info_Lhormax.txt"
    fichier = open(file_name, "w")
    fichier.write(str(Lhor_max))
    fichier.close()
    
    
    console_info("\nToutes les lignes possibles ont ete testees.\n")     
    ##############################################################################################################################################
    ### 4. SELECTION OF BEST LINE IF CHECKED
    ##############################################################################################################################################
    if test_cable_optimise:
        line_selection(Rspace_c,w_list,lim_list,0,file_shp_Foret,file_Vol_ha,file_Vol_AM,Lhor_max,prelevement,Pente_max_bucheron)


def prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize):
    rastLosup,rastTh,rastTv = fc.Tabmesh(d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)
    np.save(Dir_temp+"rastLosup.npy",rastLosup)
    np.save(Dir_temp+"rastTh.npy",rastTh)
    np.save(Dir_temp+"rastTv.npy",rastTv)
    text  = "d    "+" "+str(round(d,2))+"\n"
    text += "E    "+" "+str(round(E,2))+"\n"
    text += "Tmax "+" "+str(round(Tmax,2))+"\n"
    text += "Lmax "+" "+str(round(Lmax,2))+"\n"
    text += "Fo   "+" "+str(round(Fo,2))+"\n"
    text += "Csize"+" "+str(round(Csize,2))+"\n"
    text += "masse_li   "+" "+str(round(masse_li,2))+"\n"
    text += "masse_li2   "+" "+str(round(masse_li2,2))+"\n"
    text += "masse_li3   "+" "+str(round(masse_li3,2))+"\n"
    f = open(Dir_temp+'info_config.txt',"w")
    f.write(text)
    f.close()
    return rastLosup,rastTh,rastTv


def check_tabconv(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize):
    try:
        _,v1=read_info(Dir_temp+"info_config.txt")
        if np.all(np.array([round(d,2),round(E,2),round(Tmax,2),round(Lmax,2),round(Fo,2),round(Csize,2),round(masse_li,2),round(masse_li2,2),round(masse_li3,2)])==v1):
            rastLosup = np.load(Dir_temp+"rastLosup.npy")
            rastTh = np.load(Dir_temp+"rastTh.npy")
            rastTv = np.load(Dir_temp+"rastTv.npy")
        else:
            rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)
    except:
        rastLosup,rastTh,rastTv = prep_rast(Dir_temp,d,E,Tmax,Lmax,Fo,masse_li,masse_li2,masse_li3,Csize)        
    return rastLosup,rastTh,rastTv


def check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret):
    indmax = 0
    npix = Line.shape[0]
    test = 1
    i=0
    Dsansforet=0.
    for i in range(0,npix): 
        if Line[i,5]<0:break
        if Line[i,5]>=ncols:break
        if Line[i,6]<0:break
        if Line[i,6]>=nrows:break
        if Line[i,7]==1:break
        if sqrt(Line[i,0]*Line[i,0]+(Line[i,1]-Line[0,1])*(Line[i,1]-Line[0,1]))>Lmax:break        
        if (Line[i,8]+Line[i,9])>0:                 
            if Line[i,2]==1:
                indmax = i 
                Dsansforet=0
            else:
                if i>0: Dsansforet+=Line[i,0]-Line[i-1,0]
                if Dsansforet>=Lsans_foret:break
        else:        
            break
    Lline = Line[indmax,0]
    if Lline <= Lmin:
        test=0
    return test,indmax+1,Lline


def get_ligne3(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Hfor,test_hfor,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret,
              Fo,Tmax,masse_li,masse_li2,masse_li3,Htower,Hend,Hline_max,Hintsup,Lslope,PropSlope):
                  
    npix = Nbpix_line[az]
    npix = fc.get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,11),dtype=np.float)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        ### Check pente en devers
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1 
        if test_hfor:
            Line[:,10]=np.round(np.minimum(np.maximum(-7.76961+0.71858*Hfor[inds],0),26))
        else:
            Line[:,10]=Hintsup
        ####Raccourci pour ne pas depasser Hline_max
        indmax=Line.shape[0]-1
        for i in range(indmax,1,-1):  
            test=1
            D = Line[i,0]
            H = abs(Line[0,1]+Htower-(Line[i,1]+Hend))    
            if Line[0,1]+Htower>=Line[i,1]+Hend:
                Xup,Zup =0,Line[0,1]+Htower
                fact = 1. 
            else:    
                Xup,Zup = Line[i,0],Line[i,1]+Hend
                fact = -1.             
            L=sqrt(H*H+D*D)
            F = 0.5*(0.5*L*masse_li2+0.5*L*masse_li3)*9.80665 + Fo  
            fleche = 1.1*(F*L/(4*Tmax)+masse_li*9.80665*L*L/(8*Tmax))
            for j in range(1,i-1):
                droite = -fact*H/D*(Line[j,0]-Xup)+Zup-Line[j,1]
                if droite-fleche > Hline_max:
                    test=0
                    break
            if test:
                break
        Line=Line[0:i+1]
        test,indmax,Lline=fc.check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret,Lslope,PropSlope)
        Lline = 2 # A modifier    
        return test,Lline,Line[0:indmax, [0, 1, 2, 3, 4, 5, 6,10,9]]
    else:
        return 0,0,0 


def return_profile(Line):
    Line2 = np.zeros_like(Line)
    indmax = Line.shape[0]-1
    Dmax =Line[indmax,0]
    for i,j in enumerate(range(indmax,-1,-1)):
        Line2[i]=Line[j]
        Line2[i,0]=Dmax-Line[j,0]
    return Line2


def azimuth(X0,Y0,X1,Y1):
    dX=abs(X0-X1)
    dY=abs(Y0-Y1)
    #cas 1:cadran en haut a droite
    if (X1>X0) and (Y1>Y0):
        az=degrees(atan(dX*1.0/dY))
    #cas 2:cadran en bas a droite
    elif (X1>X0) and (Y1<Y0):
        az=180-degrees(atan(dX*1.0/dY))
    #cas 3:cadran en haut a gauche
    elif (X1<X0) and (Y1>Y0):
        az=360-degrees(atan(dX*1.0/dY)) 
    #cas 4:cadran en bas a gauche
    elif (X1<X0) and (Y1<Y0):
        az=180+degrees(atan(dX*1.0/dY)) 
    #cas 5:horizontal gauche
    elif (dY==0) and (X1>X0):
        az=90
    #cas 6:horizontal droite
    elif (dY==0) and (X1<X0):
        az=90*3
    #cas 7:vertical haut
    elif (Y1>=Y0) and (dX==0):
        az=0
    #cas 8:vertical bas
    elif (Y1<Y0) and (dX==0):
        az=180
    return az


def from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az):    
    X1 = sin(radians(az))*Lmax
    Y1 = cos(radians(az))*Lmax
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    line = ogr.Geometry(ogr.wkbLineString)
    line.AddPoint(0,0)
    line.AddPoint(X1,Y1)
    feature = ogr.Feature(layerDefinition)
    feature.SetGeometry(line)
    feature.SetFID(az)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return X1,Y1,mask_arr


def check_common_line(item,Row_line,Col_line,D_line,nb_pix):
    i=0
    while (Row_line[item-1,i]==Row_line[item,i]) and (Col_line[item-1,i]==Col_line[item,i]) and i<nb_pix:
        i+=1
    return D_line[item,i-1]


def pt_emprise(X0,Y0,X1,Y1,Lhor_max):
    az=azimuth(X0,Y0,X1,Y1)
    #deb + 90
    X = [X0+sin(radians(az+90))*Lhor_max]
    Y = [Y0+cos(radians(az+90))*Lhor_max]
    #deb - 90
    X.append(X0+sin(radians(az-90))*Lhor_max)
    Y.append(Y0+cos(radians(az-90))*Lhor_max)
    #fin - 90
    X.append(X1+sin(radians(az-90))*Lhor_max)
    Y.append(Y1+cos(radians(az-90))*Lhor_max)
    #fin + 90
    X.append(X1+sin(radians(az+90))*Lhor_max)
    Y.append(Y1+cos(radians(az+90))*Lhor_max)
    return [X,Y] 


def point_line_to_line_ext(X0,Y0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize):
    ### Create mask_array
    X,Y = pt_emprise(X0,Y0,X1,Y1,Lhor_max)
    #Initialize raster info
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #create polygon object:
    driver = ogr.GetDriverByName('Memory')
    datasource = driver.CreateDataSource('')
    source_srs=osr.SpatialReference()
    source_srs.ImportFromEPSG(2154)
    layer = datasource.CreateLayer('layerName',source_srs,geom_type=ogr.wkbPolygon)
    new_field = ogr.FieldDefn('ID', ogr.OFTInteger)
    layer.CreateField(new_field)
    # create polygon object:
    myRing = ogr.Geometry(ogr.wkbLinearRing)
    for i in range(0,len(X)):
        myRing.AddPoint(X[i],Y[i])
    myRing.AddPoint(X[0],Y[0])#close ring
    poly = ogr.Geometry(type=ogr.wkbPolygon)
    poly.AddGeometry(myRing)
    feature = ogr.Feature( layer.GetLayerDefn() )
    feature.SetGeometry(poly)
    feature.SetFID(1)
    feature.SetField('ID',1)
    layer.CreateFeature(feature)    
    feature.Destroy()     
    # Initialize the new memory raster      
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int16)
    target_ds.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds, [maskvalue], layer,options=["ATTRIBUTE=ID","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds.FlushCache()
        mask_arr = target_ds.GetRasterBand(1).ReadAsArray()
    datasource.Destroy()
    return mask_arr


def get_car_dist(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        _ ,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
    return mat


def get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,item,mat):
    A = np.zeros((Nbpix_line[item],2))
    A[:,0] = Row_line[item,0:Nbpix_line[item]]
    A[:,1] = Col_line[item,0:Nbpix_line[item]]
    Tree=spatial.cKDTree(A)
    for i,pixel in enumerate(mat):
        pt = [pixel[0],pixel[1]]
        distance,index = Tree.query(pt)
        mat[i,2]=D_line[item,index]
        mat[i,3]=distance
    return mat


def ligh_line(mat,Dmin):
    mat[0,3]=1
    for i in range(1,mat.shape[0]):
        if (mat[i,2]-mat[i-1,2])>Dmin:
            mat[i,3]=1
    return mat[mat[:,3]>0]


def create_buffer(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+1))
        mat[:,:-1] = inds
        mat = get_car_dist(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],Dir_list


def create_buffer2(Csize,Lmax,Lhor_max):
    Lcote = Lmax+Lhor_max+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((Lmax+Lhor_max)/Csize+1.5)
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)
    Row_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    Col_ext = np.zeros((len(Dir_list),50*Buffer_cote),dtype=np.int16)
    D_ext = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*-1
    D_lat = np.ones((len(Dir_list),50*Buffer_cote),dtype=np.float)*(Lmax+Lhor_max)
    Nbpix_ext = 0
    Dmin = sqrt(2)*Csize*0.5
    for az in Dir_list:
        #Fill line info
        X1,Y1,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lmax,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],4))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        mat = ligh_line(mat,Dmin)
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix
        #Fill extent info
        mask_arr=point_line_to_line_ext(0,0,X1,Y1,Lhor_max,xmin,xmax,ymin,ymax,Csize)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],inds.shape[1]+2))
        mat[:,:-2] = inds
        mat= get_car_dist2(Row_line,Col_line,D_line,Nbpix_line,az,mat)
        ind = np.lexsort((mat[:,1],mat[:,2]))               
        nb_pix=inds.shape[0]
        Row_ext[az,0:nb_pix]=mat[ind,0]
        Col_ext[az,0:nb_pix]=mat[ind,1]
        D_ext[az,0:nb_pix]=mat[ind,2]
        D_lat[az,0:nb_pix]=mat[ind,3]*Csize
        Nbpix_ext = max(nb_pix,Nbpix_ext)
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line, Row_ext[:,0:Nbpix_ext],Col_ext[:,0:Nbpix_ext],D_ext[:,0:Nbpix_ext],D_lat[:,0:Nbpix_ext],Dir_list


def get_ligne(coordX,coordY,posiX,posiY,az,MNT,Forest,Fin_ligne_forcee,Aspect,Pente,Lmax,Lmin,Csize,
              Row_line,Col_line,D_line,Nbpix_line,angle_transv,slope_trans,ncols,nrows,Lsans_foret):
    npix = Nbpix_line[az]
    npix = fc.get_npix(az,npix,coordY,coordX,ncols,nrows,Row_line,Col_line)   
    if D_line[az,npix-1]>Lmin:  
        Line=np.zeros((npix,10),dtype=np.float)
        inds = (Row_line[az,0:npix]+coordY,Col_line[az,0:npix]+coordX)        
        Line[:,0],Line[:,1],Line[:,2]=D_line[az,0:npix],MNT[inds],Forest[inds]
        Line[:,3],Line[:,4]=Csize*Col_line[az,0:npix]+posiX,-Csize*Row_line[az,0:npix]+posiY
        Line[:,5],Line[:,6]=Col_line[az,0:npix]+coordX,Row_line[az,0:npix]+coordY 
        Line[:,7],Line[:,8],Line[:,9]=Fin_ligne_forcee[inds],np.abs(((az-np.int_(Aspect[inds]))+180)%360-180),(np.int_(Pente[inds])<slope_trans)*1
        Line[:,8] = (Line[:,8]>(90+angle_transv))*1+(Line[:,8]<(90-angle_transv))*1
        test,indmax,Lline=fc.check_line(Line,Lmax,Lmin,nrows,ncols,Lsans_foret)    
        return test,Lline,Line[0:indmax,0:7]
    else:
        return 0,0,0


def create_az_rules(angle_transv):
    matrice = np.zeros((360,360),dtype=np.int8)
    b1 = 90-angle_transv
    b2 = 90+angle_transv
    b3 = 270-angle_transv
    b4 = 270+angle_transv
    matrice[0,0:b1]=1
    matrice[0,b2:b3]=1
    matrice[0,b4:360]=1
    for expo in range(1,360,1):
        matrice[expo,0]=matrice[expo-1,359]
        for azi in range(1,360,1):
            matrice[expo,azi]=matrice[expo-1,azi-1]
    return matrice 


def Line_to_shapefile(Tab,Cable_line_Path,source_src,prelevement,language):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    fieldvol = 'Volume_'+str(int(100*prelevement))
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xstart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ystart', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Yend', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Id_route', ogr.OFTInteger)
    layer.CreateField(new_field)
    if language=='FR':
        new_field = ogr.FieldDefn('Desserte', ogr.OFTString) 
        
    else:
        new_field = ogr.FieldDefn('Road', ogr.OFTString)                              
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('AzimuthDeg', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Long', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Config', ogr.OFTString)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('NbIntSup', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Surface', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn(fieldvol, ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('IPC', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Dmoy', ogr.OFTInteger)
    layer.CreateField(new_field)
    cneg = "Debardage vers l'aval"
    cpos = "Debardage vers l'amont"
    proj = "En projet"
    exis = "Existant"

    
    for ind,S in enumerate(Tab):
        line = ogr.Geometry(ogr.wkbLineString)
        line.AddPoint(float(S[2]),float(S[3]))
        line.AddPoint(float(S[6]),float(S[7]))
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(line)
        feature.SetFID(ind)
        feature.SetField('IdLine',ind+1)
        feature.SetField('Xstart',float(S[2]))
        feature.SetField('Ystart',float(S[3]))
        feature.SetField('Xend',float(S[6]))
        feature.SetField('Yend',float(S[7]))
        if int(S[10])==2: 
            feature.SetField('Desserte',exis)
        else:
            feature.SetField('Desserte',proj)
        feature.SetField('Id_route',int(S[0]))
        feature.SetField('AzimuthDeg',int(S[1]))
        feature.SetField('Long',int(S[11]))
        if int(S[12])>0:
            feature.SetField('Config',cpos)
        else:
            feature.SetField('Config',cneg)
        feature.SetField('NbIntSup',int(S[17]))
        feature.SetField('Surface',S[13]/10000.)
        feature.SetField('Dmoy',int(S[14]))
        feature.SetField(fieldvol,int(S[15]*prelevement))
        feature.SetField('IPC',S[15]*prelevement/float(S[11]))
        layer.CreateFeature(feature)
        line.Destroy()
        feature.Destroy()
    target_ds.Destroy()


def Pylone_in_shapefile(Tab,Cable_line_Path,source_src):
    # Get driver
    driver = ogr.GetDriverByName('ESRI Shapefile')
    # Create output shapefile
    if os.path.exists(Cable_line_Path):driver.DeleteDataSource(Cable_line_Path)
    target_ds = driver.CreateDataSource(Cable_line_Path)
    layerName = os.path.splitext(os.path.split(Cable_line_Path)[1])[0]    
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbPoint)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn('IdLine', ogr.OFTInteger)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Xpyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Ypyl', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Altitude', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Hcable', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pression', ogr.OFTReal)
    layer.CreateField(new_field)
    new_field = ogr.FieldDefn('Pyl_pos', ogr.OFTInteger)
    layer.CreateField(new_field)
    idi = 0
    for ind,S in enumerate(Tab):
        nb=1
        for pyl in range(int(S[17])):  
            point = ogr.Geometry(ogr.wkbPoint)
            point.SetPoint(0, float(S[18+5*pyl]),float(S[19+5*pyl]))         
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(point)
            feature.SetFID(idi)
            feature.SetField('IdLine',ind+1)
            feature.SetField('Xpyl',float(S[18+5*pyl]))
            feature.SetField('Ypyl',float(S[19+5*pyl]))
            feature.SetField('Altitude',float(S[20+5*pyl]))
            feature.SetField('Hcable',float(S[21+5*pyl]))
            feature.SetField('Pression',float(S[22+5*pyl]))
            feature.SetField('Pyl_pos',int(nb)             )    
            layer.CreateFeature(feature)
            point.Destroy()
            feature.Destroy()
            idi+=1
            nb+=1
    target_ds.Destroy()


def create_coord_pixel_center_raster(values,nline,ncol,Csize,Dir_temp):
    Xcoord = np.zeros((ncol),dtype=np.float)
    Ycoord = np.zeros((nline),dtype=np.float)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    np.save(Dir_temp+'TableX.npy',Xcoord)
    np.save(Dir_temp+'TableY.npy',Ycoord)
    return Xcoord,Ycoord


def create_coord_pixel_center_raster2(values,nline,ncol,Csize):
    Xcoord = np.zeros((ncol),dtype=np.float)
    Ycoord = np.zeros((nline),dtype=np.float)
    y= values[3]+Csize*0.5
    for i in range(nline-1,-1,-1):
        Ycoord[i] = y
        y+= Csize
    x= values[2]+Csize*0.5
    for j in range(0,ncol,1):
        Xcoord[j]=x
        x+= Csize
    return Xcoord,Ycoord
    

def prepa_desserte_cable(Desserte_shapefile_name,MNT_file_name,Dir_temp,Pond_pente):
    ### Get info on the area
    _,values,_,Extent = raster_get_info(MNT_file_name)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    ### Get id of pixel of road and distance to public network
    Desserte_temp = shapefile_to_np_array(Desserte_shapefile_name,Extent,Csize,"CL_SVAC","CL_SVAC",'ASC')
    # Public network
    Res_pub = (Desserte_temp==3)*1
    # Forest road
    Route = (Desserte_temp==2)*1
    ID_RF = -9999*np.ones((nrows,ncols),dtype=np.int)
    ID_res_pub = -9999*np.ones((nrows,ncols),dtype=np.int)
    indice_forest_road = 0
    indice_public_road = 0
    pixels = np.argwhere(Desserte_temp>1)
    for pixel in pixels:
        if Res_pub[pixel[0],pixel[1]]==1:
            ID_res_pub[pixel[0],pixel[1]] = indice_public_road
            indice_public_road +=1
        elif Route[pixel[0],pixel[1]]==1:
            ID_RF[pixel[0],pixel[1]] = indice_forest_road
            indice_forest_road +=1
    np.save(Dir_temp+"ID_RF.npy",ID_RF)  
    np.save(Dir_temp+"ID_res_pub.npy",ID_res_pub)
    Dtransp_route, Lien_RF_respub = fc.calcul_distance_de_cout(ID_res_pub,Pond_pente,Route,Csize) 
    ### Get only forest roads
    Dir_temp2 = Dir_temp+"Temp/"
    try:os.mkdir(Dir_temp2)
    except:pass 
    Route_shp = Dir_temp2 + "Route.shp"
    select_in_shapefile(Desserte_shapefile_name,Route_shp,'WHERE CL_SVAC=2')
    ### Calculate azimuth and identify lines extremities
    Points_shp = Dir_temp2 + "Route_points.shp"    
    geoLocations,projection = linestring_to_point(Route_shp,Points_shp)
    # lines extremities
    Fin_ligne = np.int8(shapefile_to_np_array(Points_shp,Extent,Csize,'FIN_LIGNE','FIN_LIGNE','DESC'))
    # Azimuth 
    Az_route_shp = Dir_temp2 + "Az_Route.shp"
    points_to_lineshape(geoLocations,Az_route_shp,projection)
    Az_route = shapefile_to_np_array(Az_route_shp,Extent,Csize,'DIRECTION','DIRECTION','DESC')
    ID_routefor = np.unique(ID_RF)[1:]
    Link_RF_Res_pub = np.zeros((ID_routefor.shape[0],7),dtype=np.int)    
    for ind in ID_routefor:
        Temp = np.argwhere(ID_RF==ind)
        Link_RF_Res_pub[ind,0]=ind
        Link_RF_Res_pub[ind,1]=Temp[0,0]
        Link_RF_Res_pub[ind,2]=Temp[0,1]
        Link_RF_Res_pub[ind,3]=Dtransp_route[Temp[0,0],Temp[0,1]]
        Link_RF_Res_pub[ind,4]=Lien_RF_respub[Temp[0,0],Temp[0,1]]  
        Link_RF_Res_pub[ind,5]=Fin_ligne[Temp[0,0],Temp[0,1]]  
        Link_RF_Res_pub[ind,6]=Az_route[Temp[0,0],Temp[0,1]]
    shutil.rmtree(Dir_temp2)
    np.save(Dir_temp+"Link_RF_Res_pub",Link_RF_Res_pub)
    return Link_RF_Res_pub


# Create raster of obstacles from directory containing shapefiles 
def prepa_obstacle_cable(Obstacles_directory,file_MNT,Dir_temp):
    ### Creation d'un repertoire temporaire       
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize= values[4]
    MNT = read_raster(file_MNT)
    MNT[MNT==values[5]]=-9999
    Pente = fc.pente(np.float_(MNT),Csize,-9999)     
    if Obstacles_directory!="":
        liste_file = os.listdir(Obstacles_directory)
        liste_obs = [] 
        for files in liste_file:
            if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
        if len(liste_obs)>0:
            Obstacles_cable = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)
    else: Obstacles_cable = np.zeros_like(MNT,dtype=np.int8)    
    Obstacles_cable[MNT==-9999]=1
    values[5]=-9999
    np.save(Dir_temp+'Obstacles_cables.npy',np.int8(Obstacles_cable))
    gc.collect()  
    return Pente


def prepa_pond_pente_cable(MNT,Csize,Direct,head_text):
    Pente = fc.pente(MNT,Csize,-9999)
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    save_float_ascii(Direct+'/pond_pente.asc',head_text,Pond_pente)
    return Pond_pente
    

# Create a pair matrix
def create_pair_matrice(matrice):
    indices = np.indices(matrice.shape)
    pair_l = np.fmod(indices[0],2)
    pair_c = np.fmod(indices[1],2)
    pair = pair_c + pair_l
    pair = np.equal(pair,1)
    return pair


# Make buffer around a pixel
def buffer_emprise(Csize,ct_Lhor_max):
    temp = int(ct_Lhor_max/Csize)
    Ligne_perpendic = np.zeros((360*(1+2*temp),(1+2*temp)),dtype=np.uint8)
    Ind_mask = np.indices(((1+2*temp),(1+2*temp)),dtype=np.int16)
    center_inv = np.ones(((1+2*temp),(1+2*temp)),dtype=np.int16)
    center_inv[temp,temp]=0
    center = np.equal(center_inv,0)*1
    DX = Ind_mask[1]- temp
    DY = temp - Ind_mask[0]
    Dhor_ok = np.less_equal(Csize*np.sqrt(DX**2+DY**2),ct_Lhor_max)
    dmax1,dmin1,dmax2,dmin2 = direction_to_center(DX,DY,Csize,center_inv,center)
    z3_2 = np.less_equal((dmax2-dmin2),120)*1
    z3_1 = np.less_equal((dmax1-dmin1),120)*1
    Direction_list = range(0,360,1)
    for item in Direction_list:
        Dir_value = item+90
        if Dir_value > 359:Dir_value = item-90
        Mask1 = get_dir_area(Dir_value,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1)
        Dir_value1 = Dir_value+180
        if Dir_value1 > 359:Dir_value1 = Dir_value-180
        Mask2 = get_dir_area(Dir_value1,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1)
        Mask = np.greater((Mask1+Mask2),0)*Dhor_ok*1
        h = item*(1+2*temp)
        b = h+(1+2*temp)
        r = (1+2*temp)
        Ligne_perpendic[h:b,0:r]=Mask
    return Ligne_perpendic


def direction_to_center(DX,DY,Csize,center_inv,center):
    corner=[[0.5,0.5],[0.5,-0.5],[-0.5,0.5],[-0.5,0.5]]
    dmax1 = -400*np.ones_like(DX, dtype = np.int16)
    dmax2 = -400*np.ones_like(DX, dtype = np.int16)
    dmin1 = 400*np.ones_like(DX, dtype = np.int16)
    dmin2 = 400*np.ones_like(DX, dtype = np.int16)
    ind_center = np.nonzero(center==1)
    for item in corner:
        X = DX*Csize+item[1]*Csize
        Y = DY*Csize+item[0]*Csize
        D = np.sqrt(X**2+Y**2)
        Temp = np.equal(X,np.abs(X))*1
        Fact = Temp - np.less(Temp, 1)*1        
        D[ind_center] = Csize
        Angle = np.degrees(np.arccos(Y/D))
        Angle[ind_center]=0
        Temp = Angle*Fact
        del (X,Y,D,Fact,Angle)
        direction = 360*np.less(Temp, 0)+np.less(Temp, 0)*Temp+np.greater_equal(Temp, 0)*Temp
        dmax1=np.maximum(direction,dmax1)
        dmin1=np.minimum(direction,dmin1)
        dmax2=np.maximum(Temp,dmax2)
        dmin2=np.minimum(Temp,dmin2)
        del (Temp,direction)
    dmax1=np.float_(dmax1*center_inv+np.equal(center_inv,0)*9999)
    dmax2=np.float_(dmax2*center_inv+np.equal(center_inv,0)*9999)
    dmin1=np.float_(dmin1*center_inv+np.equal(center_inv,0)*9999)
    dmin2=np.float_(dmin2*center_inv+np.equal(center_inv,0)*9999)
    return dmax1,dmin1,dmax2,dmin2


#Get area corresponding to an azimuth
def get_dir_area(dir_value,dmax1,dmin1,dmax2,dmin2,center,z3_2,z3_1):
    if dir_value < 90:
        z1 = np.greater_equal(dir_value,dmin2)
        z2 = np.less_equal(dir_value,dmax2)
        zone = np.equal((z1*1+z2*1+z3_2*1),3)*1+center
    elif dir_value > 270:
        new_value = dir_value-360
        z1 = np.greater_equal(new_value,dmin2)
        z2 = np.less_equal(new_value,dmax2)
        zone = np.equal((z1*1+z2*1+z3_2*1),3)*1+center
    else:
        z1 = np.greater_equal(dir_value,dmin1)
        z2 = np.less_equal(dir_value,dmax1)
        zone = np.equal((z1*1+z2*1+z3_1*1),3)*1+center
    return zone


# Create useful buffers
def mask_buffers(test_coordY,test_coordX,ind_buffer_center,Buffer_cote,ncol,nline):
    if test_coordX < ind_buffer_center[1][0]: mask_l,buf_l = 0,ind_buffer_center[1][0] - test_coordX
    else: mask_l,buf_l = test_coordX - Buffer_cote,0
    if test_coordX + Buffer_cote + 1 > ncol: mask_r,buf_r = ncol,ncol-test_coordX+ind_buffer_center[1][0]
    else: mask_r,buf_r = test_coordX + Buffer_cote + 1,ind_buffer_center[1][0] + Buffer_cote + 1
    if test_coordY < ind_buffer_center[0][0]: mask_h,buf_h = 0,ind_buffer_center[0][0] - test_coordY
    else: mask_h,buf_h = test_coordY - Buffer_cote,0
    if test_coordY + Buffer_cote + 1 > nline: mask_b,buf_b = nline,nline - test_coordY + ind_buffer_center[0][0]
    else: mask_b,buf_b = test_coordY+Buffer_cote+1,ind_buffer_center[0][0]+Buffer_cote+1
    return mask_h,mask_b,mask_l,mask_r,buf_h,buf_b,buf_l,buf_r


def directions_a_tester(Dir_route,Dir_list,angle_sup,id_fin_ligne):
    # Pixel tout seul
    Dir_list_bis = list(Dir_list)
    # Pixel de route en fin de troncon
    if id_fin_ligne==1:
        D_plus_a = (Dir_route+angle_sup)%360
        D_moins_a = (Dir_route-angle_sup)%360
        if D_moins_a > D_plus_a:valeur_a_suppr = range(D_moins_a,360,1)+range(0,D_plus_a+1,1)
        else:valeur_a_suppr = range(D_moins_a,D_plus_a+1,1)
        for item in valeur_a_suppr:
            try:Dir_list_bis.remove(item)
            except:continue
    # Pixel de route au milieu d'un troncon
    else:
        D_plus_a = (Dir_route+angle_sup)%360
        D_moins_a = (Dir_route-angle_sup)%360
        if D_moins_a > D_plus_a:valeur_a_suppr = range(D_moins_a,360,1)+range(0,D_plus_a+1,1)
        else:valeur_a_suppr = range(D_moins_a,D_plus_a+1,1)
        D_plus_180_moins_a = (Dir_route+180-angle_sup)%360
        D_plus_180_plus_a = (Dir_route+180+angle_sup)%360
        if D_plus_180_plus_a < D_plus_180_moins_a: valeur_a_suppr = valeur_a_suppr + range(D_plus_180_moins_a,360,1)+range(0,D_plus_180_plus_a+1,1)
        else:valeur_a_suppr = valeur_a_suppr + range(D_plus_180_moins_a,D_plus_180_plus_a+1,1)
        for item in valeur_a_suppr:
            try:Dir_list_bis.remove(item)
            except:continue    
    return Dir_list_bis


def get_cable_configs(slope_Wliner_up,slope_Wliner_down,slope_grav,Skid_direction):
    #Get folder
    _,Rspace,_,_,_,_,_,_,_,_,_,_,_ = Sylvaccess_pluginDialog.get_spatial(1,0,1,0,0,0,0,0,0,0,0,0,0,0)
    dirs = [d for d in os.listdir(Rspace) if os.path.isdir(os.path.join(Rspace, d))]
    list_dir = []
    
    for dire in dirs:
        if dire[:5]=='Cable':
            list_dir.append(dire)

    optnum = len(list_dir)+1
    Rspace_c=Rspace+'Cable_'+str(optnum)        
    filename = Rspace_c+"/"
    Cable_type,_,_,_,_ = Sylvaccess_pluginDialog.get_type_cable(1,1,0,0,0,0)
    filename += str(Cable_type)
    Carriage_type,_,_,_,_ = Sylvaccess_pluginDialog.get_type_chariot(1,1,0,0,0,0)
    filename += "_"+str(Carriage_type)
    
    if Skid_direction ==0:
        filename += "_amont&aval"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1        
    
    elif Skid_direction ==1:
        filename += "_amont"
        slope_min_up = -atan(slope_Wliner_up*0.01)
        slope_max_up = 0.1
        slope_max_down = 0
        slope_min_down = 0
    
    else:
        filename += "_aval"
        slope_min_up = 0
        slope_max_up = 0
        slope_max_down = atan(slope_Wliner_down*0.01) 
        slope_min_down = -0.1 
    
    if Cable_type == "Câble long":
        if Skid_direction ==0:
            filename += "_amont&aval"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01) 
   
        elif Skid_direction ==1:
            filename += "_amont"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0
 
        else:
            filename += "_aval"
            slope_min_up = 0
            slope_max_up = 0
            slope_max_down = 1.4
            slope_min_down = atan(slope_grav*0.01)             
    else: 
        
        if Skid_direction ==0:
            filename+= "_amont_aval"
            slope_min_up = -1.4
            slope_max_up = 0.1
            slope_min_down = -0.1
            slope_max_down = 1.4
        
        elif Skid_direction ==1:
            filename += "_amont"
            slope_min_up = -1.4
            slope_max_up = -atan(slope_grav*0.01)
            slope_min_down = 0
            slope_max_down = 0 
        
        else:
            filename += "_aval"
            slope_min_up = 0
            slope_max_up = 0
            slope_min_down = -0.1
            slope_max_down = 1.4             
    
    filename+=".txt"
    
    return Rspace_c,filename,slope_min_up,slope_max_up,slope_min_down,slope_max_down


def gen_sel_table(w_list,lim_list,sup_max):
    col =     np.array([13       ,17     ,12         ,11    ,15    ,18+5*sup_max,16          ,14          ,18+5*sup_max+1])
    sens =    np.array([1        ,-1     ,0          ,1     ,1     ,1           ,1           ,-1          ,-1])
    #sens : 1:maximize,-1 minimize,0 NA
    report =  np.array([10000.   ,1.     ,1.         ,1.    ,1.    ,100.        ,10.         ,1.          ,1.])
    name = np.array(['Surface','NBsup','SensDeb'  ,'Long','Vtot','IPC'       ,'VAM'       ,'Dchar'     ,'Cout'])
    #quant =   np.array[[99,      , 100   , 100       ,99    ,99    ,99          ,99          ,100          ,100]]
    Tab_crit=np.zeros((9,4))
    Tab_crit[:,0]=w_list
    Tab_crit[:,1]=lim_list*report    
    Tab_crit[:,2]=col
    Tab_crit[:,3]=sens
    Name = ""  
    for i,crit in enumerate(Tab_crit):
        if crit[0]>0:
            Name+= '_'+str(name[i])+'('+str(round(crit[0],1))+')'
        
    return Tab_crit[Tab_crit[:,0]>0],Name


def create_best_table(Tab2,w_list,lim_list,sup_max): 
    Tab_crit,name=gen_sel_table(w_list,lim_list,sup_max)
    #Trie en fonction des critere avec un poids et de la limite
    for crit in Tab_crit:
        if crit[3]>0:
            tp = (Tab2[:,int(crit[2])]-crit[1])>=0
        elif crit[3]<0:
            tp = (Tab2[:,int(crit[2])]-crit[1])<=0
        else:
            continue
        Tab2 = Tab2[tp]
        
    #identifier si le sens de debardage a ete choisi dans les criteres   
    liste =range(Tab_crit.shape[0])
    idsensdeb=np.argwhere(Tab_crit[:,2]==12)
    if idsensdeb.shape[0]>0:
        idsensdeb=idsensdeb[0,0]
        liste = [x for x in liste if x != idsensdeb]
    else:
        idsensdeb=-1
    #Transform variable to stick in the range [0-1+]
    nbcol = len(liste)+2    
    Tab = np.zeros((Tab2.shape[0],nbcol))    
    col=1   
    for crit in Tab_crit[liste]:
        if crit[3] < 1 : #all values contribute to transformation
            Tab[:,col]= (1-1.0*Tab2[:,int(crit[2])]/np.max(Tab2[:,int(crit[2])]))*crit[0]
        else:
            Tab[:,col]= (1.0*Tab2[:,int(crit[2])]/np.percentile(Tab2[:,int(crit[2])],98))*crit[0]
        col+=1
    
    for i in range(Tab2.shape[0]):
        Tab[i,0]=i                      #first col is idline of Tab2
        Tab[i,col]=np.sum(Tab[i,1:col]) #last col is the total weight
    #classify
    ordre = np.zeros((Tab2.shape[0],),dtype=np.int)   
    if idsensdeb>0:
        #first the best direction
        tp = Tab2[:,12]==Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[tp][ind][0])
        ligne=i+1
        #then the othe direction
        tp = Tab2[:,12]==-Tab_crit[idsensdeb,1]        
        inds = np.lexsort((Tab[tp,0],-Tab[tp,col]))
        for i,ind in enumerate(inds):
            ordre[i+ligne]=int(Tab[tp][ind][0])
    else:
        inds = np.lexsort((Tab[:,0],-Tab[:,col]))
        for i,ind in enumerate(inds):
            ordre[i]=int(Tab[ind,0])
    return Tab2[ordre],name


def select_best_lines(w_list,lim_list,Tab2,nrows,ncols,Csize,Row_ext,Col_ext,D_ext,D_lat,Lhor_max,sup_max):        
    # Reorder Tab to fit with criteria
    Tabbis,name=create_best_table(Tab2,w_list,lim_list,sup_max)
    nb_line,nb_cols = Tabbis.shape
    Rast_couv=np.zeros((nrows,ncols),dtype=np.int8)
    vals = range(0,nb_line)
    ### Parameter to validate a line
    recouv = min(0.6*Lhor_max,Lhor_max-Csize) #distance from the axis of the line where crossing is not allowed
    # Select best lines
    vals2 = []
    for id_tab in vals:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        test_free,Rast_couv=fc.Check_line2(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,D_lat,Rast_couv,recouv,0)
        if test_free:
            vals2.append(id_tab)
    # Check taht line contribute to total impacted surface
    Tab_result = np.zeros((len(vals2),2),dtype=np.int)
    id_line = 0    
    for id_tab in vals2:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2)  
        prop = fc.get_prop(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,D_lat,Rast_couv)  
        Tab_result[id_line]=id_tab,prop*1000
        id_line+=1
    Tab_result=Tab_result[np.lexsort((Tab_result[:,0],Tab_result[:,1]))]  
    # Remove lines that does not contribute significantly to impacted surface
    nb_line = Tab_result.shape[0]
    Tab_result2 = np.zeros((nb_line,nb_cols-2),dtype=np.int)
    id_line = 0    
    for id_tab in Tab_result[:,0]:
        coordX,coordY = Tabbis[id_tab,-2],Tabbis[id_tab,-1]
        az,Lline=Tabbis[id_tab,1],sqrt((Tabbis[id_tab,2]-Tabbis[id_tab,6])**2+(Tabbis[id_tab,3]-Tabbis[id_tab,7])**2) 
        test_free,Rast_couv=fc.Check_line3(coordX,coordY,az,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Rast_couv,0.6)         
        if test_free:
            Tab_result2[id_line]=Tabbis[id_tab,0:-2]
            id_line+=1    
    Tab_result2=Tab_result2[Tab_result2[:,11]>0]
    return Rast_couv,Tab_result2,name


def return_crit_text(w_list,lim_list,):    
    name =["Surface de forêt impactée [ha] (maximiser)                  Minimum : ", 
              "Nombre de support intermédiaires (minimiser)                Maximum : ",
              "Privilégier le débardage vers ",
              "Longueur de ligne [m] (maximiser)                           Minimum : ", 
              "Volume total par ligne [m3] (maximiser)                     Minimum : ",
              "Indice de prélèvement câble [m3/ml] (maximiser)             Minimum : ",
              "Volume de l\'arbre moyen [m3] (maximiser)                   Minimum : ",
              "Longueur moyenne parcourue par le charriot [m] (minimiser)  Maximum : ",
              "Coût du débardage [€/m3] (minimiser)                        Maximum : "]                    
    units = ["ha","","","m","m3","m3/ml","m3","m","€/m3"]
    namelist=name
    pname = "(Poids: "              
    Tab = np.empty((np.sum(np.array(w_list)>0),2),dtype='|U73')
    j=-1
    for i,w in enumerate(w_list):
        if w!=0:
            j+=1
            if i!=2:
                if round(lim_list[i],0)==lim_list[i]:
                    lim=int(lim_list[i])
                else:
                    lim=round(lim_list[i],1)
                Tab[j]=namelist[i],str(lim)+" "+units[i]+" "+pname+str(w)+')' 
            else:
                if lim_list[i]==-1:
                    Tab[j]= name[i]+"l\'aval",pname+str(w)+')' 
                elif lim_list[i]==1:
                    Tab[j]= name[i]+"l\'amont",pname+str(w)+')'  
                else:
                    continue                    
    return Tab


def generate_info_ligne(Dir_result,w_list,lim_list,Tab,Rast_couv,Vol_ha,Vol_AM,Csize,prelevement,Lhor_max):
    filename = Dir_result+"Bilan_selection.txt"
    pix_area = Csize*Csize/10000.
    Proj = np.copy(Rast_couv)
    Proj[Rast_couv==2]=0
    Rast_couv[Rast_couv==2]=1
    Surface = round(np.sum(Rast_couv)*pix_area,1)
    Surface_proj = round(np.sum(Proj)*pix_area,1)
    if Surface_proj>0:
        testProj=1
    else:
        testProj=0
    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:,12]>0))
    try:
        nb_moy_pyl = round(np.sum(Tab[:,17])/nb_ligne,1)
        long_moy_ligne = int(np.sum(Tab[:,11])/nb_ligne)
    except:
        console_info("Aucune ligne n'a ete selectionnee")
    Vol_ha[np.isnan(Vol_ha)]=0
    Vol_AM[np.isnan(Vol_AM)]=0
    tp =   Vol_ha>0
    if np.sum(tp)>0:      
        vtot = np.sum(Rast_couv[tp]*Vol_ha[tp])*pix_area*prelevement
    else:
        vtot=0
    tp =   Vol_AM>0 
    if np.sum(tp)>0:
        vam = round(np.mean(Rast_couv[tp]*Vol_AM[tp]),1)
    else:
        vam=0
    if np.sum(Tab[:,11])!=0:
        ipc_moy = round(float(vtot)/np.sum(Tab[:,11]),2)
    else:
        console_info("Aucune ligne n'a ete selectionnee")
    vtot = int(vtot)
    lim_list[4]=lim_list[4]*prelevement
    
    Table = np.empty((19+np.sum(np.array(w_list)>0),2+testProj),dtype='|U73')
    
    Table[1,0]= "BILAN DE LA SELECTION DE LIGNE"
    Table[3,1]= "\t\t\t\t\t\t\tDepuis tous les départs\t\t"
    if testProj:
        Table[3,2]="Seulement depuis les projets"
    Table[4,0]= "Surface totale de forêt traitée [ha]:\t\t\t"
    Table[5,0]= "Nombre total de ligne:\t\t\t\t\t"
    Table[6,0]= "     + Dont ligne avec débardage vers l'amont:\t\t"
    Table[7,0]= "     + Dont ligne avec débardage vers l'aval:\t\t"
    Table[8,0]= "Nombre moyen de pylône intermédiaire par ligne:\t\t"
    Table[9,0]= "Longueur moyenne des lignes [m]:\t\t\t"
    Table[10,0]="Volume total prélevé (estimation) [m3]:\t\t\t"
    Table[11,0]="Indice de prélevement câble moyen (estimation) [m3/m]:\t"        
    Table[12,0]="Volume de l'arbre moyen (estimation) [m3]:\t\t"
    Table[15,0]="Critère(s) pris en compte dans la sélection des lignes:"
    Table[17,0]="Distance laterale de pechage des bois:                      "
    Table[18,0]="Taux de prelevement du volume sur pied:                     "
        
    Table[4,1]= str(Surface)
    Table[5,1]= str(nb_ligne)
    Table[6,1]= str(nb_ligne_amont)
    Table[7,1]= str(nb_ligne-nb_ligne_amont)
    Table[8,1]= str(nb_moy_pyl)
    Table[9,1]= str(long_moy_ligne)
    Table[10,1]=str(vtot)
    Table[11,1]=str(ipc_moy)
    Table[12,1]=str(vam)
    Table[17,1]=str(int(Lhor_max))+" m"
    Table[18,1]=str(int(prelevement*100))+" %"
    
    Tabcrit = return_crit_text(w_list,lim_list)
    
    for i,crit in enumerate(Tabcrit):
        Table[19+i,0]=crit[0]
        Table[19+i,1]=crit[1]
        
    
    if testProj:
        Tab= Tab[Tab[:,10]==1]
        Rast_couv = Proj
        nb_ligne = Tab.shape[0]
        nb_ligne_amont = int(np.sum(Tab[:,12]>0))
        try:
            nb_moy_pyl = round(np.sum(Tab[:,17])/nb_ligne,1)
            long_moy_ligne = int(np.sum(Tab[:,11])/nb_ligne)
        except:
            console_info("Aucune ligne n'a ete selectionnee")
        tp =   Vol_ha>0
        if np.sum(tp)>0:      
            vtot = np.sum(Rast_couv[tp]*Vol_ha[tp])*pix_area*prelevement
        else:
            vtot=0
        tp =   Vol_AM>0 
        if np.sum(tp)>0:
            vam = round(np.mean(Rast_couv[tp]*Vol_AM[tp]),1)
        else:
            vam=0
        if np.sum(Tab[:,11])!=0:
            ipc_moy = round(float(vtot)/np.sum(Tab[:,11]),2)
        else:
            console_info("Aucune ligne n'a ete selectionnee")
        vtot = int(vtot)
        
        Table[4,2]= "\t\t\t\t"+str(Surface_proj)
        Table[5,2]= "\t\t\t\t"+str(nb_ligne)
        Table[6,2]= "\t\t\t\t"+str(nb_ligne_amont)
        Table[7,2]= "\t\t\t\t"+str(nb_ligne-nb_ligne_amont)
        Table[8,2]= "\t\t\t\t"+str(nb_moy_pyl)
        Table[9,2]= "\t\t\t\t"+str(long_moy_ligne)
        Table[10,2]="\t\t\t\t"+str(vtot)
        Table[11,2]="\t\t\t\t"+str(ipc_moy)
        Table[12,2]="\t\t\t\t"+str(vam)
           
    np.savetxt(filename, Table,fmt='%s', delimiter='')


def generate_info_cable_simu(Dir_result,Tab,Rast_couv,Vol_ha,Csize,Forest,Pente,Pente_max_bucheron):
    filename = Dir_result+"Resume_resultat_sylvaccess_cable.txt"
    Pente_max = fc.focal_stat_max(np.float_(Pente),-9999,1)
    Pente_ok_buch = np.int8((Pente_max<=Pente_max_bucheron))
    del Pente_max
    gc.collect()    
    pix_area = Csize*Csize/10000.
    Rast_couv[Forest==0]=0
    Surface_exis = round(np.sum(Rast_couv==2)*pix_area,1)
    Surface_proj = round(np.sum(Rast_couv==1)*pix_area,1)
    Surface_foret = round(np.sum(Forest==1)*pix_area,1)    
    Surface_nonbuch = round(np.sum((Forest==1)*(Pente_ok_buch==0))*pix_area,1)
        
    Vol_ha[np.isnan(Vol_ha)]=0
    Vol_ha[Forest==0]=0
    tp =  Vol_ha>0
    if np.sum(tp)>0:   
        tp2 = (tp*(Rast_couv==2))>0
        vtot_exis = int(np.sum(Vol_ha[tp2])*pix_area+0.5)
        tp2 = (tp*(Rast_couv==1))>0
        vtot_proj = int(np.sum(Vol_ha[tp2])*pix_area+0.5)     
        tp2 = (tp*(Forest==1))>0
        vtot_forest = int(np.sum(Vol_ha[tp2])*pix_area+0.5)   
        tp2 = (tp*(Forest==1)*(Pente>Pente_max_bucheron))>0
        vtot_nonbuch = int(np.sum(Vol_ha[tp2])*pix_area+0.5)   
    else:
        vtot_exis = 0  
        vtot_proj = 0
        vtot_forest = 0
        vtot_nonbuch = 0
        
    nb_ligne = Tab.shape[0]
    nb_ligne_amont = int(np.sum(Tab[:,12]>0))
    nb_moy_pyl = round(np.sum(Tab[:,17])/nb_ligne,1)
    long_moy_ligne = int(np.sum(Tab[:,11])/nb_ligne)    
                
    Table = np.empty((17,5),dtype='|U39')
    Table[0] = np.array(["","Surface (ha)","Surface (%)","Volume sur pied (m3)","Volume (%)"])
    Table[1,0] = "Depuis les departs de cable existant"
    Table[2,0] = "Depuis les departs de cable en projet"
    Table[4,0] = "Total foret accessible"
    Table[5,0] = "Total foret inaccessible"
    Table[6,0] = "    dont non bucheronnable"
    Table[8,0] = "Superficie totale de la foret"
    Table[11,0] = "Nombre total de ligne"
    Table[12,0] = "    + Dont debardage vers l'amont"
    Table[13,0] = "    + Dont debardage vers l'aval"
    Table[15,0] = "Longueur moyenne des lignes (m)"
    Table[16,0] = "Nombre moyen de pylone intermediaire"
        
    #Create recap per distance class 
    if vtot_forest>0:
        Table[1,1:] = np.array([str(Surface_exis),str(int(Surface_exis/Surface_foret*100+0.5)),
                                str(vtot_exis),str(int(vtot_exis/vtot_forest*100+0.5))])
        Table[2,1:] = np.array([str(Surface_proj),str(int(Surface_proj/Surface_foret*100+0.5)),
                                str(vtot_proj),str(int(vtot_proj/vtot_forest*100+0.5))])
        
        Table[4,1:] = np.array([str(Surface_exis+Surface_proj),str(int((Surface_proj+Surface_exis)/Surface_foret*100+0.5)),
                                str(vtot_proj+vtot_exis),str(int((vtot_exis+vtot_proj)/vtot_forest*100+0.5))])
        Table[5,1:] = np.array([str(round(Surface_foret-(Surface_exis+Surface_proj),1)),str(int((Surface_foret-(Surface_proj+Surface_exis))/Surface_foret*100+0.5)),
                                str(vtot_forest-(vtot_proj+vtot_exis)),str(int((vtot_forest-(vtot_exis+vtot_proj))/vtot_forest*100+0.5))])
        Table[6,1:] = np.array([str(Surface_nonbuch),str(int(Surface_nonbuch/Surface_foret*100+0.5)),
                                str(vtot_nonbuch),str(int(vtot_nonbuch/vtot_forest*100+0.5))])
    else:
        Table[1,1:] = np.array([str(Surface_exis),str(int(Surface_exis/Surface_foret*100+0.5)),'0','0'])
        Table[2,1:] = np.array([str(Surface_proj),str(int(Surface_proj/Surface_foret*100+0.5)),'0','0'])
                            
        
        Table[4,1:] = np.array([str(Surface_exis+Surface_proj),str(int((Surface_proj+Surface_exis)/Surface_foret*100+0.5)),'0','0'])
        Table[5,1:] = np.array([str(round(Surface_foret-(Surface_exis+Surface_proj),1)),str(int((Surface_foret-(Surface_proj+Surface_exis))/Surface_foret*100+0.5)),'0','0'])
        Table[6,1:] = np.array([str(Surface_nonbuch),str(int(Surface_nonbuch/Surface_foret*100+0.5)),'0','0'])
    
    Table[8,1:] = np.array([str(Surface_foret),"",str(vtot_forest),""])
    
    Table[11,1] = str(nb_ligne)
    Table[12,1] = str(nb_ligne_amont)
    Table[13,1] = str(nb_ligne-nb_ligne_amont)
    Table[15,1] = str(long_moy_ligne)
    Table[16,1] = str(nb_moy_pyl)
    
    np.savetxt(filename, Table,fmt='%s', delimiter=';')


def calculate_azimut(x1,y1,x2,y2):
    DX = x2-x1
    DY = y2-y1
    Deuc = math.sqrt(DX**2+DY**2)
    if x2>x1:Fact=1
    else:Fact=-1
    Angle = math.degrees(math.acos(DY/Deuc))
    Angle *=Fact
    return Angle%360   


def create_rast_couv(Tab_result,Dir_result,source_src,Extent,Csize,Lhor_max):
    drv = ogr.GetDriverByName("ESRI Shapefile")    
    layer_name = "Extent"
    dst_ds = drv.CreateDataSource( Dir_result+layer_name+".shp" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('EXIST', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    layerDefinition = dst_layer.GetLayerDefn()  
    for idi,line in enumerate(Tab_result):
        Xstart,Ystart,Xend,Yend = line[2],line[3],line[6],line[7]
        az = calculate_azimut(Xstart,Ystart,Xend,Yend)
        conv = radians(90)
        ring = ogr.Geometry(ogr.wkbLinearRing)
        ring.AddPoint(Xstart+Lhor_max*cos(az-conv), Ystart+Lhor_max*sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*cos(az-conv), Yend+Lhor_max*sin(az-conv))
        ring.AddPoint(Xend+Lhor_max*cos(az+conv), Yend+Lhor_max*sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*cos(az+conv), Ystart+Lhor_max*sin(az+conv))
        ring.AddPoint(Xstart+Lhor_max*cos(az-conv), Ystart+Lhor_max*sin(az-conv))
        poly = ogr.Geometry(ogr.wkbPolygon)
        poly.AddGeometry(ring)
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(poly)
        feature.SetFID(idi)        
        feature.SetField('EXIST',int(line[10]))
        dst_layer.CreateFeature(feature)
        ring.Destroy()
        poly.Destroy()
        feature.Destroy()
    dst_ds.Destroy()
    Rast_couv = np.int8(shapefile_to_np_array(Dir_result+layer_name+".shp",Extent,Csize,"EXIST","EXIST",'ASC') )
    for extension in [".shp",".prj",".shx",".dbf"]:
        os.remove(Dir_result+layer_name+extension)
    return Rast_couv


def prepa_data_cable(Wspace,file_MNT,file_shp_Foret,file_shp_Cable_Dep,Dir_Obs_cable):
    console_info("Pre-traitement des entrees pour le modele cable\n")
    ### Make directory for temporary files
    Dir_temp = Wspace+"Temp/"
    try:os.mkdir(Dir_temp)
    except:pass     
    ###########################################################################
    ### __         __ __   __         __ __               __   __              
    ###|__|.-----.|__|  |_|__|.---.-.|  |__|.-----.---.-.|  |_|__|.-----.-----.
    ###|  ||     ||  |   _|  ||  _  ||  |  ||__ --|  _  ||   _|  ||  _  |     |
    ###|__||__|__||__|____|__||___._||__|__||_____|___._||____|__||_____|__|__|
                                                                        
    MNT,Extent,Csize,_ = load_float_raster(file_MNT,Dir_temp)
    np.save(Dir_temp+"MNT",MNT)
    
    #############################################################################################################
    ###        __                       ___ __ __             __                                __              
    ###.-----.|  |--.---.-.-----.-----.'  _|__|  |.-----.    |  |_.-----.    .----.---.-.-----.|  |_.-----.----.
    ###|__ --||     |  _  |  _  |  -__|   _|  |  ||  -__|    |   _|  _  |    |   _|  _  |__ --||   _|  -__|   _|
    ###|_____||__|__|___._|   __|_____|__| |__|__||_____|    |____|_____|    |__| |___._|_____||____|_____|__|  
    ###                   |__|                                                                                  
    Foret = shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET")
    np.save(Dir_temp+"Foret",np.int8(Foret))    
    del Foret
    console_info("    - Raster de foret termine")    
    ### Forest : shapefile to raster 
    Exposition = fc.exposition(MNT,Csize,-9999)
    np.save(Dir_temp+"Aspect",np.uint16(Exposition+0.5))
    Pente = prepa_obstacle_cable(Dir_Obs_cable,file_MNT,Dir_temp)
    np.save(Dir_temp+"Pente",Pente)    
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    np.save(Dir_temp+"Pond_pente",Pond_pente)
    del Pente,MNT  
    console_info("    - Obstacles pour le cable traites")

    #################################################################################################################################
    ###             __     __                    __               __                                                 __              
    ###.----.---.-.|  |--.|  |.-----.    .-----.|  |_.---.-.----.|  |_     .-----.----.-----.----.-----.-----.-----.|__|.-----.-----.
    ###|  __|  _  ||  _  ||  ||  -__|    |__ --||   _|  _  |   _||   _|    |  _  |   _|  _  |  __|  -__|__ --|__ --||  ||     |  _  |
    ###|____|___._||_____||__||_____|    |_____||____|___._|__|  |____|    |   __|__| |_____|____|_____|_____|_____||__||__|__|___  |
    ###                                                                    |__|                                               |_____|
    Cable_start = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"CABLE","CABLE",'ASC') 
    testExist = check_field(file_shp_Cable_Dep,"EXIST") 
    if testExist:    
        Existing = shapefile_to_np_array(file_shp_Cable_Dep,Extent,Csize,"EXIST","EXIST",'ASC') 
    else:
        Existing = np.ones_like(Cable_start,dtype=np.int8)*2

    pixels = np.argwhere(Cable_start>0)
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.int) 
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        Lien_RF[ID,4]=Cable_start[pixel[0],pixel[1]]
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=Existing[pixel[0],pixel[1]]
        ID +=1         
    # Link RF with res_pub and calculate transportation distance
#    Lien_RF=fc.Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for, Lien_RF,Csize) 
#    Lien_RF=Lien_RF[Lien_RF[:,4]>0]
    Lien_RF=Lien_RF[Lien_RF[:,2]>-1]
    np.save(Dir_temp+"Lien_RF_c",Lien_RF)    
    console_info("    - Departs de cables potentiels identifies")    

    ###################################################################################################################################################################################
    ###                                 __                                     __                      __                                      __                                      
    ###.----.----.-----.-----.----.    |  |.-----.-----.    .----.---.-.-----.|  |_.-----.----.    .--|  |.-----.    .----.-----.-----.----.--|  |.-----.-----.-----.-----.-----.-----.
    ###|  __|   _|  -__|  -__|   _|    |  ||  -__|__ --|    |   _|  _  |__ --||   _|  -__|   _|    |  _  ||  -__|    |  __|  _  |  _  |   _|  _  ||  _  |     |     |  -__|  -__|__ --|
    ###|____|__| |_____|_____|__|      |__||_____|_____|    |__| |___._|_____||____|_____|__|      |_____||_____|    |____|_____|_____|__| |_____||_____|__|__|__|__|_____|_____|_____|
                                                                                                                                                                                
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    TableX,TableY=create_coord_pixel_center_raster(values,nrows,ncols,Csize,Dir_temp)
    CoordRoute = np.zeros((Lien_RF.shape[0],2),dtype=np.float)
    for i,pixel in enumerate(Lien_RF):
        CoordRoute[i,0]=TableX[pixel[1]]
        CoordRoute[i,1]=TableY[pixel[0]] 
    np.save(Dir_temp+"CoordRoute.npy",CoordRoute)  
    console_info("    - Table des coordonnees creee")  
    ##############################################################################################################################################
    ###       __                         __   __                                __         __   
    ###.----.|  |.-----.-----.-----.    |  |_|  |--.-----.    .-----.----.----.|__|.-----.|  |_ 
    ###|  __||  ||  _  |__ --|  -__|    |   _|     |  -__|    |__ --|  __|   _||  ||  _  ||   _|
    ###|____||__||_____|_____|_____|    |____|__|__|_____|    |_____|____|__|  |__||   __||____|
    ###                                                                            |__|         
    console_info("\nPre-traitement des entrees pour le cable termine\n")
    clear_big_nparray()


def line_selection(Rspace_c,w_list,lim_list,new_calc,file_shp_Foret,file_Vol_ha,file_Vol_AM,Lhor_max,prelevement,Pente_max_bucheron):
    console_info("Selection des meilleures lignes en fonction des criteres de l'utilisateur.")
    ### Check if temporary files have been generated and have the same extent
    Rspace_sel = Rspace_c+"FilesForOptimisation/"
    try: 
        Tab = np.load(Rspace_sel+"Tab_all_lines.npy") 
    except:
        console_info("Veuillez d'abord faire tourner le modele cable.")
        return ""
    Lmax = np.max(Tab[:,11])    
    _,values,Extent=loadrasterinfo_from_file(Rspace_sel)
    Csize,nrows,ncols=values[4],int(values[1]),int(values[0]) 
    if not new_calc:
        f = open(Rspace_sel+"info_Lhormax.txt","r")
        Lhor_max=f.readlines(0)
        f.close()
        Lhor_max= float(Lhor_max[0])
    
    _,_,_,_,Row_ext,Col_ext,D_ext,D_lat,_=create_buffer2(Csize,Lmax,Lhor_max)        
    Lien_RF = np.load(Rspace_sel+"Lien_RF_c.npy")
    ############################################
    ### Recompute cable line stats if necessary
    ############################################
    if new_calc:
        console_info("    - Recalcule les caracteristiques des lignes avec les nouvelles couches...") 
        #Couche foret
        if file_shp_Foret != "":
            Forest = np.int8(shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET"))
        else:
            Forest=np.load(Rspace_sel+"Forest.npy")
        #Couche vol_ha
        if file_Vol_ha != "":
            Vol_ha = load_float_raster_simple(file_Vol_ha) 
            Vol_ha[Vol_ha<0]=0
            Vol_ha[np.isnan(Vol_ha)]=0
            test_vp = True
        else:
            test_vp = False            
            if file_Vol_AM != "":
                Vol_ha = np.zeros((Forest.shape),dtype=np.float)
            else:
                Vol_ha = np.zeros_like(Forest,dtype=np.int8)
        #Couche vol_am
        if file_Vol_AM != "":
            Vol_AM = load_float_raster_simple(file_Vol_AM) 
            Vol_AM[Vol_AM<0]=0
            Vol_AM[np.isnan(Vol_AM)]=0
            test_vam = True
        else:
            test_vam = False  
            if file_Vol_ha != "":
                Vol_AM = np.zeros((Forest.shape),dtype=np.float)   
            else:
                Vol_AM = np.zeros_like(Forest,dtype=np.int8)   
       
        if test_vp or test_vam:             
            Pente = np.load(Rspace_sel+"Pente.npy")
            Vol_AM[Pente>Pente_max_bucheron]=0
            Vol_ha[Pente>Pente_max_bucheron]=0
        nbline = Tab.shape[0]        
        Rast_couv = np.zeros_like(Forest,dtype=np.int8)
        for i in range(0,nbline):
            coordX=Lien_RF[Tab[i,0],1]
            coordY=Lien_RF[Tab[i,0],0]       
            az=Tab[i,1]
            Lline=sqrt((Tab[i,2]-Tab[i,6])**2+(Tab[i,3]-Tab[i,7])**2)                                                      
            if test_vp or test_vam:
                Distance_moyenne,Surface,Vtot,VAM,Rast_couv = fc.get_line_carac_vol(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv,Vol_ha,Vol_AM)
            else:
                Distance_moyenne,Surface,Rast_couv = fc.get_line_carac_simple(coordX,coordY,az,Csize,ncols,nrows,Lline,Row_ext,Col_ext,D_ext,Forest,Rast_couv)
            #Surface foret Dmoy chariot
            Tab[i,13],Tab[i,14]=Surface,Distance_moyenne
            #Vtot IPC
            if test_vp:
                Tab[i,15]=Vtot
            #VAM               
            if test_vam:
                Tab[i,16]=VAM*10
   
    
    ############################################
    ### Calc IPC according to prelevement
    ############################################
    
    Tab2 = np.zeros((Tab.shape[0],Tab.shape[1]+4),dtype=np.int)
    Tab2[:,0:-4]=Tab
    Tab2[:,-4]=np.int_(100.0*Tab[:,15]*prelevement/Tab[:,11])
    del Tab
    gc.collect()    
    Tab2[:,-1]= Lien_RF[Tab2[:,0],0]
    Tab2[:,-2]= Lien_RF[Tab2[:,0],1]     
    del Lien_RF
    gc.collect()
    sup_max=np.max(Tab2[:,17])    
    
    
    lim_list[4]=lim_list[4]/prelevement #in order to account for prelevement in line selection
    
    #Modify selection criteria in case of no volume or vam        
    if np.max(Tab2[:,15])==0:        
        if w_list[4]>0:
            console_info("Optimisation impossible sur le volume/ipc car aucune information disponible.")   
        w_list[4],lim_list[4]=0,0
        w_list[5],lim_list[5]=0,0
        
    if np.max(Tab2[:,16])==0:
        if w_list[6]>0:
            console_info("Optimisation impossible sur le volume de l'arbre moyen car aucune information disponible.")
        w_list[6],lim_list[6]=0,0
        
    Rast_couv,Tab_result,Tab_name=select_best_lines(w_list,lim_list,Tab2,
                                                                   nrows,ncols,Csize,
                                                                   Row_ext,Col_ext,D_ext,
                                                                   D_lat,Lhor_max,sup_max)
    del Tab2  
    gc.collect()
    #Get folder
    dirs = [d for d in os.listdir(Rspace_c) if os.path.isdir(os.path.join(Rspace_c, d))]
    list_dir = []
    for dire in dirs:
        if dire[:12]=='Optimisation':
            list_dir.append(dire)
    optnum = len(list_dir)+1
    Dir_result = Rspace_c+'Optimisation'+str(optnum) 
    ### Get best volume
    header = 'ID_pixel Azimuth_deg X_debut Y_debut Alt_debut Hcable_debut X_fin Y_fin Alt_fin Hcable_fin '
    header +='Etat_RouteFor Longueur_reelle Configuration '
    header +='Surface_foret Distance_moy_chariot Volume_total VAM NB_int_sup'
    for num in range(1,sup_max+1):
        header +=' '+'Xcoord_intsup'+str(num)+' Ycoord_intsup'+str(num)+' Alt_intsup'+str(num)
        header +=' '+'Hcable_intsup'+str(num)+' Pression_intsup'+str(num)
    header +='IPC cout'
    Dir_result +=Tab_name  
    header +='\n'
    try:os.mkdir(Dir_result)
    except:pass
    Dir_result+="/"
    filename = Dir_result+"Database_Optim_"+str(optnum)+".gzip" 
    shape_name = Dir_result+"CableLines_Optim_"+str(optnum)+".shp"
    rast_name = Dir_result+"CableArea_Optim_"+str(optnum)
    pyl_name = Dir_result+"Int_sup_Optim_"+str(optnum)+".shp"
    
    save_integer_ascii(filename,header,Tab_result)
    source_src=get_source_src(Rspace_sel+"info_proj.shp")  
    road_network_proj=get_proj_from_road_network(Rspace_sel+"info_proj.shp")
    Line_to_shapefile(Tab_result,shape_name,source_src,prelevement) 
    #New rast_couv to take into account project of cable start
    Rast_couv=create_rast_couv(Tab_result,Dir_result,source_src,Extent,Csize,Lhor_max)
    #Rast_couv[Rast_couv>0]=1
    if not new_calc:
        Forest=np.load(Rspace_sel+"Forest.npy")
        try:         
            Vol_ha=np.load(Rspace_sel+"Vol_ha.npy")
        except:
            Vol_ha=np.zeros_like(Forest)
        try:
            Vol_AM=np.load(Rspace_sel+"Vol_AM.npy")
        except:
            Vol_AM=np.zeros_like(Forest)    
    Rast_couv[Forest==0]=0
    ArrayToGtiff(Rast_couv,rast_name,Extent,nrows,ncols,road_network_proj,0,'UINT8')    
    Pylone_in_shapefile(Tab_result,pyl_name,source_src)
    ### Summary of the choice
    generate_info_ligne(Dir_result,w_list,lim_list,Tab_result,Rast_couv,Vol_ha,Vol_AM,Csize,prelevement,Lhor_max) 
    console_info("Selection des meilleures lignes de cable terminee.")
 

#####################################################################
#    _______. __  ___  __   _______   _______   _______ .______     #
#    /       ||  |/  / |  | |       \ |       \ |   ____||   _  \   #
#   |   (----`|  '  /  |  | |  .--.  ||  .--.  ||  |__   |  |_)  |  #
##   \   \    |    <   |  | |  |  |  ||  |  |  ||   __|  |      /   #
#.----)   |   |  .  \  |  | |  '--'  ||  '--'  ||  |____ |  |\  \--.#
#|_______/    |__|\__\ |__| |_______/ |_______/ |_______|| _| `.___|#
#####################################################################

# Fonctions qui gère les calculs liés au skidder

def Skidder():
    Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,_,Dir_Full_Obs_skidder,Dir_Partial_Obs_skidder,_,_,file_Vol_ha,_,_ = Sylvaccess_pluginDialog.get_spatial(1,1,1,1,1,1,0,1,1,0,0,1,0,0)
    _,_,_,_,Pente_max_bucheron = Sylvaccess_pluginDialog.get_general(1,0,0,0,0,1)
    Pente_max_skidder,Dtreuil_max_up,Dtreuil_max_down,Dmax_train_near_for,Pmax_amont,Pmax_aval,Option_Skidder,Skid_Debclass=Sylvaccess_pluginDialog.get_skidder(1,1,1,1,1,1,1,1,1)
    console_info("Debut du modele skidder")
    
    Hdebut = datetime.datetime.now()
    
    # Create a folder for process results
    Rspace_s = Rspace+"Skidder/"
    try:os.mkdir(Rspace_s)
    except:pass
    Dir_temp = Wspace+"Temp/"
    
    # Check if temporary files have been generated and have the same extent
    try:
        _,values,_,Extent = raster_get_info(file_MNT)
    except:
        return "Erreur: veuillez definir une projection pour le raster MNT"
    try: 
        _,v1=read_info(Dir_temp+'info_extent.txt')
        for i,item in enumerate(values):
            if v1[i]!=round(item,2):
                prep_data_skidder(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Full_Obs_skidder,Dir_Partial_Obs_skidder)
            if i+1>4:break
    except:
        prep_data_skidder(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Full_Obs_skidder,Dir_Partial_Obs_skidder)
    
    # Inputs
    try:
        Foret = np.int8(np.load(Dir_temp+"Foret.npy"))
        Piste = np.int8(np.load(Dir_temp+"Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp+"Route_for.npy"))    
        Res_pub = np.int8(np.load(Dir_temp+"Res_pub.npy"))    
        Lien_piste = np.load(Dir_temp+"Lien_piste.npy")
        Lien_RF = np.load(Dir_temp+"Lien_RF.npy")
        Pente = np.load(Dir_temp+"Pente.npy")
        Pond_pente = np.load(Dir_temp+"Pond_pente.npy")
        MNT = np.load(Dir_temp+"MNT.npy")
        Full_Obstacles_skidder = np.int8(np.load(Dir_temp+"Full_Obstacles_skidder.npy"))
        Partial_Obstacles_skidder = np.int8(np.load(Dir_temp+"Partial_Obstacles_skidder.npy"))
    except: 
        prep_data_skidder(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Full_Obs_skidder,Dir_Partial_Obs_skidder)
        Foret = np.int8(np.load(Dir_temp+"Foret.npy"))
        Piste = np.int8(np.load(Dir_temp+"Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp+"Route_for.npy"))   
        Res_pub = np.int8(np.load(Dir_temp+"Res_pub.npy")) 
        Lien_piste = np.load(Dir_temp+"Lien_piste.npy")
        Lien_RF = np.load(Dir_temp+"Lien_RF.npy")
        Pente = np.load(Dir_temp+"Pente.npy")
        Pond_pente = np.load(Dir_temp+"Pond_pente.npy")
        MNT = np.load(Dir_temp+"MNT.npy")
        Full_Obstacles_skidder = np.int8(np.load(Dir_temp+"Full_Obstacles_skidder.npy"))
        Partial_Obstacles_skidder = np.int8(np.load(Dir_temp+"Partial_Obstacles_skidder.npy"))
    
    nrows,ncols = MNT.shape[0],MNT.shape[1]
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    
    # Calculation of useful variable for the model process
    Pmax_up = float(abs(Pmax_amont))/100.0
    Pmax_down = -float(abs(Pmax_aval))/100.0
    deniv_up = math.sqrt(float(Dtreuil_max_up*Dtreuil_max_up)/float(1+1.0/float(Pmax_up*Pmax_up)))
    deniv_down = -math.sqrt(float(Dtreuil_max_down*Dtreuil_max_down)/float(1+1.0/float(Pmax_down*Pmax_down)))
    coeff = float(Dtreuil_max_up-Dtreuil_max_down)/float(deniv_up-deniv_down)
    orig = Dtreuil_max_up - coeff*deniv_up
    Csize = values[4]
    Pond_pente[Full_Obstacles_skidder==1] = 1000
    Pente_max = fc.focal_stat_max(np.float_(Pente),-9999,1)
    Pente_ok_buch = np.int8((Pente_max<=Pente_max_bucheron))
    del Pente_max
    gc.collect()
    Pente_ok_skid = np.int8((Pente <= Pente_max_skidder)*(Pente > -9999))
    MNT_OK = np.int8((MNT!=values[5]))
    Zone_OK = np.int8(MNT_OK*(Foret==1)*(Full_Obstacles_skidder==0)*Pente_ok_buch==1)
    
    Surf_foret = np.sum((Foret==1)*MNT_OK)*Csize*Csize*0.0001
    Surf_foret_non_access = int(np.sum((Pente_ok_buch==0)*(Foret==1)*MNT_OK*Csize*Csize*0.0001)+0.5)
    
    Row_line,Col_line,D_line,Nbpix_line=create_buffer_skidder(Csize,Dtreuil_max_up,Dtreuil_max_down)
            
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)]=0
        Temp = ((Vol_ha>0)*(Foret==1)*MNT_OK)>0
        Vtot = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        Temp = ((Vol_ha>0)*(Pente_ok_buch==0)*(Foret==1)*MNT_OK)>0
        Vtot_non_buch = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        del Vol_ha,Temp
    else:
        Vtot=0    
        Vtot_non_buch =0
       
    ArrayToGtiff(Pente_ok_buch,Rspace_s+'Pente_ok_buch',Extent,nrows,ncols,road_network_proj,0,'UINT8')   
    console_info("    - Initialisation terminee")  
    del Pente,Pente_ok_buch
    gc.collect()     
    
    ###############################################################################################################################################    
    ### Calculation of skidding distance inside the forest stands
    ###############################################################################################################################################                  
    # Identify the forest area that may be run through by the skidder
    zone_rast = Pente_ok_skid*(Foret==1)
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    from_rast = np.int8(((Piste==1)+(Route_for==1))>0)
    from_rast[Res_pub==1]=0
    Zone_for,_ = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Zone_for[Zone_for>=0]=1
    Zone_for[from_rast==1]=1
    Zone_for=np.int8(Zone_for)
    
    # Create a buffer of Dmax_out_forest around these area taking into account slope and obstacles
    from_rast = fc.focal_stat_nb(np.float_(Zone_for==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.copy(Pente_ok_skid)
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0 
    Zone_for2,Out_alloc = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Dmax_train_near_for) 
    Pente_ok_skidder = np.int8(Zone_for2>0)
    Pente_ok_skidder[Zone_for==1]=1 
    
    del Zone_for,Zone_for2,Out_alloc
    gc.collect()
    
    #Stick all forest with pente_ok_skidder to the area
    from_rast = fc.focal_stat_nb(np.float_(Pente_ok_skidder==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.int8(1*Pente_ok_skid*(Foret==1))
    zone_rast[Full_Obstacles_skidder==1]=0
    zone_rast[Partial_Obstacles_skidder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for,Out_alloc = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Pente_ok_skidder[Zone_for>=0]=1    
           
    del Zone_for,from_rast,zone_rast,Out_alloc,Pente_ok_skid
    gc.collect()     
    
    
    D_foret_piste,L_Piste,D_piste=fc.Dfwd_flat_forest_tracks(Lien_piste, Pond_pente, Pente_ok_skidder*(Route_for==0)*1, Csize)    
    D_foret_RF,L_RF = fc.Dfwd_flat_forest_road(Lien_RF,Pond_pente,Pente_ok_skidder*1*(Piste==0),Csize)
    
    del Pente_ok_skidder,Pond_pente
    gc.collect()          
    console_info("    - Distance de trainage depuis la desserte forestieres calculee")  
    
    ###############################################################################################################################################
    ### Calculation of winching distance from forest roads
    ###############################################################################################################################################
    
    DebRF_D,DebRF_LRF=fc.skid_debusq_RF(Lien_RF,MNT,Row_line,Col_line,D_line,Nbpix_line,coeff,orig,Pmax_up,Pmax_down,
                                        Dtreuil_max_up,Dtreuil_max_down,nrows,ncols,Zone_OK*(Route_for==0)*1*(Piste==0))
    

    console_info("    - Distance de debusquage depuis les routes forestieres calculee")  

    
    ###############################################################################################################################################
    #### Calculation of winching distance from forest tracks
    ###############################################################################################################################################                 
    
    Debp_D,Debp_LP,Debp_Dtrpiste=fc.skid_debusq_Piste(Lien_piste,MNT,Row_line,Col_line,D_line,Nbpix_line,coeff,orig,Pmax_up,Pmax_down,
                                                      Dtreuil_max_up,Dtreuil_max_down,nrows,ncols,Zone_OK*(Piste==0)*1*(Route_for==0))


    console_info("    - Distance de debusquage depuis les pistes forestieres calculee")  
    gc.collect()
    
    ###############################################################################################################################################    
    ### Concatenation of the resultats (1)
    ###############################################################################################################################################
    DTrain_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    DTrain_foret = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Ddebusquage = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_RF = np.ones((nrows,ncols),dtype=np.int32)*-9999
             
    if Option_Skidder==1:
        # Option 1 : Skidder is forced to stay as much possible as possible on forest road networks
        # Get value of winching distance from forest roads
        Temp = (DebRF_D>=0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = DebRF_D[Temp]
        Lien_foret_RF[Temp] = DebRF_LRF[Temp]
            
        # Get value of winching distance from forest tracks  
        Temp = Debp_D>=0
        Temp[(Debp_D+0.1*Debp_Dtrpiste)>Ddebusquage]=0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp]
        Lien_foret_RF[Temp] = -9999
        Temp = ((Ddebusquage<0)*(Debp_D>=0))>0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp]
        Lien_foret_RF[Temp] = -9999
        
        # Get value of skidding distance within forest stand from forest tracks
        Temp = (Ddebusquage<0)*(D_foret_piste>=0)
        DTrain_piste[Temp] = D_piste[Temp]
        DTrain_foret[Temp] = D_foret_piste[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_piste[Temp] = L_Piste[Temp]
        
        # Get value of skidding distance within forest stand from forest roads
        Temp = (Ddebusquage==0)*(D_foret_RF>=0)
        Temp[(DTrain_foret+0.1*DTrain_piste)<D_foret_RF]=0
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]  
        Temp = (Ddebusquage<0)*(D_foret_RF>=0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]   
         
        
    else:
        # Option 2 : Limit the skidding : skidder goes as close as possible to the timber before using winching possibility

        # Get value of skidding distance within forest stand from forest tracks
        Temp = (D_foret_piste>=0)
        DTrain_piste[Temp] = D_piste[Temp]
        DTrain_foret[Temp] = D_foret_piste[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_piste[Temp] = L_Piste[Temp]   
        
        # Get value of skidding distance within forest stand from forest roads       
        Temp = (Ddebusquage==0)*(D_foret_RF>=0)
        Temp[(DTrain_foret+0.1*DTrain_piste)<D_foret_RF]=0
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]     
        Temp = (D_foret_RF>=0)*(DTrain_foret<0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = D_foret_RF[Temp]
        Ddebusquage[Temp] = 0
        Lien_foret_RF[Temp] = L_RF[Temp]                  
        
        # Get value of winching distance from forest roads
        Temp = (DebRF_D>=0)*(DTrain_foret<0)
        DTrain_piste[Temp] = 0
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = DebRF_D[Temp]
        Lien_foret_RF[Temp] = DebRF_LRF[Temp]   
        
        # Get value of winching distance from forest tracks
        Temp = Debp_D>=0
        Temp[(Debp_D+0.1*Debp_Dtrpiste)>Ddebusquage]=0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp] 
        Lien_foret_RF[Temp] = -9999        
        Temp = ((DTrain_foret<0)*(Debp_D>=0))>0
        DTrain_piste[Temp] = Debp_Dtrpiste[Temp]
        DTrain_foret[Temp] = 0
        Ddebusquage[Temp] = Debp_D[Temp]
        Lien_foret_piste[Temp] = Debp_LP[Temp] 
        Lien_foret_RF[Temp] = -9999
        
        
    # Calculation of the forest area accessible with a skidder
    zone_tracteur = np.zeros_like(MNT,dtype=np.int8)
    zone_tracteur[((D_foret_piste>=0)*(Foret==1))>0]=1
    zone_tracteur[((D_foret_RF>=0)*(Foret==1))>0]=1    
    
    ArrayToGtiff(zone_tracteur,Rspace_s+'Zone_parcourable_par_skidder',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    console_info("    - Concatenation 1 terminee")  
    del DebRF_D,DebRF_LRF,Debp_D,Debp_LP,Debp_Dtrpiste
    gc.collect() 
    
    ################################################################################################################################################  
    ### Calculation of winching distance from contours
    ################################################################################################################################################
    contour = fc.focal_stat_nb(np.float_((zone_tracteur==1)*1),0,1)
    contour = ((contour<9)*(contour>0)>0)*1
    contour[Full_Obstacles_skidder==1]=0
    contour[Partial_Obstacles_skidder==1]=0
    contour[Res_pub==1]=0   
    contour[MNT_OK==0]=0  
    
    pixels=np.argwhere(contour>0)
    del zone_tracteur,Full_Obstacles_skidder,Partial_Obstacles_skidder,Res_pub,MNT_OK,contour
    gc.collect()
    
    #line=ID_contour, Y, X,L_RF,L_piste,Dtrain,Dpis
    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int)    
    ID = 1
    for pixel in pixels:
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        testpiste=0
        if D_foret_RF[pixel[0],pixel[1]]<0:
            testpiste=1
        elif D_piste[pixel[0],pixel[1]]>=0:
            if (D_foret_piste[pixel[0],pixel[1]]+0.1*D_piste[pixel[0],pixel[1]])<D_foret_RF[pixel[0],pixel[1]]:
                testpiste=1
        if testpiste:
            Lien_contour[ID,2],Lien_contour[ID,3]=-9999,L_Piste[pixel[0],pixel[1]]
            Lien_contour[ID,4],Lien_contour[ID,5]=D_foret_piste[pixel[0],pixel[1]],D_piste[pixel[0],pixel[1]]
        else:
            Lien_contour[ID,2],Lien_contour[ID,3]=L_RF[pixel[0],pixel[1]],-9999
            Lien_contour[ID,4],Lien_contour[ID,5]=D_foret_RF[pixel[0],pixel[1]],0     
        ID += 1
    del D_foret_piste,L_Piste,D_piste,D_foret_RF,L_RF
    gc.collect()    
    
    # Get the contour of traversable area
    Ddebus,L_RF,L_Piste,Dpis,Dfor=fc.skid_debusq_contour(Lien_contour,MNT,Row_line,Col_line,D_line,Nbpix_line,coeff,orig,Pmax_up,Pmax_down,
                                                         Dtreuil_max_up,Dtreuil_max_down,nrows,ncols,Zone_OK*1*(Ddebusquage<=0))
                                                      
    del Lien_contour,pixels,MNT
    gc.collect()
    console_info("    - Distance de debusquage depuis le contour de la zone parcourable calculee")      
    
    ################################################################################################################################################  
    ### Concatenation (2)
    ################################################################################################################################################    
    
    Temp = (Ddebusquage<0)*(Ddebus>=0)
    DTrain_piste[Temp] = Dpis[Temp]
    DTrain_foret[Temp] = Dfor[Temp]
    Ddebusquage[Temp] = Ddebus[Temp]
    Lien_foret_RF[Temp] = L_RF[Temp]
    Lien_foret_piste[Temp] = L_Piste[Temp]
        
    del Ddebus,L_RF,L_Piste,Dpis,Dfor
    gc.collect()
    
    Temp = (Foret==0)
    DTrain_piste[Temp] = -9999
    DTrain_foret[Temp] = -9999
    Ddebusquage[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    
    del Temp
    gc.collect()
    
    # Fill Lien foret respub and Lien foret RF
    Lien_foret_Res_pub,Lien_foret_RF,Keep=fc.fill_Link(Lien_foret_piste,Lien_piste,Lien_RF, Lien_foret_RF, nrows,ncols)
    
    Temp = (Keep<1)*((Piste==1)+(Route_for==1))>0
    DTrain_piste[Temp] = -9999
    DTrain_foret[Temp] = -9999
    Ddebusquage[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_Res_pub[Temp] = -9999
        
    del Temp,Keep
    gc.collect()
    
    # Calculation of the total skidding distance
    Dtotal = np.ones((nrows,ncols),dtype=np.int32)*-9999
    zone_accessible = np.zeros((nrows,ncols),dtype=np.int8)
    Temp = (Ddebusquage>=0)
    Dtotal[Temp]= DTrain_piste[Temp] + DTrain_foret[Temp] + Ddebusquage[Temp]
    zone_accessible[Temp] = 1    
   
    del Temp
    gc.collect()
    console_info("    - Concatenation des resultats terminee. Sauvegarde en cours...")             
        
    
    ### Saving all rasters
    ##################################################################################################################################################
    ### Create a summary table of accessible area    
    make_summary_surface_vol(Skid_Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,Dtotal,Vtot,Vtot_non_buch,Rspace_s,"Skidder")
     
    ### Save output rasters
    ArrayToGtiff(zone_accessible,Rspace_s+'Foret_accessible',Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    ArrayToGtiff(Foret-zone_accessible,Rspace_s+'Foret_inaccessible',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    ArrayToGtiff(DTrain_piste,Rspace_s+'Distance_trainage_piste',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(DTrain_foret,Rspace_s+'Distance_trainage_foret',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Ddebusquage,Rspace_s+'Distance_debusquage',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Dtotal,Rspace_s+'Distance_totale_foret_route_forestiere',Extent,nrows,ncols,road_network_proj,-9999,'INT32')        
    ArrayToGtiff(Lien_foret_piste,Rspace_s+'Lien_foret_piste',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_RF,Rspace_s+'Lien_foret_route_forestiere',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_Res_pub,Rspace_s+'Lien_foret_Reseau_public',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    layer_name = 'Skidder_recap_accessibilite'
    source_src=get_source_src(file_shp_Desserte)  
    create_access_shapefile(Dtotal,Rspace_s,zone_accessible,Foret,Skid_Debclass.split(";"),road_network_proj,source_src,Csize, Dir_temp,Extent,nrows,ncols,layer_name)
      
    del zone_accessible,DTrain_piste,DTrain_foret,Ddebusquage,Dtotal
    del Lien_foret_piste,Lien_foret_RF,Lien_foret_Res_pub
    
    str_duree,str_fin,str_debut=heures(Hdebut)
    
    ### Genere le fichier avec le resume des parametres de simulation
    file_name = str(Rspace_s)+"Parametres_simulation.txt"
    resume_texte = "Sylvaccess : CARTOGRAPHIE AUTOMATIQUE DES ZONES ACCESSIBLES PAR TRACTEUR FORESTIER\n\n\n"
    resume_texte = resume_texte+"Version du programme : 3.5.1 de 12/2021\n\n"
    resume_texte = resume_texte+"Resolution           : "+str(Csize)+" m\n\n"
    resume_texte = resume_texte+"Date et heure de lancement du script:             "+str_debut+"\n"
    resume_texte = resume_texte+"Date et heure a la fin de l'execution du script:  "+str_fin+"\n"
    resume_texte = resume_texte+"Temps total d'execution du script:                "+str_duree+"\n\n"
    resume_texte = resume_texte+"PARAMETRES UTILISES POUR LA MODELISATION:\n\n"
    resume_texte = resume_texte+"   - Distance maximale de debusquage en amont de la desserte :       "+str(Dtreuil_max_up)+" m\n"
    resume_texte = resume_texte+"   - Distance maximale de debusquage en aval de la desserte  :       "+str(Dtreuil_max_down)+" m\n"
    resume_texte = resume_texte+"   - Pente au-dela de laquelle le debusquage amont = distance max :  "+str(Pmax_amont)+" %\n"
    resume_texte = resume_texte+"   - Pente au-dela de laquelle le debusquage aval  = distance max :  "+str(Pmax_aval)+" %\n\n"
    resume_texte = resume_texte+"   - Distance maximale parcourable hors foret et hors desserte :     "+str(Dmax_train_near_for)+" m\n"
    resume_texte = resume_texte+"   - Pente maximale pour parcourir le terrain en skidder :           "+str(Pente_max_skidder)+" %\n"
    resume_texte = resume_texte+"   - Pente maximale pour l'abattage manuel des arbres :              "+str(Pente_max_bucheron)+" %\n\n"
    resume_texte = resume_texte+"   - Option de simulation :\n"    
    if Option_Skidder==1:
        resume_texte = resume_texte+"      * Limiter l'impact sur les sols : forcer le skidder a proceder autant que possible\n"    
        resume_texte = resume_texte+"        depuis le reseau de desserte forestiere\n" 
    else:
        resume_texte = resume_texte+"      * Limiter le debusquage : forcer le skidder a se rapprocher autant que possible\n"    
        resume_texte = resume_texte+"        des grumes de bois\n" 
    if Dir_Full_Obs_skidder!='':
        resume_texte = resume_texte+"      * Prise en compte de zones totalement interdites a l'exploitation par skidder\n"  
    if Dir_Partial_Obs_skidder!='':
        resume_texte = resume_texte+"      * Prise en compte de zones ou le trainage des bois est interdit\n"  
        
    if os.path.exists(Rspace_s+'Pistes_non_connectees.tif'):
        resume_texte = resume_texte+"\n\n"
        resume_texte = resume_texte+"      !!! Attention !!! Certaines pistes forestières ne sont pas connectée.\n"  
        resume_texte = resume_texte+"      Elles ont été exclues de l'analyse.\n"  
    if os.path.exists(Rspace_s+'Routes_forestieres_non_connectees.tif'):
        resume_texte = resume_texte+"\n\n      !!! Attention !!! Certaines routes forestières ne sont pas connectée.\n"  
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    
        
        
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    console_info("Modele skidder termine")
    clear_big_nparray()
    gc.collect()
    

def create_new_road_network(file_shp_Desserte,Wspace):
    Dir_temp = Wspace+"Temp/"    
    try:os.mkdir(Dir_temp)
    except:pass 
    File_fin = Dir_temp+"Existing_roads.shp"    
    source_ds = ogr.Open(file_shp_Desserte)
    source_layer = source_ds.GetLayer()
    source_src = source_layer.GetSpatialRef()
    driver = ogr.GetDriverByName('ESRI Shapefile')
    target_ds = driver.CreateDataSource(File_fin)
    layerName = os.path.splitext(os.path.split(File_fin)[1])[0]
    layer = target_ds.CreateLayer(layerName, source_src, ogr.wkbLineString)
    layerDefinition = layer.GetLayerDefn()  
    new_field = ogr.FieldDefn("CL_SVAC", ogr.OFTInteger)
    layer.CreateField(new_field)
    for feat in source_layer:
        geometry = feat.GetGeometryRef()
        label = feat.GetField('EXIST')
        if label == 2:
            feature = ogr.Feature(layerDefinition)
            feature.SetGeometry(geometry)
            feature.SetField("CL_SVAC",feat.GetField("CL_SVAC"))
            layer.CreateFeature(feature)
            feature.Destroy()
    source_ds.Destroy()
    target_ds.Destroy()
    return File_fin


def make_summary_surface_vol(Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,Dtotal,Vtot,Vtot_non_buch,Rspace_s,modele_name):
    Skid_list = Debclass.split(";")
    nbclass = len(Skid_list)
            
    Table = np.empty((nbclass+7,9),dtype='|U39')
    Table[0] = np.array(["Distance totale de debardage",
                         "Surface (ha)","Surface par classe (%)","Surface cumulee (ha)","Surface cumulee (%)",
                         "Volume (m3)","Volume par classe (%)","Volume cumule (m3)","Volume cumule (%)"])    
    Table[nbclass+2:nbclass+7,0]=["Total foret accessible","Total foret inaccessible",
                                  "    dont non bucheronnable","",
                                  "Superficie totale de la foret"]
    file_name = str(Rspace_s)+"Resume_resultats_Sylvaccess_"+modele_name+".txt"  
        
    #SURFACE
    Surf_Cum = 0 
    for i in range(1,nbclass):
        dmin,dmax = int(Skid_list[i-1]),int(Skid_list[i])
        class_text = str(Skid_list[i-1])+" - "+str(Skid_list[i])+" m"
        Temp = np.sum((Dtotal>=dmin)*(Dtotal<dmax)*Csize*Csize*0.0001)
        Table[i,0:5] = np.array([class_text,str(round(Temp,1)),
                                str(round(Temp/Surf_foret*100,1)),
                                str(round((Temp+Surf_Cum),1)),
                                str(round((Temp+Surf_Cum)/Surf_foret*100,1))])
        Surf_Cum += Temp
    #add infinite distance class 
    dmin = int(Skid_list[nbclass-1])
    Temp = np.sum((Dtotal>=dmin)*Csize*Csize*0.0001)
    Table[nbclass,0:5] = np.array(["> "+str(dmin)+" m",str(round(Temp,1)),
                                   str(round(Temp/Surf_foret*100,1)),
                                   str(round((Temp+Surf_Cum),1)),
                                   str(round((Temp+Surf_Cum)/Surf_foret*100,1))])
    Surf_Cum += Temp  
         
    Table[-5,1] = str(round(Surf_Cum,1))+" ha"
    Table[-5,2] = str(round(Surf_Cum/Surf_foret*100,1))+" %"
    Table[-4,1] = str(round(Surf_foret-Surf_Cum,1))+" ha"
    Table[-4,2] = str(round((Surf_foret-Surf_Cum)/Surf_foret*100,1))+" %"
    Table[-3,1] = str(round(Surf_foret_non_access,1))+" ha"
    Table[-3,2] = str(round(Surf_foret_non_access/Surf_foret*100,1))+" %"        
    Table[-1,1] = str(round(Surf_foret,1))+" ha"
        
    #VOLUME            
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)]=0
                
        #Create recap per distance class 
        Vol_Cum = 0
        for i in range(1,nbclass):
            dmin,dmax = int(Skid_list[i-1]),int(Skid_list[i])            
            Temp = ((Dtotal>=dmin)*(Dtotal<dmax)*(Vol_ha>=0))>0
            if np.sum(Temp>0):
                Vclass = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
            else:
                Vclass = 0
            Table[i,5:9] = np.array([str(int(Vclass+0.5)),str(round(Vclass/Vtot*100,1)),
                                    str(int(Vclass+Vol_Cum+0.5)),
                                    str(round(100*(Vclass+Vol_Cum)/Vtot,1))])
            Vol_Cum +=Vclass
        #add infinite distance class 
        dmin = int(Skid_list[nbclass-1])
        Temp = ((Dtotal>=dmin)*(Vol_ha>=0))>0
        if np.sum(Temp>0):
            Vclass = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        else:
            Vclass = 0
        Table[nbclass,5:9] = np.array([str(int(Vclass+0.5)),str(round(Vclass/Vtot*100,1)),
                                    str(int(Vclass+Vol_Cum+0.5)),
                                    str(round(100*(Vclass+Vol_Cum)/Vtot,1))])
          
        Vol_Cum +=Vclass        
        Table[-5,5] = str(int(Vol_Cum+0.5))+" m3"
        Table[-5,6] = str(round(100*Vol_Cum/Vtot,1))+" %"
        Table[-4,5] = str(int(Vtot-Vol_Cum+0.5))+" m3"
        Table[-4,6] = str(round(100*(Vtot-Vol_Cum)/Vtot,1))+" %"
        Table[-3,5] = str(int(Vtot_non_buch+0.5))+" m3"
        Table[-3,6] = str(round(100*(Vtot_non_buch)/Vtot,1))+" %"  
        Table[-1,5] = str(int(Vtot+0.5))+" m3"
      
        np.savetxt(file_name, Table,fmt='%s', delimiter=';')
        
    else:
        np.savetxt(file_name, Table[:,0:5],fmt='%s', delimiter=';')


def make_dif_files(Rspace,idmod):#idmod 0 : Skidder, 1 : Porteur
    Modele = ["Skidder","Porteur"]
    Rspace_s = Rspace+Modele[idmod]+"/"
    filename = "Resume_resultats_Sylvaccess_"+Modele[idmod]+".txt"
    rastname = "Distance_totale_foret_route_forestiere.tif"
    foldExist = Rspace_s+"1_Existant/"
    foldProj = Rspace_s+"2_Projet/"
    txtname = Rspace_s+"Comparaison_avant_apres_projet.txt"
    shpname = "Surface_impactee"

        
        
    #Shapefile des differences
    _,values,_,Extent = raster_get_info(foldExist+rastname)
    Csize = values[4]
    DExist =  load_float_raster_simple(foldExist+rastname)
    DProj =  load_float_raster_simple(foldProj+rastname)
    nrows,ncols = DProj.shape
    Diff2 = DExist-DProj
    Diff2[DExist==-9999]=0
    Diff2[DProj==-9999]=0
    Diff = np.zeros_like(DExist,dtype=np.int8)
    Diff[((DExist==-9999)*(DProj>=0))>0] = 1 #Nouvel accessible
    Diff[((Diff2>0)*(Diff2<500))>0] = 2 
    Diff[((Diff2>500)*(Diff2<1000))>0] = 3
    Diff[((Diff2>1000)*(Diff2<1500))>0] = 4
    Diff[Diff2>1500] = 5
    Surf_impact = round(np.sum(Diff>0)*Csize*Csize/10000,1)
    road_network_proj=get_proj_from_road_network(foldExist+Modele[idmod]+"_recap_accessibilite.shp")
    source_src=get_source_src(foldExist+Modele[idmod]+"_recap_accessibilite.shp") 

       
    ArrayToGtiff(Diff,Rspace_s+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    del DExist,DProj,Diff2,Diff
    gc.collect()
    
    label = ["","0_Nouvellement accessible","4_Distance raccourcie de 1 a 500m",
               "3_Distance raccourcie de 500 a 999m", "2_Distance raccourcie de 1000 a 1499m",
               "1_Distance raccourcie d'au moins 1500m"]

    
    ds = gdal.Open(Rspace_s+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("ESRI Shapefile")
    dst_ds = drv.CreateDataSource( Rspace_s+shpname+".shp")
    dst_layer = dst_ds.CreateLayer(shpname, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', ogr.OFTInteger)
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds = None
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
            feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()    
    
    os.remove(Rspace_s+"Recap.tif")
    
    
    #Tableau des differences   
    TabExist = np.loadtxt(foldExist+filename,dtype='|U39',delimiter=";")
    TabProj = np.loadtxt(foldProj+filename,dtype='|U39',delimiter=";")
    if TabExist.shape[1]<6:        
        colrecap=[1,2]       
    else:        
        colrecap=[1,2,5,6] 
    Table = np.empty((TabExist.shape[0]-3,TabExist.shape[1]),dtype='|U39')    
    Table[0:-3,0]=TabExist[0:-6,0]
    for i in range(1,Table.shape[1]):
        Table[0,i]=str("Diff. ")+TabExist[0,i]
    
    for i in range(1,TabExist.shape[0]-6):
        for j in range(1,Table.shape[1]):
            Table[i,j]=round(float(TabProj[i,j])-float(TabExist[i,j]),1)
    
    Table[-2,0]="Total foret accessible supplementaire"
    Table[-1,0]="Surface de foret impactee"
            
    for i in colrecap:
        Table[-2,i]=round(np.sum(np.float32(Table[1:-3,i])),1)
        
    Table[-1,1:3]=Surf_impact,round(Surf_impact/float(TabExist[-1,1][:-3])*100,1)   
    np.savetxt(txtname, Table,fmt='%s', delimiter=';') 


def prepa_obstacle_skidder(Obstacles_directory,Extent,Csize,ncols,nrows,Rast_desserte_ok):
    liste_file = os.listdir(Obstacles_directory)
    liste_obs = []
    for files in liste_file:
        if files[-4:len(files)]=='.shp':liste_obs.append(Obstacles_directory+files)
    if len(liste_obs)>0:
        Obstacles_skidder = shapefile_obs_to_np_array(liste_obs,Extent,Csize)
        Temp = (Rast_desserte_ok>0)
        Obstacles_skidder[Temp] = 0
    else: Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    return Obstacles_skidder


def create_buffer_skidder(Csize,Dtreuil_max_up,Dtreuil_max_down):
    Lcote = max(Dtreuil_max_up,Dtreuil_max_down)+1.5*Csize
    xmin,xmax,ymin,ymax = -Lcote,Lcote,-Lcote,Lcote
    Buffer_cote = int((max(Dtreuil_max_up,Dtreuil_max_down)/Csize+1.5))
    Dir_list = range(0,360,1)
    Row_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    Col_line = np.zeros((len(Dir_list),3*Buffer_cote),dtype=np.int16)
    D_line = np.ones((len(Dir_list),3*Buffer_cote),dtype=np.float)*-1
    Nbpix_line = np.zeros((len(Dir_list),),dtype=np.int16)    
    for az in Dir_list:
        #Fill line info
        _,_,mask_arr=from_az_to_arr(xmin,xmax,ymin,ymax,Csize,Lcote,az)        
        inds=np.argwhere(mask_arr==1)-Buffer_cote
        mat = np.zeros((inds.shape[0],3))
        mat[:,:2] = inds
        mat[:,2] = Csize*np.sqrt(mat[:,0]**2+mat[:,1]**2)
        ind = np.lexsort((mat[:,1],mat[:,2]))
        mat = mat[ind]
        nb_pix=mat.shape[0]
        Row_line[az,0:nb_pix]=mat[:,0]
        Col_line[az,0:nb_pix]=mat[:,1]
        D_line[az,0:nb_pix]=mat[:,2]
        Nbpix_line[az] = nb_pix        
    NbpixmaxL = np.max(Nbpix_line)
    return Row_line[:,0:NbpixmaxL],Col_line[:,0:NbpixmaxL],D_line[:,0:NbpixmaxL],Nbpix_line


def create_access_shapefile(Dtotal,Rspace_s,Foret,HarvClass_list,road_network_proj,source_src,Dir_temp,Extent,nrows,ncols,layer_name):
    Recap = np.copy(Foret)
    #0: no Forest
    #1: inaccessible forest
    #2: Non_buch
    #Then harvesting classes
    label = ["Zone hors foret","Inaccessible","Zone non exploitable (pente trop elevee)"]
    nbclass = len(HarvClass_list)    
    for i in range(1,nbclass):
        dmin,dmax = int(HarvClass_list[i-1]),int(HarvClass_list[i])
        label.append("Accessible - Classe de debardage "+str(i)+' : '+str(HarvClass_list[i-1])+" - "+str(HarvClass_list[i])+" m")
        Temp = ((Dtotal>=dmin)*(Dtotal<dmax)*(Foret==1))>0
        Recap[Temp]=2+i
    #add infinite distance class 
    dmin = int(HarvClass_list[nbclass-1])
    label.append("Accessible - Classe de debardage "+str(nbclass)+" : > "+str(dmin)+" m")
    Temp = ((Dtotal>=dmin)*(Foret==1))>0
    Recap[Temp]=2+nbclass
    #Get area too slopy for harvesting
    Temp = load_float_raster_simple(Rspace_s+'Pente_ok_buch.tif')
    Temp = ((Temp!=1)*(Foret==1))>0
    Recap[Temp]=2
    #Save as Gtiff
    ArrayToGtiff(Recap,Dir_temp+"Recap",Extent,nrows,ncols,road_network_proj,0,raster_type='UINT8')
    #Convert to shape
    type_mapping = { gdal.GDT_Byte: ogr.OFTInteger,
                 gdal.GDT_UInt16: ogr.OFTInteger,   
                 gdal.GDT_Int16: ogr.OFTInteger,    
                 gdal.GDT_UInt32: ogr.OFTInteger,
                 gdal.GDT_Int32: ogr.OFTInteger,
                 gdal.GDT_Float32: ogr.OFTReal,
                 gdal.GDT_Float64: ogr.OFTReal,
                 gdal.GDT_CInt16: ogr.OFTInteger,
                 gdal.GDT_CInt32: ogr.OFTInteger,
                 gdal.GDT_CFloat32: ogr.OFTReal,
                 gdal.GDT_CFloat64: ogr.OFTReal}

    ds = gdal.Open(Dir_temp+"Recap.tif")
    srcband = ds.GetRasterBand(1)
    drv = ogr.GetDriverByName("ESRI Shapefile")
    dst_ds = drv.CreateDataSource( Rspace_s+layer_name+".shp" )
    dst_layer = dst_ds.CreateLayer(layer_name, source_src , ogr.wkbPolygon)
    raster_field = ogr.FieldDefn('Class', type_mapping[srcband.DataType])
    dst_layer.CreateField(raster_field)
    gdal.Polygonize( srcband, None, dst_layer, 0, [], callback=None)
    ds.FlushCache()
    raster_field = ogr.FieldDefn('Cat', ogr.OFTString)
    dst_layer.CreateField(raster_field)
    for feat in dst_layer:
        i=feat.GetField("Class")  
        if i==0:
            dst_layer.DeleteFeature(feat.GetFID())
        feat.SetField('Cat',label[i])
        dst_layer.SetFeature(feat)
    # Cleanup
    dst_ds.Destroy()


def create_arrays_from_roads(source_shapefile,Extent,Csize):
    #Recupere les dimensions du raster ascii
    xmin,xmax,ymin,ymax = Extent[0],Extent[1],Extent[2],Extent[3]
    nrows,ncols = int((ymax-ymin)/float(Csize)+0.5),int((xmax-xmin)/float(Csize)+0.5)    
    #Recupere le driver
    #Get information from source shapefile
    source_ds = ogr.Open(source_shapefile)
    source_layer = source_ds.GetLayer()    
    source_type = source_layer.GetGeomType()
    source_srs = source_layer.GetSpatialRef()
    ###################################################
    ###                                                      __     __ __       
    ###.----.-----.-----.-----.---.-.--.--.    .-----.--.--.|  |--.|  |__|.----.
    ###|   _|  -__|__ --|  -__|  _  |  |  |    |  _  |  |  ||  _  ||  |  ||  __|
    ###|__| |_____|_____|_____|___._|_____|    |   __|_____||_____||__|__||____|
    ###                                        |__|                                 
    expression = '"CL_SVAC" = 3'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Res_pub = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###                   __               ___                          __   __                   
    ###.----.-----.--.--.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|   _|  _  |  |  ||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|__| |_____|_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
                                                                                           
    expression = '"CL_SVAC" = 2'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Route_For = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    ###################################################
    ###        __         __               ___                          __   __                   
    ###.-----.|__|.-----.|  |_.-----.    .'  _|.-----.----.-----.-----.|  |_|__|.-----.----.-----.
    ###|  _  ||  ||__ --||   _|  -__|    |   _||  _  |   _|  -__|__ --||   _|  ||  -__|   _|  -__|
    ###|   __||__||_____||____|_____|    |__|  |_____|__| |_____|_____||____|__||_____|__| |_____|
    ###|__|                                                                                       
    expression = '"CL_SVAC" = 1'
    source_layer_bis = source_ds.ExecuteSQL('SELECT * FROM '+str(source_layer.GetName())+' WHERE '+expression) 
    # Initialize the new memory raster
    driver = ogr.GetDriverByName('Memory')
    target_ds = driver.CreateDataSource("test")
    layerName = "test"
    layer = target_ds.CreateLayer(layerName, source_srs, source_type)
    layerDefinition = layer.GetLayerDefn()
    new_field = ogr.FieldDefn('Route', ogr.OFTInteger)
    layer.CreateField(new_field)
    ind=0
    for feat in source_layer_bis:
        geometry = feat.GetGeometryRef()
        feature = ogr.Feature(layerDefinition)
        feature.SetGeometry(geometry)
        feature.SetFID(ind)
        feature.SetField('Route',1)
        # Save feature
        layer.CreateFeature(feature)
        # Cleanup
        feature.Destroy()
        ind +=1
    # Cleanup
    maskvalue = 1    
    xres=float(Csize)
    yres=float(Csize)
    geotransform=(xmin,xres,0,ymax,0, -yres)    
    target_ds2 = gdal.GetDriverByName('MEM').Create('', int(ncols), int(nrows), 1, gdal.GDT_Int32)
    target_ds2.SetGeoTransform(geotransform)
    if source_srs:
        # Make the target raster have the same projection as the source
        target_ds2.SetProjection(source_srs.ExportToWkt())
    else:
        # Source has no projection (needs GDAL >= 1.7.0 to work)
        target_ds2.SetProjection('LOCAL_CS["arbitrary"]')
    # Rasterize
    err = gdal.RasterizeLayer(target_ds2, [maskvalue], layer,options=["ATTRIBUTE=Route","ALL_TOUCHED=TRUE"])
    if err != 0:
        raise Exception("error rasterizing layer: %s" % err)
    else:
        target_ds2.FlushCache()
        Piste = np.int8(target_ds2.GetRasterBand(1).ReadAsArray())
    target_ds.Destroy()
    target_ds2.FlushCache()
    source_ds.Destroy()    
    return Res_pub,Route_For,Piste


def prep_data_skidder(Wspace, Rspace, file_MNT, file_shp_Foret, file_shp_Desserte, Dir_Full_Obs_skidder, Dir_Partial_Obs_skidder):
    console_info("Preparation des entrees pour le modele skidder")
    ### Make directory for temporary files
    Dir_temp = Wspace+"Temp/"
    try:os.mkdir(Dir_temp)
    except:pass 
    Rspace_s = Rspace+"Skidder/"
    try:os.mkdir(Rspace_s)
    except:pass
    ##############################################################################################################################################
    ### Initialization
    ##############################################################################################################################################
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    ##############################################################################################################################################
    ### Forest : shapefile to raster
    ##############################################################################################################################################
    Foret = shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET")
    np.save(Dir_temp+"Foret",np.int8(Foret))    
    del Foret
    gc.collect()
    console_info("    - Raster de foret cree")
        
    ##############################################################################################################################################
    ### Calculation of a slope raster and a cost raster of slope
    ##############################################################################################################################################
    # Slope raster
    MNT,Extent,Csize,_ = load_float_raster(file_MNT,Dir_temp)
    np.save(Dir_temp+"MNT",np.float32(MNT))
    Pente = fc.pente(MNT,Csize,-9999)
    np.save(Dir_temp+"Pente",np.float32(Pente))    
    # Cost raster of slope
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    np.save(Dir_temp+"Pond_pente",np.float32(Pond_pente))
    # Report a success message   
    del Pente,MNT
    gc.collect()
    console_info("    - Raster de pente cree")  
    ##############################################################################################################################################
    ### Road network processing
    ##############################################################################################################################################
    Res_pub,Route_for,Piste= create_arrays_from_roads(file_shp_Desserte,Extent,Csize)
    np.save(Dir_temp+"Res_pub",Res_pub)  
    ##############################################################################################################################################
    ### Forest road network processing
    ##############################################################################################################################################
    pixels = np.argwhere(Res_pub==1) 
    # Give an identifiant to each public network pixel    
    ID = 1    
    Tab_res_pub = np.zeros((pixels.shape[0]+1,2),dtype=np.int32) 
    for pixel in pixels:
        Tab_res_pub[ID,0],Tab_res_pub[ID,1]=pixel[0],pixel[1]
        ID +=1         
    np.save(Dir_temp+"Tab_res_pub",Tab_res_pub)
    pixels = np.argwhere(Route_for==1)
    #num_ligne = id_RF, Y, X, Dtransp,Lien_Respub
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.float32)     
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=100001
        ID +=1 
    # Link RF with res_pub and calculate transportation distance
    Lien_RF=fc.Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for,Res_pub, Lien_RF,Csize) 
    Lien_RF[:,2]=np.int_(Lien_RF[:,2]+0.5)
    Lien_RF=Lien_RF.astype('int')
    Temp = (Lien_RF[:,3]>0)*(Lien_RF[:,2]==0)
    Lien_RF=Lien_RF[Temp==0]    
    np.save(Dir_temp+"Lien_RF",Lien_RF)
    # Check if all Forest road are linked to public network    
    if np.max(Lien_RF[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_RF[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_RF[ind,0],Lien_RF[ind,1]]=1        
        ArrayToGtiff(RF_bad,Rspace_s+'Routes_forestieres_non_connectees',Extent,nrows,ncols,road_network_proj,0,'UINT8')
        console_info("    - Certaines routes forestieres ne sont pas connectees au reseau public. Pour voir ou elles se trouvent, ouvrir le raster "+Rspace_s+"Routes_forestieres_non_connectees.tif")
    else:
        console_info("    - Routes forestieres traitees") 
            
    ##############################################################################################################################################
    ### Forest tracks network processing
    ##############################################################################################################################################
    # Tracks
    pixels = np.argwhere(Piste==1)
    #num_ligne = id_piste, Y, X, Dpiste,Dtransp,Lien_RF, Lien_Respub,
    Lien_piste = np.zeros((pixels.shape[0]+1,7),dtype=np.float32)    
    ID = 1
    for pixel in pixels:
        Lien_piste[ID,0],Lien_piste[ID,1]=pixel[0],pixel[1]
        Lien_piste[ID,4]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_piste[ID,2]=-9999
        else:
            Lien_piste[ID,2]=100001
        ID +=1
    Lien_piste=fc.Link_tracks_res_pub(Tab_res_pub,Lien_RF,Pond_pente,Piste,Route_for,Res_pub,Lien_piste,Csize)
    Lien_piste[:,2]=np.int_(Lien_piste[:,2]+0.5)
    Lien_piste=Lien_piste.astype('int')
    Temp = (Lien_piste[:,5]>0)*(Lien_piste[:,2]==0)
    Lien_piste=Lien_piste[Temp==0]    
    ind = np.lexsort((Lien_piste[:,1],Lien_piste[:,2]))
    Lien_piste=Lien_piste[ind]
    np.save(Dir_temp+"Lien_piste",Lien_piste) 
    if np.max(Lien_piste[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_piste[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_piste[ind,0],Lien_piste[ind,1]]=1   
            Piste[Lien_piste[ind,0],Lien_piste[ind,1]]=0
        ArrayToGtiff(RF_bad,Rspace_s+'Pistes_non_connectees',Extent,nrows,ncols,road_network_proj,0,'UINT8')
        console_info("    - Certaines pistes forestieres ne sont pas connectees a des routes ou au reseau public.")
        console_info("      Pour voir ou elles se trouvent ouvrir le raster "+Rspace_s+"Pistes_non_connectees.tif")
        console_info("      Ces lineaires sont exclus de l'analyse.")
    else:
        console_info("    - Pistes forestieres traitees")  
    Route_for[Res_pub==1]=0
    Piste[Res_pub==1]=0
    np.save(Dir_temp+"Route_for",Route_for) 
    np.save(Dir_temp+"Piste",np.int8(Piste))
    del Tab_res_pub,Lien_RF,Lien_piste,Res_pub  
    gc.collect()     
    ##############################################################################################################################################
    ### Create a raster of total obstacle for skidder
    ##############################################################################################################################################
    if Dir_Full_Obs_skidder!="":
        Full_Obstacles_skidder = prepa_obstacle_skidder(Dir_Full_Obs_skidder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))
    else:
        Full_Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Full_Obstacles_skidder",np.int8(Full_Obstacles_skidder))  
    console_info("    - Raster d'obstacles complet cree")
    ##############################################################################################################################################
    ### Create a raster of partial obstacle for skidder
    ##############################################################################################################################################
    if Dir_Partial_Obs_skidder!="":
        Partial_Obstacles_skidder = prepa_obstacle_skidder(Dir_Partial_Obs_skidder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))        
    else:
        Partial_Obstacles_skidder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Partial_Obstacles_skidder",np.int8(Partial_Obstacles_skidder))  
    console_info("    - Raster d'obstacles partiels cree")
    console_info("Pre-traitement des donnees d'entree termine")
    ##############################################################################################################################################
    ### Close the script
    ##############################################################################################################################################
    clear_big_nparray()
    gc.collect()


###########################################################################
#.______     ______   .______  .___________. _______  __    __  .______   #
#|   _  \   /  __  \  |   _  \ |           ||   ____||  |  |  | |   _  \  #
#|  |_)  | |  |  |  | |  |_)  |`---|  |----`|  |__   |  |  |  | |  |_)  | #
#|   ___/  |  |  |  | |      /     |  |     |   __|  |  |  |  | |      /  #
#|  |      |  `--'  | |  |\  \-.   |  |     |  |____ |  `--'  | |  |\  \-.#
#| _|       \______/  | _| `.__|   |__|     |_______| \______/  | _| `.__|#
# #########################################################################                                                                               

  
def prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder):
    console_info("Preparation des entrees pour le modele porteur")
    ### Make directory for temporary files
    Dir_temp = Wspace+"Temp/"
    try:os.mkdir(Dir_temp)
    except:pass 
    Rspace_f = Rspace+"Porteur/"
    try:os.mkdir(Rspace_f)
    except:pass
    ##############################################################################################################################################
    ### Initialization
    ##############################################################################################################################################
    _,values,_,Extent = raster_get_info(file_MNT)
    Csize,ncols,nrows = values[4],int(values[0]),int(values[1])  
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    ##############################################################################################################################################
    ### Forest : shapefile to raster
    ##############################################################################################################################################
    Foret = shapefile_to_np_array(file_shp_Foret,Extent,Csize,"FORET")
    np.save(Dir_temp+"Foret",np.int8(Foret))    
    del Foret
    console_info("    - Raster de foret cree")
    ##############################################################################################################################################
    ### Calculation of a slope raster and a cost raster of slope
    ##############################################################################################################################################
    # Slope raster
    MNT,Extent,Csize,_ = load_float_raster(file_MNT,Dir_temp)
    np.save(Dir_temp+"MNT",np.float32(MNT))      
    Pente = fc.pente(MNT,Csize,-9999)
    np.save(Dir_temp+"Pente",np.float32(Pente))    
    Exposition = np.int16(fc.exposition(MNT,Csize,-9999)+0.5)
    Exposition[Pente==-9999] = -9999
    np.save(Dir_temp+"Aspect",Exposition) 
    # Cost raster of slope
    Pond_pente = np.sqrt((Pente*0.01*Csize)**2+Csize**2)/float(Csize)
    Pond_pente[Pente==-9999] = 10000
    np.save(Dir_temp+"Pond_pente",np.float32(Pond_pente))
    # Report a success message   
    del Pente,MNT,Exposition
    console_info("    - Rasters de pente et d'exposition crees")  
    ##############################################################################################################################################
    ### Road network processing
    ##############################################################################################################################################
    Res_pub,Route_for,Piste= create_arrays_from_roads(file_shp_Desserte,Extent,Csize)
    np.save(Dir_temp+"Res_pub",Res_pub)  
    ##############################################################################################################################################
    ### Forest road network processing
    ##############################################################################################################################################
    pixels = np.argwhere(Res_pub==1) 
    # Give an identifiant to each public network pixel    
    ID = 1    
    Tab_res_pub = np.zeros((pixels.shape[0]+1,2),dtype=np.int32) 
    for pixel in pixels:
        Tab_res_pub[ID,0],Tab_res_pub[ID,1]=pixel[0],pixel[1]
        ID +=1         
    np.save(Dir_temp+"Tab_res_pub",Tab_res_pub)
    pixels = np.argwhere(Route_for==1)
    #num_ligne = id_RF, Y, X, Dtransp,Lien_Respub
    Lien_RF = np.zeros((pixels.shape[0]+1,5),dtype=np.float32)     
    ID = 1
    for pixel in pixels:
        Lien_RF[ID,0],Lien_RF[ID,1]=pixel[0],pixel[1]
        Lien_RF[ID,3]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_RF[ID,2]=-9999
        else:
            Lien_RF[ID,2]=100001
        ID +=1 
    # Link RF with res_pub and calculate transportation distance
    Lien_RF=fc.Link_RF_res_pub(Tab_res_pub,Pond_pente,Route_for,Res_pub, Lien_RF,Csize) 
    Lien_RF[:,2]=np.int_(Lien_RF[:,2]+0.5)
    Lien_RF=Lien_RF.astype('int')
    Temp = (Lien_RF[:,3]>0)*(Lien_RF[:,2]==0)
    Lien_RF=Lien_RF[Temp==0]    
    np.save(Dir_temp+"Lien_RF",Lien_RF)
    # Check if all Forest road are linked to public network    
    if np.max(Lien_RF[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_RF[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_RF[ind,0],Lien_RF[ind,1]]=1        
        ArrayToGtiff(RF_bad,Rspace_f+'Routes_forestieres_non_connectees',Extent,nrows,ncols,road_network_proj,0,'UINT8')
        console_info("    - Certaines routes forestieres ne sont pas connectees au reseau public. Pour voir ou elles se trouvent, ouvrir le raster "+Rspace_f+"Routes_forestieres_non_connectees.tif")
    else:
        console_info("    - Routes forestieres traitees") 
             
    ##############################################################################################################################################
    ### Forest tracks network processing
    ##############################################################################################################################################
    pixels = np.argwhere(Piste==1)
    #num_ligne = id_piste, Y, X, Dpiste,Dtransp,Lien_RF, Lien_Respub,
    Lien_piste = np.zeros((pixels.shape[0]+1,7),dtype=np.float32)    
    ID = 1
    for pixel in pixels:
        Lien_piste[ID,0],Lien_piste[ID,1]=pixel[0],pixel[1]
        Lien_piste[ID,4]=-9999
        if Pond_pente[pixel[0],pixel[1]]==10000:
            Lien_piste[ID,2]=-9999
        else:
            Lien_piste[ID,2]=100001
        ID +=1
    Lien_piste=fc.Link_tracks_res_pub(Tab_res_pub,Lien_RF,Pond_pente,Piste,Route_for,Res_pub,Lien_piste,Csize)
    Lien_piste[:,2]=np.int_(Lien_piste[:,2]+0.5)
    Lien_piste=Lien_piste.astype('int')
    Temp = (Lien_piste[:,5]>0)*(Lien_piste[:,2]==0)
    Lien_piste=Lien_piste[Temp==0]    
    ind = np.lexsort((Lien_piste[:,1],Lien_piste[:,2]))
    Lien_piste=Lien_piste[ind]
    np.save(Dir_temp+"Lien_piste",Lien_piste) 
    if np.max(Lien_piste[:,2])==100001:
        RF_bad = np.zeros((nrows,ncols),dtype=np.int8)
        pixels = np.argwhere(Lien_piste[:,2]==100001)
        for pixel in pixels:
            ind = pixel[0]            
            RF_bad[Lien_piste[ind,0],Lien_piste[ind,1]]=1   
            Piste[Lien_piste[ind,0],Lien_piste[ind,1]]=0
        ArrayToGtiff(RF_bad,Rspace_f+'Pistes_non_connectees',Extent,nrows,ncols,Csize,road_network_proj,0,'UINT8')
        console_info("    - Certaines pistes forestieres ne sont pas connectees a des routes ou au reseau public.")
        console_info("      Pour voir ou elles se trouvent ouvrir le raster "+Rspace_f+"Pistes_non_connectees.tif")
        console_info("      Ces lineaires sont exclus de l'analyse.")
    else:
        console_info("    - Pistes forestieres traitees")  
    Route_for[Res_pub==1]=0
    Piste[Res_pub==1]=0
    np.save(Dir_temp+"Route_for",Route_for) 
    np.save(Dir_temp+"Piste",np.int8(Piste))
    del Tab_res_pub,Lien_RF,Lien_piste,Res_pub  
    gc.collect() 
    ##############################################################################################################################################
    ### Create a raster of total obstacle for forwarder
    ##############################################################################################################################################
    if Dir_Obs_forwarder!="":
        Obstacles_forwarder = prepa_obstacle_skidder(Dir_Obs_forwarder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1))
    else:
        Obstacles_forwarder = np.zeros((nrows,ncols),dtype=np.int8)
    np.save(Dir_temp+"Obstacles_forwarder",np.int8(Obstacles_forwarder))    
    console_info("    - Raster d'obstacles cree")  
    console_info("Pre-traitement des donnees d'entree termine")
    ##############################################################################################################################################
    ### Close the script
    ##############################################################################################################################################
    clear_big_nparray()


def process_forwarder():
    Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,_,_,_,Dir_Obs_forwarder,_,file_Vol_ha,_,_ = Sylvaccess_pluginDialog.get_spatial(1,1,1,1,1,1,0,0,0,1,0,1,0,0)
    _,_,_,_,Pente_max_bucheron = Sylvaccess_pluginDialog.get_general(1,0,0,0,0,1)
    Forw_angle_incl,Forw_angle_up,Forw_angle_down,Forw_Lmax,Forw_Dmax_out_for,Forw_portee,Forw_Debclass=Sylvaccess_pluginDialog.get_porteur(1,1,1,1,1,1,1,1)

    console_info("Debut de Sylvaccess - Porteur")

    ###############################################################################################################################################
    ### Initialisation
    ###############################################################################################################################################
    Hdebut = datetime.datetime.now()
    
    # Create a folder for process result
    Rspace_s = Rspace+"Porteur/"
    try:os.mkdir(Rspace_s)
    except:pass
    Dir_temp = Wspace+"Temp/"
    
    # Check if temporary files have been generated and have the same extent
    try:
        _,values,_,Extent = raster_get_info(file_MNT)
    except:
        console_info("Erreur: veuillez definir une projection pour le raster MNT")
        return ""    
    try: 
        _,v1=read_info(Dir_temp+'info_extent.txt')
        for i,item in enumerate(values):
            if v1[i]!=round(item,2):
                prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder)
            if i+1>4:break
    except:
        prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder)
    
    Csize = values[4]
    # Inputs
    try:
        Foret = np.int8(np.load(Dir_temp+"Foret.npy"))
        Piste = np.int8(np.load(Dir_temp+"Piste.npy"))
        Route_for = np.int8(np.load(Dir_temp+"Route_for.npy"))        
        Lien_piste = np.load(Dir_temp+"Lien_piste.npy")
        Res_pub = np.int8(np.load(Dir_temp+"Res_pub.npy"))
        Lien_RF = np.load(Dir_temp+"Lien_RF.npy")
        Pente = np.load(Dir_temp+"Pente.npy")
        Pond_pente = np.load(Dir_temp+"Pond_pente.npy")
        MNT = np.load(Dir_temp+"MNT.npy")
        try:
            Aspect = np.load(Dir_temp+"Aspect.npy")    
        except:
            Aspect = np.int16(fc.exposition(np.float_(MNT),Csize,-9999))
            Aspect[Pente==-9999] = -9999
            np.save(Dir_temp+"Aspect",Aspect)             
        try:
            Obstacles_forwarder = np.int8(np.load(Dir_temp+"Obstacles_forwarder.npy"))
        except:
            nrows,ncols = MNT.shape[0],MNT.shape[1]
            if Dir_Obs_forwarder!="":
                Obstacles_forwarder = np.int8(prepa_obstacle_skidder(Dir_Obs_forwarder,Extent,Csize,ncols,nrows,((Route_for>0)*1+(Piste>0)*1)))
            else:
                Obstacles_forwarder = np.zeros((nrows,ncols),dtype=np.int8)
                np.save(Dir_temp+"Obstacles_forwarder",np.int8(Obstacles_forwarder)) 
    except: 
        prepa_data_fwd(Wspace,Rspace,file_MNT,file_shp_Foret,file_shp_Desserte,Dir_Obs_forwarder)
        Foret = np.int8(np.load(Dir_temp+"Foret.npy"))
        Piste = np.int8(np.load(Dir_temp+"Piste.npy"))
        Res_pub = np.int8(np.load(Dir_temp+"Res_pub.npy"))
        Route_for = np.int8(np.load(Dir_temp+"Route_for.npy"))        
        Lien_piste = np.load(Dir_temp+"Lien_piste.npy")
        Lien_RF = np.load(Dir_temp+"Lien_RF.npy")
        Pente = np.load(Dir_temp+"Pente.npy")
        Pond_pente = np.load(Dir_temp+"Pond_pente.npy")
        MNT = np.load(Dir_temp+"MNT.npy")
        Aspect = np.load(Dir_temp+"Aspect.npy")
        Obstacles_forwarder = np.int8(np.load(Dir_temp+"Obstacles_forwarder.npy"))
    
    # Generate useful variable for the process
    nrows,ncols = MNT.shape[0],MNT.shape[1]
    road_network_proj=get_proj_from_road_network(file_shp_Desserte)
    Fwd_max_inc = math.degrees(math.atan(Forw_angle_incl*0.01))
    Fwd_max_up = math.degrees(math.atan(Forw_angle_up*0.01))
    Fwd_max_down = math.degrees(math.atan(Forw_angle_down*0.01))
    Pond_pente[Obstacles_forwarder==1] = 1000
    Pente_ok_buch = np.int8((fc.focal_stat_max(np.float_(Pente),-9999,1)<=Pente_max_bucheron))
    MNT_OK = np.int8((MNT!=values[5]))
    Pente_deg = np.degrees(np.arctan(Pente*0.01))
    Pente_deg[Pente==-9999]=-9999        
        
    Pente_ok_forw = np.int8((Pente_deg<=min(Fwd_max_inc,Fwd_max_up,Fwd_max_down))*(Pente_deg > -9999))    
    
    Surf_foret = np.sum((Foret==1)*MNT_OK)*Csize*Csize*0.0001
    Surf_foret_non_access = int(np.sum((Pente_ok_buch==0)*(Foret==1)*MNT_OK*Csize*Csize*0.0001)+0.5)
    
    Row_line,Col_line,D_line,Nbpix_line=create_buffer_skidder(Csize,Forw_Lmax,Forw_Lmax)
    
    if file_Vol_ha != "":
        Vol_ha = load_float_raster_simple(file_Vol_ha)
        Vol_ha[np.isnan(Vol_ha)]=0
        Temp = ((Vol_ha>0)*(Foret==1)*MNT_OK)>0
        Vtot = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        Temp = ((Vol_ha>0)*(Pente_ok_buch==0)*(Foret==1)*MNT_OK)>0
        Vtot_non_buch = np.mean(Vol_ha[Temp])*np.sum(Temp)*Csize*Csize*0.0001
        del Vol_ha,Temp
    else:
        Vtot=0    
        Vtot_non_buch =0
       
    ArrayToGtiff(Pente_ok_buch,Rspace_s+'Pente_ok_buch',Extent,nrows,ncols,road_network_proj,0,'UINT8')   
    console_info("    - Initialisation terminee")  
    del Pente
    gc.collect()     
    
    ###############################################################################################################################################    
    ### Calculation of skidding distance inside the forest stands
    ###############################################################################################################################################                  
    # Identify the forest area that may be run through by the skidder
    zone_rast = Pente_ok_forw*(Foret==1)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    from_rast = np.int8(((Piste==1)+(Route_for==1))>0)
    from_rast[Res_pub==1]=0
    Zone_for,_ = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Zone_for[Zone_for>=0]=1
    Zone_for[from_rast==1]=1
    Zone_for=np.int8(Zone_for)
    
    # Create a buffer of Dmax_out_forest around these area taking into account slope and obstacles
    from_rast = fc.focal_stat_nb(np.float_(Zone_for==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.copy(Pente_ok_forw)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for2,Out_alloc = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Forw_Dmax_out_for) 
    Pente_ok_forwarder = np.int8(Zone_for2>0)
    Pente_ok_forwarder[Zone_for==1]=1    
    
    del Zone_for,Zone_for2,Out_alloc
    gc.collect()
    
    #Stick all forest with pente_ok_skidder to the area
    from_rast = fc.focal_stat_nb(np.float_(Pente_ok_forwarder==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = Pente_ok_forw*(Foret==1)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for,Out_alloc = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize) 
    Pente_ok_forwarder[Zone_for>=0]=1  
    
    # Create a buffer of Dmax_out_forest around forest
    from_rast = fc.focal_stat_nb(np.float_(Foret==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.int8(Pente_deg<=max(Fwd_max_inc,Fwd_max_up,Fwd_max_down))
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Foret==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_for,Out_alloc = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Forw_Dmax_out_for) 
    BufForest = np.int8(Zone_for>0)
           
    del Zone_for,from_rast,zone_rast,Out_alloc,Pente_ok_forw
    gc.collect()     
    
    ###############################################################################################################################################
    ### Get directly passable area from forest tracks PAFT (forwarder can reach throught the forest)
    ###############################################################################################################################################
    D_foret,L_Piste,D_piste=fc.Dfwd_flat_forest_tracks(Lien_piste, Pond_pente,Pente_ok_forwarder*(Route_for==0), Csize)
    
    D_foret[(Foret+BufForest)==0] = -9999
    L_Piste[(Foret+BufForest)==0] = -9999
    D_piste[(Foret+BufForest)==0] = -9999
    
    ###############################################################################################################################################
    ### Get directly passable area from forest roads PAFR (forwarder can reach throught the forest)
    ###############################################################################################################################################
    RF_D,RF_L_forRF = fc.Dfwd_flat_forest_road(Lien_RF,Pond_pente,Pente_ok_forwarder*(Piste==0),Csize)

    RF_D[(Foret+BufForest)==0] = -9999
    RF_L_forRF[(Foret+BufForest)==0] = -9999    
    
    del BufForest,Pente_ok_forwarder
    gc.collect()
    
    ###############################################################################################################################################
    ### Check forwarder inclination and terrain slope conditions from forest road network
    ###############################################################################################################################################
    from_rast = fc.focal_stat_nb(np.float_(Foret==1),0,1)
    from_rast = np.int8((from_rast<9)*(from_rast>0))
    zone_rast = np.copy(Pente_ok_buch)
    zone_rast[Obstacles_forwarder==1]=0
    zone_rast[Foret==1]=0
    zone_rast[Res_pub==1]=0   
    zone_rast[MNT_OK==0]=0   
    Zone_OK,Out_alloc = fc.calcul_distance_de_cout(from_rast,Pond_pente,zone_rast,Csize,Forw_Dmax_out_for) 
    Zone_OK[Zone_OK>=0]=1
    Zone_OK[Zone_OK<0]=0
    Zone_OK=np.int8(Zone_OK)
    Zone_OK[Foret==1]=1
    Zone_OK[MNT_OK==0]=0
    Zone_OK[Obstacles_forwarder==1]=0
    Zone_OK[Pente_ok_buch==0]=0
    
    del Out_alloc
    
    contour=np.int8((Piste+Route_for)>0)
    contour[Obstacles_forwarder==1]=0
    contour[Res_pub==1]=0   
    contour[MNT_OK==0]=0     
    pixels=np.argwhere(contour>0)
    del contour    
    
    #line=ID_contour, Y, X,Dpis,Dfor,L_RF,L_Piste    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int)    
    ID = 1
    Dpis=np.zeros_like(MNT,np.int32)
    Lpis=np.zeros_like(MNT,np.int32)
    LRF=np.zeros_like(MNT,np.int32)
    for i,p in enumerate(Lien_piste[1:]):
        Dpis[p[0],p[1]]=p[2]
        Lpis[p[0],p[1]]=i+1
        LRF[p[0],p[1]]=p[4]
    for i,p in enumerate(Lien_RF[1:]):        
        LRF[p[0],p[1]]=i+1    
    
    for pixel in pixels:        
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        Lien_contour[ID,2],Lien_contour[ID,3]=Dpis[pixel[0],pixel[1]],0
        Lien_contour[ID,4],Lien_contour[ID,5]=LRF[pixel[0],pixel[1]],Lpis[pixel[0],pixel[1]]
        ID +=1   
    
    del Dpis,Lpis,LRF
    gc.collect()
    
    zone_rast = np.int8(Zone_OK*(Pente_deg<=max(Fwd_max_inc,Fwd_max_up,Fwd_max_down)))
        
    Dpente,L_RF,L_pis,Dpis,Dfor=fc.fwd_azimuts_contour(Lien_contour,MNT,Aspect,Pente_deg,Row_line,Col_line,D_line,Nbpix_line,
                                                       Fwd_max_up, Fwd_max_down,Fwd_max_inc, Forw_Lmax, nrows,ncols,zone_rast)    
        
    del Dfor
    gc.collect()
    
    ###############################################################################################################################################
    ### Concatenate for passable area
    ###############################################################################################################################################   
    DTot = np.ones((nrows,ncols),dtype=np.int32)*100001
    Dforet = np.ones((nrows,ncols),dtype=np.int32)*-9999    
    Dpiste = np.ones((nrows,ncols),dtype=np.int32)*-9999
    Lien_foret_piste = np.ones((nrows,ncols),dtype=np.int32)*-9999     
    Lien_foret_RF = np.ones((nrows,ncols),dtype=np.int32)*-9999
    
    ### Get flat area from forest tracks
    Temp = (D_piste>=0)
    DTot[Temp] = D_foret[Temp]+D_piste[Temp]
    Dforet[Temp] = D_foret[Temp] 
    Dpiste[Temp] = D_piste[Temp]
    Lien_foret_piste[Temp] = L_Piste[Temp] 
       
    ### Get flat area from forest roads
    Temp =  (DTot<100001)*(RF_D>=0)
    Temp[RF_D>(Dforet+0.1*Dpiste)]=0
    DTot[Temp] = RF_D[Temp]
    Dforet[Temp] = RF_D[Temp] 
    Dpiste[Temp] = 0
    Lien_foret_RF[Temp] = RF_L_forRF[Temp]
    Temp=(DTot==100001)*(RF_D>=0)
    DTot[Temp] = RF_D[Temp]
    Dforet[Temp] = RF_D[Temp] 
    Dpiste[Temp] = 0
    Lien_foret_RF[Temp] = RF_L_forRF[Temp]
    
    contour = fc.focal_stat_nb(np.float_(Dforet),-9999,1)
    contour = ((contour<9)*(contour>0))>0
    
    ### Get slope area from tracks and roads
    Temp =  (DTot<100001)*(Dpente>=0)
    Temp[Dpente<(Dforet+0.1*Dpiste)]=0
    DTot[Temp] = Dpente[Temp]+Dpis[Temp]
    Dforet[Temp] = 0
    Dpiste[Temp] = Dpis[Temp]
    Lien_foret_RF[Temp] = L_RF[Temp]
    Lien_foret_piste[Temp] = L_pis[Temp] 
    Temp =  (DTot==100001)*(Dpente>=0)
    DTot[Temp] = Dpente[Temp]+Dpis[Temp]
    Dforet[Temp] = 0
    Dpiste[Temp] = Dpis[Temp]
    Lien_foret_RF[Temp] = L_RF[Temp]
    Lien_foret_piste[Temp] = L_pis[Temp] 
    
    del RF_D,RF_L_forRF,Temp,D_foret,L_Piste,D_piste
    gc.collect()    
    
    console_info("    - Surface directement parcourable identifiee") 
    
    ###############################################################################################################################################
    ### Get contour of passable area (check forwarder inclination and terrain slope conditions)
    ###############################################################################################################################################
    #Identify zone_ok taking into account non forest area    
    contour[Obstacles_forwarder==1]=0
    contour[Res_pub==1]=0  
    contour[Route_for==1]=0  
    contour[Piste==1]=0  
    contour[MNT_OK==0]=0 
    
    Temp = (Dforet>=0)*(contour==0)
    pixels=np.argwhere(contour>0)
    del contour
    
    #line=ID_contour, Y, X,Dpis,Dfor,L_RF,L_Piste    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int)    
    ID = 1
    for pixel in pixels:
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        Lien_contour[ID,2],Lien_contour[ID,3]=Dpiste[pixel[0],pixel[1]],Dforet[pixel[0],pixel[1]]
        Lien_contour[ID,4],Lien_contour[ID,5]=Lien_foret_RF[pixel[0],pixel[1]],Lien_foret_piste[pixel[0],pixel[1]]
        ID +=1   
        
    zone_rast = np.int8(Zone_OK*(Pente_deg<=max(Fwd_max_inc,Fwd_max_up,Fwd_max_down))*(Temp==0))
        
    Dpente,L_RF,L_pis,Dpis,Dfor=fc.fwd_azimuts_contour(Lien_contour,MNT,Aspect,Pente_deg,Row_line,Col_line,D_line,Nbpix_line,
                                                       Fwd_max_up, Fwd_max_down,Fwd_max_inc, Forw_Lmax, nrows,ncols,zone_rast)
    
    del MNT,Aspect,Pente_deg
    gc.collect()   
    
    ###############################################################################################################################################
    ### Concatenate for in slope area 
    ###############################################################################################################################################      
     
    Temp = (DTot==100001)*(Dpente+Dfor+Dpis>=0)
    DTot[Temp] = Dfor[Temp]+Dpis[Temp]+Dpente[Temp]
    Dforet[Temp] = Dfor[Temp]+Dpente[Temp]
    Dpiste[Temp] = Dpis[Temp]
    Lien_foret_piste[Temp] = L_pis[Temp] 
    Lien_foret_RF[Temp] = L_RF[Temp] 
    
    Temp = (Foret==0)
    DTot[Temp] = 100001
    Dforet[Temp] = -9999
    Dpiste[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_RF[Temp] = -9999   
    
    del Dpente,Dfor,L_pis,Dpis,Temp,Lien_contour,pixels,L_RF,zone_rast
    gc.collect()    
    
    console_info("    - Surface en pente accessible identifiee") 
    
    ################################################################################################################################################
    ### Calculation of area reachable with the grap
    ################################################################################################################################################                   
    # Get the contour of traversable area
    contour = fc.focal_stat_nb(np.float_(Dforet),-9999,1)
    contour = (contour<9)*(contour>0) 
    contour[Obstacles_forwarder==1]=0
    contour[Res_pub==1]=0   
    contour[MNT_OK==0]=0 
    pixels=np.argwhere(contour>0)
    
    del contour,MNT_OK,Res_pub,Obstacles_forwarder
    gc.collect()
    
    Temp = (DTot<100001)    
    Lien_contour = np.zeros((pixels.shape[0]+1,6),dtype=np.int)    
    ID = 1
    for pixel in pixels:
        Lien_contour[ID,0],Lien_contour[ID,1]=pixel[0],pixel[1]
        Lien_contour[ID,2],Lien_contour[ID,3]=Dforet[pixel[0],pixel[1]],Lien_foret_RF[pixel[0],pixel[1]]
        Lien_contour[ID,4],Lien_contour[ID,5]=Dpiste[pixel[0],pixel[1]],Lien_foret_piste[pixel[0],pixel[1]]
        ID +=1   
    
    zone_rast = Zone_OK*(Temp==0)   
    Dbras,Lien_RF2,Lien_piste2,Dpiste2,Dforet2=fc.Fwd_add_contour(Lien_contour, Pond_pente,zone_rast,Forw_portee, Csize)

    ###############################################################################################################################################                                                                                    
    ### Concatenation of the resultats number 2
    ###############################################################################################################################################
    Temp =  (DTot==100001)*(Dbras+Dpiste2+Dforet2>=0)
    DTot[Temp] = Dbras[Temp]+Dpiste2[Temp]+Dforet2[Temp]
    Dforet[Temp] = Dbras[Temp] + Dforet2[Temp]
    Dpiste[Temp] = Dpiste2[Temp]
    Lien_foret_piste[Temp] = Lien_piste2[Temp]
    Lien_foret_RF[Temp] = Lien_RF2[Temp] 
    
    # Keep only results in Forest area
    Temp = (DTot==100001)
    DTot[Temp] = -9999
    Temp = (Foret==0)
    DTot[Temp] = -9999
    Dforet[Temp] = -9999
    Dpiste[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
    
    del zone_rast,Zone_OK,Temp,Lien_contour,Dbras,Dpiste2,Dforet2,Lien_piste2,Lien_RF2,Pond_pente
    gc.collect()
    
    # Fill Lien foret respub and Lien foret RF
    Lien_foret_Res_pub,Lien_foret_RF,Keep=fc.fill_Link(Lien_foret_piste,Lien_piste,Lien_RF, Lien_foret_RF, nrows,ncols)
    
    Temp = (Keep<1)*((Piste==1)+(Route_for==1))>0
    DTot[Temp] = -9999
    Dforet[Temp] = -9999
    Dpiste[Temp] = -9999
    Lien_foret_piste[Temp] = -9999
    Lien_foret_RF[Temp] = -9999
       
    Zone_accessible = np.int8(1*(DTot>=0))    
    
    del Keep,Piste,Route_for
    gc.collect()    
    console_info("    - Surface accessible avec la grue ajoutee") 
    model_name = "Porteur"
    
    
    ###############################################################################################################################################                                                                                    
    ### CREATE SUMMARY TABLE
    ###############################################################################################################################################
    make_summary_surface_vol(Forw_Debclass,file_Vol_ha,Surf_foret,Surf_foret_non_access,Csize,DTot,Vtot,Vtot_non_buch,Rspace_s,model_name)
            
    ###############################################################################################################################################                                                                                    
    ### SAVE RASTER
    ###############################################################################################################################################    
    console_info("    - Sauvegarde des fichiers de sorties") 
    ArrayToGtiff(DTot,Rspace_s+'Distance_totale_foret_route_forestiere',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Lien_foret_piste,Rspace_s+'Lien_foret_piste',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_RF,Rspace_s+'Lien_foret_route_forestiere',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Lien_foret_Res_pub,Rspace_s+'Lien_foret_Reseau_public',Extent,nrows,ncols,road_network_proj,-9999,'INT32')
    ArrayToGtiff(Dforet,Rspace_s+'Distance_dans_foret',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Dpiste,Rspace_s+'Distance_sur_piste',Extent,nrows,ncols,road_network_proj,-9999,'INT16')
    ArrayToGtiff(Zone_accessible,Rspace_s+'Zone_accessible',Extent,nrows,ncols,road_network_proj,0,'UINT8')
    
    layer_name = 'Porteur_recap_accessibilite'
    source_src=get_source_src(file_shp_Desserte)  
    create_access_shapefile(DTot,Rspace_s,Zone_accessible,Foret,Forw_Debclass.split(";"),road_network_proj,source_src,Csize, Dir_temp,Extent,nrows,ncols,layer_name)
       
    ###############################################################################################################################################                                                                                    
    ### SAVE PARAMETERS
    ###############################################################################################################################################    
    
    str_duree,str_fin,str_debut=heures(Hdebut)
    ### Genere le fichier avec le resume des parametres de simulation
    file_name = str(Rspace_s)+"Parametres_simulation.txt"
    resume_texte = "Sylvaccess : CARTOGRAPHIE AUTOMATIQUE DES ZONES ACCESSIBLES PAR PORTEUR FORESTIER\n\n\n"
    resume_texte = resume_texte+"Version du programme : 3.5.1 de 12/2021\n\n"
    resume_texte = resume_texte+"Resolution           : "+str(Csize)+" m\n\n"
    resume_texte = resume_texte+"Date et heure de lancement du script:             "+str_debut+"\n"
    resume_texte = resume_texte+"Date et heure a la fin de l'execution du script:  "+str_fin+"\n"
    resume_texte = resume_texte+"Temps total d'execution du script:                "+str_duree+"\n\n"
    resume_texte = resume_texte+"PARAMETRES UTILISES POUR LA MODELISATION:\n\n"
    resume_texte = resume_texte+"   - Pente en travers maximale :                                  "+str(Forw_angle_incl)+" %\n"
    resume_texte = resume_texte+"   - Pente maximale en remontant les bois  :                      "+str(Forw_angle_up)+" %\n"
    resume_texte = resume_texte+"   - Pente maximale en descendant les bois :                      "+str(Forw_angle_down)+" %\n"
    resume_texte = resume_texte+"   - Portee de la grue:                                           "+str(Forw_portee)+" m\n"
    resume_texte = resume_texte+"   - Distance maximale quand pente > pente en travers max :       "+str(Forw_Lmax)+" m\n"
    resume_texte = resume_texte+"   - Distance maximale parcourable hors foret et hors desserte :  "+str(Forw_Dmax_out_for)+" m\n"
    resume_texte = resume_texte+"   - Pente maximale pour l'abattage manuel des arbres :           "+str(Pente_max_bucheron)+" %\n"  
    
    if os.path.exists(Rspace_s+'Pistes_non_connectees.tif'):
        resume_texte = resume_texte+"\n\n"
        resume_texte = resume_texte+"      !!! Attention !!! Certaines pistes forestières ne sont pas connectée.\n"  
        resume_texte = resume_texte+"      Elles ont été exclues de l'analyse.\n"  
    if os.path.exists(Rspace_s+'Routes_forestieres_non_connectees.tif'):
        resume_texte = resume_texte+"\n\n      !!! Attention !!! Certaines routes forestières ne sont pas connectée.\n"  
    
    fichier = open(file_name, "w")
    fichier.write(resume_texte)
    fichier.close()
    console_info("Accessibilite avec porteur terminee")

    ##############################################################################################################################################
    ### Close the script
    ##############################################################################################################################################
    clear_big_nparray()

####################################################################
#  ______ ____    ____ .___________. __    __    ______   .__   __.# 
# /      |\   \  /   / |           ||  |  |  |  /  __  \  |  \ |  |#
#|  ,----' \   \/   /  `---|  |----`|  |__|  | |  |  |  | |   \|  |# 
#|  |       \_    _/       |  |     |   __   | |  |  |  | |  . `  |# 
#|  `----.    |  |         |  |     |  |  |  | |  `--'  | |  |\   |# 
# \______|    |__|         |__|     |__|  |__|  \______/  |__| \__|# 
####################################################################                                                                  

global g,intsup,best,nblineTabis,h,b,l,r  
g = 9.80665
intsup = 0 
best = 0
nblineTabis = 1
h = 0
b = 0
l = 0
r = 0


def dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4):
    a = 1. / (Th * Th) * (
            -Tv * Tv / rac1 + (Tv - F - W) * (Tv - F - W) / rac2 -
            (Tv - F - W * s1 / Lo) * (Tv - F - W * s1 / Lo) / rac3 +
            (Tv - W * s1 / Lo) * (Tv - W * s1 / Lo) / rac4
    )
    a += math.sqrt(1 + (Tv / Th) * (Tv / Th)) - math.sqrt(1 + ((Tv - F - W) / Th) * ((Tv - F - W) / Th)) + \
         math.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th) * ((Tv - F - W * s1 / Lo) / Th)) - \
         math.sqrt(1 + ((Tv - W * s1 / Lo) / Th) * ((Tv - W * s1 / Lo) / Th))
    a *= Lo / W
    return a


def double_max(a, b):
    return a if a >= b else b


def int_max(a, b):
    return a if a >= b else b


def double_min(a, b):
    return a if a <= b else b


def max_array(a):
    
    max_a = a[0]
    for item in range(1, a.shape[0]):
        if a[item] > max_a:
            max_a = a[item]
    return max_a


def max_array_f(a):
    max_a = a[0]
    for item in range(1, a.shape[0]):
        if a[item] > max_a:
            max_a = a[item]
    return max_a


def sum_array_f(a):
    summ = a[0]
    for item in range(1, a.shape[0]):
        summ += a[item]
    return summ


def copy_int8_array(arraystock, arraytocopy, nline, ncol):
    for i in range(nline):
        for j in range(ncol):
            arraystock[i, j] = arraytocopy[i, j]
    return arraystock


def int8_array_sum(matrice):
    somme = 0
    for y in range(matrice.shape[0]):
        for x in range(matrice.shape[1]):
            somme += matrice[y, x]
    return somme


def int_array_sum(matrice):
    somme = 0
    for y in range(matrice.shape[0]):
        for x in range(matrice.shape[1]):
            somme += matrice[y, x]
    return somme


def pente(raster_mnt, Csize, nodata):
    nline, ncol = raster_mnt.shape
    pente = np.zeros_like(raster_mnt, dtype=np.float32)

    for y in range(1, nline-1):
        for x in range(1, ncol-1):
            e = raster_mnt[y, x]
            if e > nodata:
                a, b, c, d, f, g, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                          raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                          raster_mnt[y+1, x], raster_mnt[y+1, x+1])
                dz_dx = float(c + 2*f + i - (a + 2*d + g)) / float(8 * Csize)
                dz_dy = float(g + 2*h + i - (a + 2*b + c)) / float(8 * Csize)
                pente[y, x] = sqrt(dz_dx * dz_dx + dz_dy * dz_dy) * 100
            else:
                pente[y, x] = nodata

    # Coins
    pente[0, 0] = calculate_corner_pente(raster_mnt, nodata, Csize, 0, 0)
    pente[nline-1, 0] = calculate_corner_pente(raster_mnt, nodata, Csize, nline-1, 0)
    pente[0, ncol-1] = calculate_corner_pente(raster_mnt, nodata, Csize, 0, ncol-1)
    pente[nline-1, ncol-1] = calculate_corner_pente(raster_mnt, nodata, Csize, nline-1, ncol-1)

    # First and last rows
    for x in range(1, ncol-1):
        pente[0, x] = calculate_edge_pente(raster_mnt, nodata, Csize, 0, x)
        pente[nline-1, x] = calculate_edge_pente(raster_mnt, nodata, Csize, nline-1, x)

    # First and last columns
    for y in range(1, nline-1):
        pente[y, 0] = calculate_edge_pente(raster_mnt, nodata, Csize, y, 0)
        pente[y, ncol-1] = calculate_edge_pente(raster_mnt, nodata, Csize, y, ncol-1)

    return pente


def calculate_corner_pente(raster_mnt, nodata, Csize, y, x):
    e = raster_mnt[y, x]
    if e > nodata:
        _, _, _, d, f, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                               raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x],
                               raster_mnt[y+1, x+1])
        dz_dx = float(f + i - (e + h)) / float(2 * Csize)
        dz_dy = float(h + i - (d + f)) / float(2 * Csize)
        return sqrt(dz_dx * dz_dx + dz_dy * dz_dy) * 100
    else:
        return nodata


def calculate_edge_pente(raster_mnt, nodata, Csize, y, x):
    e = raster_mnt[y, x]
    if e > nodata:
        _, b, c, _, f, _, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                  raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                  raster_mnt[y+1, x], raster_mnt[y+1, x+1])
        dz_dx = float(f + c - (b + e + h)) / float(4 * Csize)
        dz_dy = float(h + i - (b + e + f)) / float(3 * Csize)
        return sqrt(dz_dx * dz_dx + dz_dy * dz_dy) * 100
    else:
        return nodata


def exposition(raster_mnt, Csize, nodata):
    nline, ncol = raster_mnt.shape
    expo = np.zeros_like(raster_mnt, dtype=np.float)

    for y in range(1, nline-1):
        for x in range(1, ncol-1):
            e = raster_mnt[y, x]
            if e > nodata:
                a, b, c, d, f, g, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                          raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                          raster_mnt[y+1, x], raster_mnt[y+1, x+1])
                dz_dx = float(c + 2*f + i - (a + 2*d + g)) / float(8 * Csize)
                dz_dy = float(g + 2*h + i - (a + 2*b + c)) / float(8 * Csize)
                expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
                if expo1 < 0.:
                    expo[y, x] = 90.0 - expo1
                elif expo1 > 90.:
                    expo[y, x] = 360.0 - expo1 + 90.0
                else:
                    expo[y, x] = 90.0 - expo1
            else:
                expo[y, x] = nodata

    # Coins
    expo[0, 0] = calculate_corner_expo(raster_mnt, nodata, Csize, 0, 0)
    expo[nline-1, 0] = calculate_corner_expo(raster_mnt, nodata, Csize, nline-1, 0)
    expo[0, ncol-1] = calculate_corner_expo(raster_mnt, nodata, Csize, 0, ncol-1)
    expo[nline-1, ncol-1] = calculate_corner_expo(raster_mnt, nodata, Csize, nline-1, ncol-1)

    # First and last rows
    for x in range(1, ncol-1):
        expo[0, x] = calculate_edge_expo(raster_mnt, nodata, Csize, 0, x)
        expo[nline-1, x] = calculate_edge_expo(raster_mnt, nodata, Csize, nline-1, x)

    # First and last columns
    for y in range(1, nline-1):
        expo[y, 0] = calculate_edge_expo(raster_mnt, nodata, Csize, y, 0)
        expo[y, ncol-1] = calculate_edge_expo(raster_mnt, nodata, Csize, y, ncol-1)

    return expo


def calculate_corner_expo(raster_mnt, nodata, Csize, y, x):
    e = raster_mnt[y, x]
    if e > nodata:
        _, _, _, d, f, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                               raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x],
                               raster_mnt[y+1, x+1])
        dz_dx = float(f + i - (e + h)) / float(2 * Csize)
        dz_dy = float(h + i - (d + f)) / float(2 * Csize)
        expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
        if expo1 < 0.:
            return 90.0 - expo1
        elif expo1 > 90.:
            return 360.0 - expo1 + 90.0
        else:
            return 90.0 - expo1
    else:
        return nodata


def calculate_edge_expo(raster_mnt, nodata, Csize, y, x):
    e = raster_mnt[y, x]
    if e > nodata:
        _, b, c, _, f, _, h, i = (raster_mnt[y-1, x-1], raster_mnt[y-1, x], raster_mnt[y-1, x+1],
                                  raster_mnt[y, x-1], raster_mnt[y, x+1], raster_mnt[y+1, x-1],
                                  raster_mnt[y+1, x], raster_mnt[y+1, x+1])
        dz_dx = float(f + c - (b + e + h)) / float(4 * Csize)
        dz_dy = float(h + i - (b + e + f)) / float(3 * Csize)
        expo1 = 57.29578 * atan2(dz_dy, -dz_dx)
        if expo1 < 0.:
            return 90.0 - expo1
        elif expo1 > 90.:
            return 360.0 - expo1 + 90.0
        else:
            return 90.0 - expo1
    else:
        return nodata


def mask_zone(matrice):
    nline, ncol = matrice.shape
    top, bottom, left, right = nline, 0, ncol, 0

    for y in range(nline):
        for x in range(ncol):
            if matrice[y, x] > 0:
                top = min(top, y)
                bottom = max(bottom, y)
                left = min(left, x)
                right = max(right, x)

    return top, bottom, left, right


def calcul_distance_de_cout(from_rast, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = from_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    h, b, l, r = mask_zone(from_rast)
    
    # Création des rasters de sortie
    Out_distance = np.ones_like(from_rast, dtype=np.int32) * Max_distance
    Out_alloc = np.ones_like(from_rast, dtype=np.int32) * -9999
    
    x1, y1 = l, h
    for y1 in range(h, b):
        for x1 in range(l, r):
            if from_rast[y1, x1] > 0:
                Out_distance[y1, x1] = 0
                Out_alloc[y1, x1] = from_rast[y1, x1]
                for y in range(max(0, y1-1), min(nline, y1+2)):
                    for x in range(max(0, x1-1), min(ncol, x1+2)):                        
                        if zone_rast[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag
                            else:
                                Dist = cost_rast[y, x] * direct
                            if Out_distance[y, x] > Dist:
                                Out_distance[y, x] = int(Dist + 0.5)                                
                                Out_alloc[y, x] = from_rast[y1, x1]
    
    # Traitement complet
    h, b, l, r = mask_zone(zone_rast)
    dist_ac = Csize
    count_sans_match = 0
    
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        test = 0
        y1, x1 = h, l
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1   
                    for y in range(max(0, y1-1), min(nline, y1+2)):
                        for x in range(max(0, x1-1), min(ncol, x1+2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] > Dist:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    Out_alloc[y, x] = Out_alloc[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
    
    for y in range(nline):
        for x in range(ncol):
            if Out_distance[y, x] == Max_distance:
                Out_distance[y, x] = -9999
                Out_alloc[y, x] = -9999
    
    return Out_distance, Out_alloc


def calcul_distance_de_cout_2_alloc(from_rast1, from_rast2, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = from_rast1.shape
    diag = 1.414214 * Csize
    direct = Csize
    h, b, l, r = mask_zone(from_rast1)
    
    # Création des rasters de sortie
    Out_distance = np.ones_like(from_rast1, dtype=np.int) * (Max_distance + 1)
    Out_alloc1 = np.ones_like(from_rast1, dtype=np.int) * -9999
    Out_alloc2 = np.ones_like(from_rast1, dtype=np.int) * -9999
    
    x1, y1 = l, h
    for y1 in range(h, b):
        for x1 in range(l, r):
            if from_rast1[y1, x1] > 0:
                Out_distance[y1, x1] = 0
                Out_alloc1[y1, x1] = from_rast1[y1, x1]
                Out_alloc2[y1, x1] = from_rast2[y1, x1]
                for y in range(max(0, y1-1), min(nline, y1+2)):
                    for x in range(max(0, x1-1), min(ncol, x1+2)):                        
                        if zone_rast[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag
                            else:
                                Dist = cost_rast[y, x] * direct
                            if Out_distance[y, x] > Dist:
                                Out_distance[y, x] = int(Dist + 0.5)
                                Out_alloc1[y, x] = from_rast1[y1, x1]
                                Out_alloc2[y, x] = from_rast2[y1, x1]
    
    # Traitement complet
    h, b, l, r = mask_zone(zone_rast)
    dist_ac = Csize
    count_sans_match = 0
    
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        test = 0
        y1, x1 = h, l
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1   
                    for y in range(max(0, y1-1), min(nline, y1+2)):
                        for x in range(max(0, x1-1), min(ncol, x1+2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] > Dist:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    Out_alloc1[y, x] = Out_alloc1[y1, x1]
                                    Out_alloc2[y, x] = Out_alloc2[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
    
    for y in range(nline):
        for x in range(ncol):
            if Out_distance[y, x] > Max_distance:
                Out_distance[y, x] = -9999
                Out_alloc1[y, x] = -9999
                Out_alloc2[y, x] = -9999
    
    return Out_distance, Out_alloc1, Out_alloc2


def focal_stat_mean(raster, nodata, cote):
    nline, ncol = raster.shape
    mean = np.ones_like(raster, dtype=np.float) * nodata
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                nb, somme, y, x = 0.0, 0.0, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            somme += raster[y, x]
                            nb += 1.0
                
                mean[y1, x1] = somme / nb if nb != 0 else nodata
    
    return mean


def focal_stat_sum(raster, nodata, cote):
    nline, ncol = raster.shape
    rsomme = np.ones_like(raster, dtype=np.float) * nodata
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                somme, y, x = 0.0, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            somme += raster[y, x]
                
                rsomme[y1, x1] = somme
    
    return rsomme


def focal_stat_nb(raster, nodata, cote):
    nline, ncol = raster.shape
    rnb = np.ones_like(raster, dtype=np.float) * nodata
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                nb, y, x = 0.0, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            nb += 1.0
                
                rnb[y1, x1] = nb
    
    return rnb


def focal_stat_min(raster, nodata, cote):
    nline, ncol = raster.shape
    rmin = np.ones_like(raster, dtype=np.float) * nodata
    max_value = np.max(raster[raster != nodata])
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                local_min, y, x = max_value, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            local_min = min(local_min, raster[y, x])
                
                rmin[y1, x1] = local_min
    
    return rmin


def focal_stat_max(raster, nodata, cote):
    nline, ncol = raster.shape
    rmax = np.ones_like(raster, dtype=np.float) * nodata
    min_value = np.min(raster[raster != nodata])
    
    for y1 in range(nline):
        for x1 in range(ncol):
            if raster[y1, x1] != nodata:
                local_max, y, x = min_value, max(0, y1 - cote), max(0, x1 - cote)
                
                # Grille sans les bordures
                for y in range(max(0, y1 - cote), min(nline, y1 + cote + 1)):
                    for x in range(max(0, x1 - cote), min(ncol, x1 + cote + 1)):
                        if raster[y, x] != nodata:
                            local_max = max(local_max, raster[y, x])
                
                rmax[y1, x1] = local_max
    
    return rmax


def get_zone(direction, Matrice, Buffer_cote):
    h3 = direction * (Buffer_cote + 1)
    b3 = h3 + Buffer_cote + 1
    return Matrice[h3:b3, :]


def get_cadran(direction, Buffer_cote):
    if direction <= 90:
        h = 0
        l = Buffer_cote
    elif direction <= 180:
        h = Buffer_cote
        l = Buffer_cote
    elif direction <= 270:
        h = Buffer_cote
        l = 0
    else:
        h = 0
        l = 0
    return h, h + Buffer_cote + 1, l, l + Buffer_cote + 1


def get_npix(az, npix, coordY, coordX, ncols, nrows, Row_line, Col_line):
    for i in range(npix):
        x = Col_line[az, i] + coordX
        if x < 0 or x >= ncols:
            break
        y = Row_line[az, i] + coordY
        if y < 0 or y >= nrows:
            break
    return i


def Check_line1(Line, Lmax, Lmin, nrows, ncols, Lsans_foret, Lslope, PropSlope):
    indmax = 0
    indmax2 = 0
    npix = Line.shape[0]
    test = 1
    Dsansforet = 0.0
    Dcum = 0.0
    
    for i in range(npix):
        if Line[i, 5] < 0:
            break
        if Line[i, 5] >= ncols:
            break
        if Line[i, 6] < 0:
            break
        if Line[i, 6] >= nrows:
            break
        if Line[i, 7] == 1:
            break
        if np.sqrt(Line[i, 0] * Line[i, 0] + (Line[i, 1] - Line[0, 1]) * (Line[i, 1] - Line[0, 1])) > Lmax:
            break

        # Devers
        if i > 0:
            if Line[i, 8] + Line[i, 9] == 0:
                Dcum += Line[i, 0] - Line[i - 1, 0]
            if Dcum > Lslope:
                break
            if Dcum / Line[i, 0] < PropSlope:
                indmax2 = i
                Line[i, 9] = 1
            else:
                Line[i, 9] = 0
        else:
            Line[i, 9] = 1
        Line[i, 8] = Dcum

        # Longueur sans foret
        if Line[i, 2] == 1:
            indmax = i
            Dsansforet = 0
        else:
            if i > 0:
                Dsansforet += Line[i, 0] - Line[i - 1, 0]
            if Dsansforet >= Lsans_foret:
                break

    indmax = min(indmax, indmax2)
    Lline = Line[indmax, 0]

    if Lline <= Lmin:
        test = 0

    return test, indmax + 1, Lline


def get_line_carac_simple(coordX, coordY, az, Csize, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Forest, Rast_couv):
    i = 0
    nfor = 0
    Dmoy_car = 0
    Forest_area = 0

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0:
            i += 1
            continue
        if x >= ncols:
            i += 1
            continue
        y = Row_ext[az, i] + coordY
        if y < 0:
            i += 1
            continue
        if y >= nrows:
            i += 1
            continue
        if Forest[y, x] == 1:
            nfor += 1
            Dmoy_car += D_ext[az, i]
            Rast_couv[y, x] = 1
        i += 1

    if nfor > 0:
        Forest_area = nfor * Csize * Csize
        Dmoy_car = Dmoy_car / nfor
    else:
        Dmoy_car = D_ext[az, i]

    return int(Dmoy_car), int(Forest_area), Rast_couv


def Check_line(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, D_lat, Rast_couv, debut, recouv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.zeros((nrows, ncols), dtype=np.int8)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if x < 0:
            i += 1
            continue
        if x >= ncols:
            i += 1
            continue
        y = Row_ext[az, i] + coordY
        if y < 0:
            i += 1
            continue
        if y >= nrows:
            i += 1
            continue
        if Rast_couv[y, x] == 0:
            if D_ext[az, i] < debut:
                Rast_couv_bis[y, x] = 2
                nb2 += 1
            else:
                if float(D_lat[az, i]) < float(recouv):  # Ensure consistent types
                    Rast_couv_bis[y, x] = 1
                    nb1 += 1
                else:
                    Rast_couv_bis[y, x] = 2
                    nb2 += 1
        elif Rast_couv[y, x] == 1:
            test = 0
            break
        else:
            nb2 += 1
        i += 1

    # Check if the line is really important
    if test and nb1 >= (nb1 + nb2) * rapport:
        Rast_couv = Rast_couv + Rast_couv_bis
    else:
        test = 0

    return test, Rast_couv


def check_line2(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, D_lat, Rast_couv, recouv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.zeros((nrows, ncols), dtype=np.int8)
    debut = min(100, Lline * 0.4)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if 0 <= x < ncols:
            y = Row_ext[az, i] + coordY
            if 0 <= y < nrows:
                Rast_couv_bis[y, x] = 1
                if Rast_couv[y, x] == 0:
                    nb1 += 1
                elif Rast_couv[y, x] > 1 and D_ext[az, i] > debut and D_lat[az, i] < recouv:
                    test = 0
                    break
                else:
                    nb2 += 1
        i += 1

    if test and nb1 >= (nb1 + nb2) * rapport:
        Rast_couv += Rast_couv_bis
    else:
        test = 0

    return test, Rast_couv


def Check_line3(coordX, coordY, az, ncols, nrows, Lline, Row_ext, Col_ext, D_ext, Rast_couv, rapport):
    i = 0
    test = 1
    nb1 = 0
    nb2 = 0
    Rast_couv_bis = np.copy(Rast_couv)
    debut = min(100, Lline * 0.4)

    while D_ext[az, i] <= Lline:
        x = Col_ext[az, i] + coordX
        if 0 <= x < ncols:
            y = Row_ext[az, i] + coordY
            if 0 <= y < nrows:
                if Rast_couv[y, x] > 0:
                    Rast_couv_bis[y, x] -= 1
                if Rast_couv[y, x] == 1:
                    nb1 += 1
                elif Rast_couv[y, x] > 1:
                    if D_ext[az, i] > debut:
                        nb2 += 1
                    else:
                        nb1 += 1
        i += 1

    # Check if the line is really important
    if nb1 < (nb1 + nb2) * rapport:
        test = 0
        Rast_couv = Rast_couv_bis

    return test, Rast_couv


def Fcariage(Lo, F, q2, q3, s1, Dsupdep=0.0, Dsupend=0.0):
    return (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + F


def df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4):
    a = (1.0 / Th) * (-Tv / rac1 + (Tv - F - W) / rac2 - (Tv - F - W * s1 / Lo) / rac3 + (Tv - W * s1 / Lo) / rac4)
    a += math.asinh(Tv / Th) - math.asinh((Tv - F - W) / Th) + math.asinh((Tv - F - W * s1 / Lo) / Th) - math.asinh((Tv - W * s1 / Lo) / Th)
    a *= Lo / W
    a += Lo / EAo
    return a


def f_x(Th, Tv, Lo, EAo, W, F, s1, D):
    x = Th * Lo / EAo - D
    x += Th * Lo / W * (
        math.asinh(Tv / Th)
        - math.asinh((Tv - F - W) / Th)
        + math.asinh((Tv - F - W * s1 / Lo) / Th)
        - math.asinh((Tv - W * s1 / Lo) / Th)
    )
    return x


def f_z(Th, Tv, Lo, EAo, W, F, s1, H):
    z = (W * Lo / EAo) * (Tv / W - 0.5) - H
    Temp = (
        math.sqrt(1 + (Tv / Th) ** 2)
        - math.sqrt(1 + ((Tv - F - W) / Th) ** 2)
        + (F * W / (Th * EAo)) * (s1 / Lo - 1)
    )
    Temp += math.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th) ** 2) - math.sqrt(1 + ((Tv - W * s1 / Lo) / Th) ** 2)
    z += Th * Lo / W * Temp
    return z


def calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s):
    x = Th * s / EAo
    x += Th * Lo / W * (
        math.asinh(Tv / Th)
        - math.asinh((Tv - F - W * s / Lo) / Th)
        + math.asinh((Tv - F - W * s1 / Lo) / Th)
        - math.asinh((Tv - W * s1 / Lo) / Th)
    )
    return x


def calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s):
    z = W * s / EAo * (Tv / W - s / (2 * Lo))
    Temp = (
        math.sqrt(1 + (Tv / Th))
        - math.sqrt(1 + ((Tv - F - W * s / Lo) / Th))
        + F * W / (Th * EAo) * (s1 / Lo - s / Lo)
    )
    Temp += math.sqrt(1 + ((Tv - F - W * s1 / Lo) / Th)) - math.sqrt(1 + ((Tv - W * s1 / Lo) / Th))
    z += Th * Lo / W * Temp
    return z


def find_ThTvTmax(Tmax, W, EAo, F, pas, D, H, Lo, step=50):
    Fx_min = 0.05
    Gz_min = 0.05
    sum_min = 10.0
    Th = -1.0
    Tv = -1.0
    T = 1
    test = 0

    for i in range(0, int(Tmax), step):
        for j in range(0, int(Tmax), step):
            Fx = f_x(float(i), float(j), Lo, EAo, W, F, pas, D)
            if abs(Fx) < Fx_min:
                Gz = f_z(float(i), float(j), Lo, EAo, W, F, pas, H)
                if abs(Gz) < Gz_min:
                    if abs(Fx) + abs(Gz) < sum_min:
                        sum_min = min(abs(Fx) + abs(Gz), sum_min)
                        Th = float(i)
                        Tv = float(j)
                        if sum_min < 0.03:
                            test = 1
                            break
        if test == 1:
            break

    if math.sqrt(Th * Th + Tv * Tv) > Tmax:
        T = 0

    return Th, Tv, T


def newton_ThTv(Th, Tv, H, D, Lo, W, s1, F, EAo, Tmax, err=1.0):
    h = 100.0
    k = 100.0
    it = 0
    step = 100
    fo = 0
    go = 0
    rac1 = 0
    rac2 = 0
    rac3 = 0
    rac4 = 0
    dfTv = 0
    dfTh = 0
    dgTv = 0
    dgTh = 0
    coeff = 0
    Fx = 0
    Gz = 0
    Fx_min = 0.05
    Gz_min = 0.05
    sum_min = 10.0
    i = 0
    j = 0
    test = 0

    while abs(h) > err and abs(k) > err:
        fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
        go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
        rac1 = math.sqrt((Tv / Th) ** 2 + 1)
        rac2 = math.sqrt(((Tv - F - W) / Th) ** 2 + 1)
        rac3 = math.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
        rac4 = math.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
        dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
        dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
        dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
        dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
        coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
        h = coeff * (-dgTv * fo + dfTv * go)
        k = coeff * (dgTh * fo - dfTh * go)
        Th = Th + h
        Tv = Tv + k
        it += 1

        if min(Th, Tv) < 0:
            it = 0
            for i in range(0, math.ceil(Tmax), step):
                for j in range(0, math.ceil(Tmax), step):
                    Fx = f_x(float(i), float(j), Lo, EAo, W, F, s1, D)
                    if abs(Fx) < Fx_min:
                        Gz = f_z(float(i), float(j), Lo, EAo, W, F, s1, H)
                        if abs(Gz) < Gz_min:
                            if abs(Fx) + abs(Gz) < sum_min:
                                sum_min = min(abs(Fx) + abs(Gz), sum_min)
                                Th = float(i)
                                Tv = float(j)
                                if sum_min < 0.03:
                                    test = 1
                                    break
                if test:
                    break

        if it > 20:
            break

    return Th, Tv


def Tabmesh(d, E, Tmax, Lmax, Fo, q1, q2, q3, Csize):
    pas = 1
    ncol = int(np.ceil((Lmax + Csize) / pas - 1))
    nline = ncol + 1
    rastLosup = np.full((nline, ncol), np.nan, dtype=np.float)
    rastTh = np.copy(rastLosup)
    rastTv = np.copy(rastLosup)
    col = 0
    lig = 0
    Hmax = 0
    Tvo = 0.1 * Tmax
    Tho = 0.9 * Tmax
    Lsupo = 0.0
    D = 0.0
    H = 0.0
    Tvprec = Tvo
    Thprec = Tho
    Lsup_prec = Lsupo
    diag = 0.0
    Lo = 0.0
    W = 0.0
    F = 0.0
    Th = 0.0
    Tv = 0.0
    Tcalc = 0.0
    incr = 0.0
    signe = 0.0

    EAo = 0.25 * math.pi * (d * d) * E

    for D in range(5, int(Lmax + Csize), pas):
        lig = 0
        Hmax = int(math.ceil(math.sqrt(Lmax * Lmax - D * D) + Csize))
        Tvprec = Tvo
        Thprec = Tho
        Lsup_prec = Lsupo

        for H in range(0, Hmax, pas):
            diag = math.sqrt(H ** 2 + D ** 2)
            Lo = diag + Lsup_prec
            W = q1 * 9.81 * Lo
            F = 0.5 * ((q2 + (Lo - D) * q3) + Fo) * 9.81

            Th, Tv = newton_ThTv(Thprec, Tvprec, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2, 0.1)

            # Check if Th, Tv are OK
            if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                Th, Tv = newton_ThTv(D / diag * Tmax, Tmax * (H / diag + 0.01), H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                    Th, Tv, _ = find_ThTvTmax(Tmax, W, EAo, F, Lo * 0.5, D, H, Lo, 20)
                    Th, Tv = newton_ThTv(Th, Tv, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                    if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                        continue

            # Find Lo so that Tcalc does not exceed Tmax
            Tcalc = math.sqrt(Th ** 2 + Tv ** 2)

            if math.ceil(Lsup_prec * 0.1) >= 1:
                incr = 1.0
            elif math.ceil(Lsup_prec) >= 1:
                incr = 0.1
            elif math.ceil(Lsup_prec * 10.0) >= 1:
                incr = 0.01
            else:
                incr = 0.001

            signe = (Tcalc - Tmax) / abs(Tcalc - Tmax)

            # Incrementation
            while abs(Tcalc - Tmax) > 10.0:
                Lo += signe * incr
                F = 0.5 * ((q2 + (Lo - D) * q3) + Fo) * 9.81
                W = q1 * 9.81 * Lo
                Th, Tv = newton_ThTv(Th, Tv, H, D, Lo, W, Lo * 0.5, F, EAo, Tmax * 2)
                Tcalc = math.sqrt(Th ** 2 + Tv ** 2)

                if signe * (Tcalc - Tmax) < 0:
                    incr *= 0.1
                    signe *= -1.0

                if Lo > math.sqrt(H ** 2 + D ** 2) + 1000.0:
                    break

            if abs(f_x(Th, Tv, Lo, EAo, W, F, Lo * 0.5, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, Lo * 0.5, H)) > 0.01:
                continue

            Tvprec = Tv
            Thprec = Th
            Lsup_prec = Lo - diag
            rastLosup[lig, col] = Lsup_prec
            rastTh[lig, col] = Th
            rastTv[lig, col] = Tv

            if H == 0:
                Tvo = Tv
                Tho = Th
                Lsupo = Lsup_prec

            lig += 1

        col += 1

    return rastLosup, rastTh, rastTv


def frottement(Tension, coeff_frot, tan_avant, tan_apres):
    alpha = math.atan(tan_avant)
    beta = math.atan(tan_apres)
    gama = (beta + alpha) * 0.5
    num = math.tan(coeff_frot) * math.sin(gama - beta) + math.cos(beta - gama)
    denum = math.tan(coeff_frot) * math.sin(gama - alpha) + math.cos(alpha - gama)
    return Tension * num / denum


def frottement_inv(Tension, coeff_frot, tan_avant, tan_apres):
    alpha = math.atan(tan_avant)
    beta = math.atan(tan_apres)
    gama = (beta + alpha) * 0.5
    num = math.tan(coeff_frot) * math.sin(gama - beta) + math.cos(beta - gama)
    denum = math.tan(coeff_frot) * math.sin(gama - alpha) + math.cos(alpha - gama)
    return Tension * denum / num


def mainline(F, tan_mainline, tan_avant, tan_apres, sens=1):
    alpha = math.atan(abs(tan_avant))
    beta = math.atan(abs(tan_apres))
    lambdas = math.atan(abs(tan_mainline))
    
    Tchar = F * math.cos(lambdas) / (math.sin(alpha - lambdas) + math.sin(lambdas + sens * beta))
    
    return abs(Tchar)


def mainline2(F, tan_mainline, tan_avant, tan_apres, sens=1):
    alpha = math.atan(abs(tan_avant))
    beta = math.atan(abs(tan_apres))
    lambdas = math.atan(abs(tan_mainline))
    
    Tmain = F * (math.cos(beta) - math.cos(alpha)) / math.sin(alpha + sens * beta)
    Tchar = F * math.cos(lambdas) / (math.sin(alpha - lambdas) + math.sin(lambdas + sens * beta))
    
    return abs(Tchar), abs(Tmain)


def frottement_av(Tension, coeff_frot, tan_haut, tan_bas):
    a = math.atan(tan_haut)
    T = Tension
    b = math.atan(tan_bas)
    
    if b > a and coeff_frot != 0:
        g = (a + b) * 0.5
        tanphi = math.tan(coeff_frot)
        num = tanphi * math.sin(g) * math.cos(b) + math.cos(g) * math.cos(b) - math.sin(b) * tanphi * math.cos(g) + math.sin(b) * math.sin(g)
        denum = -tanphi * math.cos(g) * math.sin(a) + math.sin(g) * math.sin(a) + math.cos(a) * tanphi * math.sin(g) + math.cos(a) * math.cos(g)
        T = Tension * num / denum
    
    return T


def frottement_ap(Tension, coeff_frot, tan_haut, tan_bas, charge_posi):
    if coeff_frot == 0:
        T = Tension
    else:
        a = math.atan(tan_bas)
        b = math.atan(tan_haut)
        if charge_posi >= 0:
            if a < b:
                T = Tension
            else:
                g = (a + b) * 0.5
                tanphi = math.tan(coeff_frot)
                num = tanphi * math.sin(b - g) + math.cos(b - g)
                denum = tanphi * math.sin(a - g) + math.cos(a - g)
                T = Tension * num / denum
        else:
            g = (a + b) * 0.5
            tanphi = math.tan(coeff_frot)
            if a < b:
                num = tanphi * math.sin(g - b) + math.cos(b - g)
                denum = tanphi * math.sin(a + g) + math.cos(a + g)
                T = Tension * num / denum
            else:
                num = tanphi * math.sin(g - b) - math.cos(b + g)
                denum = tanphi * math.sin(a - g) + math.cos(a - g)
                T = Tension * num / denum
    return T


def check_droite(fact, H, D, Xup, Zup, Line, Hline_min, Hline_max, Tmax, q1, q2, q3, Fo, pg, pd, Dsupdep=0., Dsupend=0.):
    test = 1
    L = np.sqrt(H**2 + D**2)
    F = (0.5 * ((0.5 * L + Dsupdep) * q2 + (0.5 * L + Dsupend) * q3)) * 9.80665 + Fo
    fleche = 1.1 * (F * L / (4 * Tmax) + q1 * 9.80665 * L**2 / (8 * Tmax))
    
    for i in range(pg + 1, pd):
        droite = -fact * H / D * (Line[i, 0] - Xup) + Zup - Line[i, 1]
        if droite < Hline_min:
            test = 0
            break
        if droite - fleche > Hline_max:
            test = 0
            break
    
    return test


def H_mid(Lo, F, Th, Tv, Xup, Zup, fact, Alts, Hline_min, q1, EAo):
    W = q1 * 9.80665 * Lo
    s1 = Lo * 0.5
    xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s1)
    zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s1)
    ind = int(xcoord * 2)
    return zcoord - (Alts[ind] + Hline_min)


def slope_H_mid(Lo, F, Th, Tv, Xup, Zup, fact, q1, EAo):
    W = q1 * 9.80665 * Lo
    s1 = Lo * 0.5
    xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s1)
    zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s1)
    return np.arctan((Zup - zcoord) / abs(Xup - xcoord))


def check_Hlinemin(Alts, H, D, Lo, fact, Tho, Tvo, Xup, Zup, Fo, Tmax, Hline_min, Hline_max, q1, q2, q3, Csize, EAo, Dsupdep=0., Dsupend=0.):
    end = Lo - 10.
    test = 1
    Th, Tv = Tho, Tvo
    W = g * q1 * Lo
    s1 = Lo * 0.5
    h, k = 100.0, 100.0
    it = 0
    err = 1.0
    
    while s1 > 10.:
        F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo

        # Newton Th Tv
        it = 0
        while abs(h) > err and abs(k) > err:
            fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
            go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
            rac1 = np.sqrt((Tv / Th) ** 2 + 1)
            rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
            rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
            rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
            dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
            dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
            dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
            dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
            coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
            h = coeff * (-dgTv * fo + dfTv * go)
            k = coeff * (dgTh * fo - dfTh * go)
            Th += h
            Tv += k
            it += 1
            if it > 20:
                break

        if abs(f_x(Th, Tv, Lo, EAo, W, F, s1, D)) + abs(f_z(Th, Tv, Lo, EAo, W, F, s1, H)) > 0.03:
            test = 0
            break

        xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, s1, s1)
        zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, s1, s1)
        ind = int(xcoord * 2 + 0.5)
        Hmin = zcoord - (Alts[ind] + Hline_min)

        if Hmin < 0 or Hmin + Hline_min > Hline_max or np.sqrt(Th ** 2 + Tv ** 2) > (Tmax + 1000):
            test = 0
            break
        s1 -= Csize

    if test:
        Th, Tv = Tho, Tvo
        middle = min(int(Lo * 0.5 + Csize), end)
        s1 = middle
        while s1 < end:
            F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo

            # Newton Th Tv
            h, k = 100.0, 100.0
            it = 0
            while abs(h) > err and abs(k) > err:
                fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
                go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
                rac1 = np.sqrt((Tv / Th) ** 2 + 1)


def Find_Lomin(D, H, Xup, Zup, fact, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Hline_min, Hline_max, Csize, Dsupdep=0., Dsupend=0.):
    h = 100.0
    err = 1.0
    error = 50.
    k = 100.0
    it = 0
    test = 1
    diag = np.sqrt(D * D + H * H)
    col = int_max(np.ceil(D - 5) - 1, 0)
    line = np.ceil(H)
    Lsup = rastLosup[line, col]
    Th = rastTh[line, col]
    Tv = rastTv[line, col]
    Lo = Lsup + diag
    W = q1 * g * Lo
    s1 = 0.5 * Lo
    F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
    Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
    xcoord, zcoord, Hmin = 0., 0., 0.

    if np.isnan(Th) or np.isnan(Tv):
        test = 0

    if test:
        # Newton Th Tv
        while abs(h) > err and abs(k) > err:
            fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
            go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
            rac1 = np.sqrt((Tv / Th) ** 2 + 1)
            rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
            rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
            rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
            dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
            dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
            dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
            dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
            coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
            h = coeff * (-dgTv * fo + dfTv * go)
            k = coeff * (dgTh * fo - dfTh * go)
            Th += h
            Tv += k
            it += 1
            if double_min(Th, Tv) < 0:
                test = 0
                break
            if it > 20:
                test = 0
                break

        if test:
            # Find Lo so that Tcalc does not exceed Tmax
            Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
            incr = 0.01
            signe = (Tcalc - Tmax) / abs(Tcalc - Tmax)

            # Incrementation
            while abs(Tcalc - Tmax) > error and test:
                Lo += signe * incr
                W = q1 * g * Lo
                s1 = Lo * 0.5
                F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
                h = 100.0
                k = 100.0
                it = 0

                # Newton Th Tv
                while abs(h) > err and abs(k) > err:
                    fo = f_x(Th, Tv, Lo, EAo, W, F, s1, D)  # fo
                    go = f_z(Th, Tv, Lo, EAo, W, F, s1, H)  # go
                    rac1 = np.sqrt((Tv / Th) ** 2 + 1)
                    rac2 = np.sqrt(((Tv - F - W) / Th) ** 2 + 1)
                    rac3 = np.sqrt(((Tv - F - W * s1 / Lo) / Th) ** 2 + 1)
                    rac4 = np.sqrt(((Tv - W * s1 / Lo) / Th) ** 2 + 1)
                    dfTv = Lo / W * (1.0 / rac1 - 1.0 / rac2 + 1.0 / rac3 - 1.0 / rac4)
                    dfTh = df_dTh(Th, Tv, F, W, s1, Lo, EAo, rac1, rac2, rac3, rac4)
                    dgTv = Lo / EAo + Lo / (W * Th) * (Tv / rac1 - (Tv - F - W) / rac2 + (Tv - F - W * s1 / Lo) / rac3 - (Tv - W * s1 / Lo) / rac4)
                    dgTh = dg_dTh(Tv, Th, Lo, W, s1, F, rac1, rac2, rac3, rac4)
                    coeff = 1.0 / (dfTh * dgTv - dfTv * dgTh)
                    h = coeff * (-dgTv * fo + dfTv * go)
                    k = coeff * (dgTh * fo - dfTh * go)
                    Th += h
                    Tv += k
                    it += 1

                    if double_min(Th, Tv) < 0:
                        test = 0
                        break
                    if it > 20:
                        test = 0
                        break

                Tcalc = np.sqrt(Th ** 2 + Tv ** 2)
                if signe * (Tcalc - Tmax) < 0:
                    incr *= 0.1
                    signe *= -1.

                if abs(Lo - np.sqrt(H * H + D * D)) > 100.:
                    test = 0
                    break

    if test:
        F = (0.5 * ((s1 + Dsupdep) * q2 + ((Lo - s1) + Dsupend) * q3)) * g + Fo
        xcoord = Xup + fact * calcul_xs(Th, Tv, Lo, EAo, W, F, Lo * 0.5, Lo * 0.5)
        zcoord = Zup - calcul_zs(Th, Tv, Lo, EAo, W, F, Lo * 0.5, Lo * 0.5)
        ind = int(floor(xcoord * 2 + 0.5))
        Hmin = zcoord - (Alts[ind] + Hline_min)
        if Hmin >= 0:
            Hmin = check_Hlinemin(Alts, H, D, Lo, fact, Th, Tv, Xup, Zup, Fo, Tmax, Hline_min, Hline_max, q1, q2, q3, Csize, EAo, Dsupdep, Dsupend)
            if Hmin < 0:
                test = 0
    else:
        test = 0

    return test, Lo, Th, Tv, Tcalc, F


def test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep=0., slope_prev=-9999.):
    test = 0
    D = Line[posi, 0] - Line[pg, 0]
    H = np.abs(Line[pg, 1] + Hg - (Line[posi, 1] + Hd))
    Xup, Zup = 0, 0
    fact = 0
    diag, slope, Lo, Th, Tv, F, Tcalc = 0, 0, 0, 0, 0, 0, 0

    if Line[pg, 1] + Hg >= Line[posi, 1] + Hd:
        Xup, Zup = Line[pg, 0], Line[pg, 1] + Hg
        fact = 1.
    else:
        Xup, Zup = Line[posi, 0], Line[posi, 1] + Hd
        fact = -1.

    if check_droite(fact, H, D, Xup, Zup, Line, Hline_min, Hline_max, Tmax, q1, q2, q3, Fo, pg, posi, Dsupdep):
        diag = np.sqrt(H * H + D * D)
        slope = -1 * fact * np.arctan(H / D)

        if slope < slope_min or slope > slope_max:
            test = 0
        else:
            # Check slopes around intermediate support
            if slope_prev > -9999 and (np.abs(slope - slope_prev) >= angle_intsup or (slope * slope_prev < 0 and np.abs(slope - slope_prev) >= 0.1)):
                test = 0
            else:
                test, Lo, Th, Tv, Tcalc, F = Find_Lomin(D, H, Xup, Zup, fact, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Hline_min, Hline_max, Csize, Dsupdep)

    return test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F


def get_Tabis(Tab, lineTab, nbconfig, intsup, indmax):
    i, j = 0, 0
    col = (intsup - 1) * 14 + 13
    colH = (intsup - 1) * 14 + 12
    idmax = 0
    idmax2 = indmax + 1
    idline = 0
    linemax = min(lineTab, nbconfig)
    Tabis = np.zeros((linemax, Tab.shape[1]), dtype=np.float)

    Hmin = 100

    while i < linemax:
        for j in range(0, lineTab):
            if idmax <= Tab[j, col] < idmax2:
                idmax = np.ceil(Tab[j, col])
                if Tab[j, colH] < Hmin:
                    Hmin = Tab[j, colH]
                    idline = j

        Tabis[i] = Tab[idline]
        i += 1
        idmax2 = idmax
        idmax = 0
        Hmin = 100

    return Tabis


def get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax):
    i, j = 0, 0
    col = (intsup - 1) * 15 + 13
    colH = (intsup - 1) * 15 + 12
    idmax = 0
    idmax2 = indmax + 1
    idline = 0
    linemax = min(lineTab, nbconfig)
    Tabis = np.zeros((linemax, Tab.shape[1]), dtype=np.float)

    Hmin = 100

    while i < linemax:
        for j in range(0, lineTab):
            if idmax <= Tab[j, col] < idmax2:
                idmax = np.ceil(Tab[j, col])
                if Tab[j, colH] < Hmin:
                    Hmin = Tab[j, colH]
                    idline = j

        Tabis[i] = Tab[idline]
        i += 1
        idmax2 = idmax
        idmax = 0
        Hmin = 100

    return Tabis


def optpyl_up(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
              angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
              slope_max, test_hfor, nbconfig=10):
    indmax = Line.shape[0] - 1
    test = 0
    D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    # Begin without intermediate support
    Hd = Line[indmax, 7] if test_hfor else Hend
    while Hd > 1:
        test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hd,
                                                                                 Hline_min, Hline_max,
                                                                                 slope_min, slope_max, Alts, Fo, Tmax, q1,
                                                                                 q2, q3, EAo, rastLosup, rastTh, rastTv,
                                                                                 Csize, angle_intsup, 0, slope_prev=-9999)
        if test:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
                Th * Th + (Tv - F - Lo * g * q1) ** 2)
            Span[0, 14], Span[0, 15] = Hd, indmax
            test = 1
        else:
            break
        Hd -= 1

    # Cut the line if no intermediate support allowed
    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hd = Line[posi, 7] if test_hfor else Hend
            while Hd > 1:
                test, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd,
                                                                                         Hline_min, Hline_max,
                                                                                         slope_min, slope_max, Alts, Fo,
                                                                                         Tmax, q1, q2, q3, EAo, rastLosup,
                                                                                         rastTh, rastTv, Csize,
                                                                                         angle_intsup, 0, slope_prev=-9999)
                if test:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, np.sqrt(Th * Th + Tv * Tv), np.sqrt(
                        Th * Th + (Tv - F - Lo * g * q1) ** 2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                else:
                    break
                Hd -= 1
            if test:
                break

    # Start intermediate support position optimization
    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * nbconfig * 100, 14 * (sup_max + 1)), dtype=np.float)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float)
        lineTabis = 0
        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = np.ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -14):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]
                for posi in range(indmaxmulti, indmin, -1):
                    if test_hfor:
                        Hdmax = Line[indmax, 7]
                    else:
                        Hdmax = Hend
                    Hd = 1
                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                            Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo,
                            newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                        if test1:
                            Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                                Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1
                            if test_hfor:
                                Hdmax2 = Line[indmax, 7]
                            else:
                                Hdmax2 = Hend
                            Hd2 = 1
                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                    Line, posi, indmax, Hd, Hd2, Hline_min, Hline_max, slope_min, slope_max,
                                    Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize,
                                    angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                                        Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break
                                Hd2 += 1
                            if best:
                                break
                        Hd += 1
                    if best:
                        break
                if best:
                    break
            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2
                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0
                    break
                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]
                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * nbconfig * 100, 14 * (sup_max + 1)),
                                         dtype=np.float)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break
    # Cut the line at the farthest position if sup_max > 0
    if not best and test:
        lineTab = 0
        for p in range(0, nblineTabis):
            lineTabis = p
            col = (intsup - 2) * 14
            pg = np.ceil(Tabis[p, 13 + col])
            Hg = Tabis[p, 12 + col]
            indminmulti = pg
            diff = 0.
            while diff < double_max(Csize, LminSpan):
                indminmulti += 1
                diff = Line[indminmulti, 0] - Line[pg, 0]
            newTmax = Tabis[p, 10 + col]
            Dsupdep = 0
            for c in range(col + 2, 1, -14):
                Dsupdep += Tabis[p, c]
            slope_prev = Tabis[p, 3 + col]
            for posi in range(indmax - 1, indminmulti - 1, -1):
                if test_hfor:
                    Hdmax = Line[indmax, 7]
                else:
                    Hdmax = Hend
                Hd = 1
                while Hd <= Hdmax:
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                        Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1,
                        q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                    if test1:
                        Tdown = np.sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, np.sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break
                    Hd += 1
        if lineTab == 0:
            intsup -= 2
            lineTab = 0
            Tab[lineTab] = Tabis[0]
        else:
            Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
            lineTab = 0
            intsup = sup_max

    # Save Span characteristics
    for i in range(0, intsup + 1):
        col = i * 14
        Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up_NoH(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                  angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                  slope_max, test_hfor, nbconfig=10):
    """
    Cable machine en haut
    Optimise le placement des pylones intermediaire sans bouger la hauteur de fixation du cable porteur pour chaque pylone sur un profil
    """

    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hd = Line[posi, 7] if test_hfor else Hend
            test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd,
                                                                                    Hline_min, Hline_max, slope_min,
                                                                                    slope_max, Alts, Fo, Tmax, q1, q2, q3,
                                                                                    EAo, rastLosup, rastTh, rastTv, Csize,
                                                                                    angle_intsup, 0, slope_prev=-9999)
            if test0:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hd, posi
                test = 1

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -14):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hd = Line[posi, 7]
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, 0,
                                                                                              slope_prev=-9999)
                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1

                        if test_hfor:
                            Hd2 = Line[indmax, 7]
                        else:
                            Hd2 = Hend

                        test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Hd2,
                                                                                                  Hline_min, Hline_max,
                                                                                                  slope_min, slope_max,
                                                                                                  Alts, Fo, Tdown, q1, q2,
                                                                                                  q3, EAo, rastLosup, rastTh,
                                                                                                  rastTv, Csize,
                                                                                                  angle_intsup,
                                                                                                  diag + Dsupdep, slope)
                        if test2:
                            best = 1
                            Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                            Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                                Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                            break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down_init(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                     angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                     slope_max, test_hfor, nbconfig=5):
    """
    Cable machine en bas
    Permet de recuperer la partie de profil ou il est possible de tendre un cable (avec hauteur de cable porteur variable)
    """

    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    while test and Hend > 1:
        Hend -= 1
        test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                                Hline_min, Hline_max, slope_min,
                                                                                slope_max, Alts, Fo, Tmax, q1, q2, q3,
                                                                                EAo, rastLosup, rastTh, rastTv, Csize,
                                                                                angle_intsup, 0, slope_prev=-9999)
        if test0:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
            Span[0, 14], Span[0, 15] = Hend, indmax
            test = 1
        else:
            break

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hdmax = Line[posi, 7]
            Hd = ceil(Hline_min)
            while Hd <= Hdmax:
                test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
                if test1:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                    break
                Hd += 1
            if test:
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hd = 1

                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                        if test1:
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1

                            Hdmax2 = Line[indmax, 7] if test_hfor else Hend
                            Hd2 = 1

                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Hd2, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break

                                Hd2 += 1

                            if best:
                                break

                        Hd += 1

                    if best:
                        break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down_init_NoH(Line, Alts, Span, Htower , Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                         angle_intsup, EAo,  sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                         slope_max, test_hfor, nbconfig=5):
    """
    Cable machine en bas
    Permet de recuperer la partie de profil ou il est possible de tendre un cable (avec hauteur de cable porteur fixe)
    """
    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Hend,
                                                                            Hline_min, Hline_max, slope_min, slope_max,
                                                                            Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                            rastTh, rastTv, Csize, angle_intsup, 0,
                                                                            slope_prev=-9999)

    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(
            Th * Th + (Tv - F - Lo * g * q1) ** 2)
        Span[0, 14], Span[0, 15] = Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            if test_hfor:
                Hd = Line[posi, 7]
            else:
                Hd = Hend
            test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Htower, Hd, Hline_min,
                                                                                    Hline_max, slope_min, slope_max, Alts,
                                                                                    Fo, Tmax, q1, q2, q3, EAo, rastLosup,
                                                                                    rastTh, rastTv, Csize, angle_intsup, 0,
                                                                                    slope_prev=-9999)
            if test1:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(
                    Th * Th + (Tv - F - Lo * g * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hd, posi
                test = 1
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        indminmulti = 1
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 14 * (sup_max + 1)), dtype=np.float)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 14 * (sup_max + 1)), dtype=np.float)
        lineTabis = 0
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = indminmulti - 1

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 14
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hd = 1

                    while Hd <= Hdmax:
                        test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                                Hline_min, Hline_max,
                                                                                                slope_min, slope_max, Alts,
                                                                                                Fo, newTmax, q1, q2, q3,
                                                                                                EAo, rastLosup, rastTh,
                                                                                                rastTv, Csize,
                                                                                                angle_intsup, 0,
                                                                                                slope_prev=-9999)

                        if test1:
                            Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                            Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                            lineTab += 1

                            Hdmax2 = Line[indmax, 7] if test_hfor else Hend
                            Hd2 = 1

                            while Hd2 <= Hdmax2:
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi,
                                                                                                      indmax, Hd, Hd2,
                                                                                                      Hline_min,
                                                                                                      Hline_max,
                                                                                                      slope_min,
                                                                                                      slope_max, Alts,
                                                                                                      Fo, Tmax, q1,
                                                                                                      q2, q3, EAo,
                                                                                                      rastLosup, rastTh,
                                                                                                      rastTv, Csize,
                                                                                                      angle_intsup, 0,
                                                                                                      slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 14] = Tab[lineTab - 1, 0:intsup * 14]
                                    Tab[lineTab, intsup * 14:(intsup * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd2, indmax
                                    break

                                Hd2 += 1

                            if best:
                                break

                        Hd += 1

                    if best:
                        break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 14 * (sup_max + 1)),
                                         dtype=np.float)
                    intsup += 1
                    lineTab = 0

                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 14
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 12 + col]
                indminmulti = pg
                diff = 0.

                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -14):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    Hd = Line[indmax, 7] if test_hfor else Hend
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd,
                                                                                              Hline_min, Hline_max,
                                                                                              slope_min, slope_max, Alts,
                                                                                              Fo, newTmax, q1, q2, q3,
                                                                                              EAo, rastLosup, rastTh,
                                                                                              rastTv, Csize,
                                                                                              angle_intsup, Dsupdep,
                                                                                              slope_prev)
                    if test1:
                        Tab[lineTab, 0:(intsup - 1) * 14] = Tabis[lineTabis, 0:(intsup - 1) * 14]
                        Tab[lineTab, (intsup - 1) * 14:((intsup - 1) * 14 + 14)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(
                            Th * Th + (Tv - F - Lo * g * q1) ** 2), Hd, posi
                        lineTab += 1
                        break

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]

            else:
                Tab = get_Tabis(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 14
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up2(Line, Alts, Span, Htower,  Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
               angle_intsup, EAo,  sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
               slope_max, test_hfor, nbconfig=10):
    """
    Cable machine en bas
    Optimise le placement des pylones intermediaire et la hauteur de fixation du cable porteur pour chaque pylone sur un profil
        
    """
    indmax = Line.shape[0] - 1
    test = 0
    test0 = test1 = test2 = 0
    indminmulti = indmaxmulti = pg = posi = lineTab = lineTabis = 0
    intsup = best = nblineTabis = indmin = 0
    Hg = Hd = Tdown = Hgmax = Hdmax = Hginit = 0
    slope_prev = Dsupdep = newTmax = diff = 0.0
    
    # Begin without intermediate support
    if test_hfor:
        Hg = Line[indmax, 7]
    else:
        Hg = Hend
    while Hg > 1:
        test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
            Line, 0, indmax, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
        if test0:
            Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
            Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
            Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th*Th + Tv*Tv), sqrt(Th*Th + (Tv - F - Lo*g*q1)**2)
            Span[0, 14], Span[0, 15] = Hg, indmax
            test = 1
        else:
            break
        Hg -= 1

    # End without intermediate support
    # Start Cut the line if no intermediate support allowed
    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.
        while diff < double_max(Csize, LminSpan):
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]
        for posi in range(indmax - 1, indminmulti - 1, -1):
            if test_hfor:
                Hd = Line[posi, 7]
            else:
                Hd = Hend
            while Hd > 1:
                test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                    Line, 0, posi, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
                if test0:
                    Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                    Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                    Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th*Th + Tv*Tv), sqrt(Th*Th + (Tv - F - Lo*g*q1)**2)
                    Span[0, 14], Span[0, 15] = Hd, posi
                    test = 1
                else:
                    break
                Hd -= 1
            if test:
                break

    # End Cut the line if no intermediate support allowed
    # Start intermediate support position optimization
    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.
        while diff < double_max(Csize, LminSpan) and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 15 * (sup_max + 1)), dtype=np.float)
        lineTabis = 0

        test = 1
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hg = Htower
        best = 0
        slope_prev = -9999
        indmin = 0

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 15
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    Dsupdep = 0
                    Hg = Tabis[p, 12 + col]
                    for c in range(col + 2, 1, -15):
                        Dsupdep += Tabis[p, c]
                    slope_prev = Tabis[p, 3 + col]
                for posi in range(indmaxmulti, indmin, -1):
                    Hdmax = Line[posi, 7]
                    Hg = Hginit
                    while Hg <= Hgmax:
                        Hd = ceil(Hline_min)
                        while Hd <= Hdmax:
                            test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                            if test1:
                                Tdown = sqrt(Th*Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                                Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                                Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hg, posi, Hd
                                lineTab += 1
                                test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                                    Line, posi, indmax, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)
                                if test2:
                                    best = 1
                                    Tab[lineTab, 0:intsup * 15] = Tab[lineTab - 1, 0:intsup * 15]
                                    Tab[lineTab, intsup * 15:(intsup * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hd, indmax, Htower
                                    break
                            Hd += 1
                        if best:
                            break
                        Hg += 1
                    if best:
                        break
                if best:
                    break
            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2
                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0
                    break
                Tabis = get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]
                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * Tabis.shape[0] * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0
            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 15
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 14 + col]
                indminmulti = pg
                diff = 0.
                while diff < double_max(Csize, LminSpan):
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]
                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0
                for c in range(col + 2, 1, -15):
                    Dsupdep += Tabis[p, c]
                slope_prev = Tabis[p, 3 + col]
                for posi in range(indmax - 1, indminmulti - 1, -1):
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(
                        Line, pg, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)
                    if test1:
                        Tdown = sqrt(Th*Th + (Tv - q1 * g * Lo) * (Tv - q1 * g * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th*Th + (Tv - F - Lo * g * q1)**2), Hg, posi, Htower
                        lineTab += 1

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]
            else:
                Tab = get_Tabis2(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 15
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Up2_NoH(Line, Alts, Span, Htower, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize,
                    angle_intsup, EAo, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min,
                      slope_max, test_hfor, nbconfig=10):
    indmax = Line.shape[0] - 1
    test = 0
    test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, indmax, Htower, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
    if test0:
        Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
        Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
        Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2)
        Span[0, 14], Span[0, 15] = Line[indmax, 7] if test_hfor else Hend, indmax
        test = 1

    if not test and sup_max == 0:
        indminmulti = 0
        diff = 0.0
        while diff < Csize * LminSpan:
            indminmulti += 1
            diff = Line[indminmulti, 0] - Line[0, 0]

        for posi in range(indmax - 1, indminmulti - 1, -1):
            Hg = Line[posi, 7] if test_hfor else Hend
            test0, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, 0, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, 0, slope_prev=-9999)
            if test0:
                Span[0, 0], Span[0, 1], Span[0, 2], Span[0, 3] = D, H, diag, slope
                Span[0, 4], Span[0, 5], Span[0, 6], Span[0, 7] = fact, Xup, Zup, Lo
                Span[0, 8], Span[0, 9], Span[0, 10], Span[0, 11] = Th, Tv, sqrt(Th * Th + Tv * Tv), sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2)
                Span[0, 14], Span[0, 15] = Hg, posi
                test = 1
                break

    if not test and sup_max > 0:
        indmaxmulti = indmax
        diff = 0.0
        while diff < Csize * LminSpan and indmaxmulti > 0:
            indmaxmulti -= 1
            diff = Line[indmax, 0] - Line[indmaxmulti, 0]
        if indmaxmulti == 0:
            test = 1

    if not test and sup_max > 0:
        Tab = -9999 * np.ones((indmaxmulti * 100 * nbconfig, 15 * (sup_max + 1)), dtype=np.float)
        lineTab = 0
        Tabis = -9999 * np.ones((1, 15 * (sup_max + 1)), dtype=np.float)
        lineTabis = 0
        test = 1
        intsup = 1
        newTmax = Tmax
        Dsupdep = 0
        pg = 0
        Hginit = Line[0, 7] if test_hfor else Hend
        best = 0
        slope_prev = -9999
        indmin = 0

        while intsup <= sup_max and not best:
            for p in range(0, nblineTabis):
                if intsup > 1:
                    lineTabis = p
                    col = (intsup - 2) * 15
                    indmin = ceil(Tabis[p, 13 + col])
                    pg = indmin
                    newTmax = Tabis[p, 10 + col]
                    Dsupdep = 0
                    Hginit = Tabis[p, 14 + col]

                    for c in range(col + 2, 1, -15):
                        Dsupdep += Tabis[p, c]

                    slope_prev = Tabis[p, 3 + col]

                for posi in range(indmaxmulti, indmin, -1):
                    Hd = Line[posi, 7]
                    Hg = Hginit
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Hd, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * 9.81 * Lo) * (Tv - q1 * 9.81 * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hg, posi, Hd
                        lineTab += 1
                        test2, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, posi, indmax, Hd, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, Tdown, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, diag + Dsupdep, slope)

                        if test2:
                            best = 1
                            Tab[lineTab, 0:intsup * 15] = Tab[lineTab - 1, 0:intsup * 15]
                            Tab[lineTab, intsup * 15:(intsup * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hd, indmax, Htower
                            break

                if best:
                    break

            if not best:
                if lineTab == 0:
                    test = 0
                    intsup -= 2

                    if Tabis[0, 0] > 0:
                        Tab[lineTab] = Tabis[0]
                    else:
                        Tab[lineTab] *= 0

                    break

                Tabis = get_Tabis2(Tab, lineTab, nbconfig, intsup, indmax)
                nblineTabis = Tabis.shape[0]

                if nblineTabis > 0:
                    Tab = -9999 * np.ones((indmaxmulti * nbconfig * Tabis.shape[0] * 100, 15 * (sup_max + 1)), dtype=np.float)
                    intsup += 1
                    lineTab = 0
                else:
                    test = 0
                    intsup = -2
                    break

        if not best and test:
            lineTab = 0

            for p in range(0, nblineTabis):
                lineTabis = p
                col = (intsup - 2) * 15
                pg = ceil(Tabis[p, 13 + col])
                Hg = Tabis[p, 14 + col]
                indminmulti = pg
                diff = 0.0

                while diff < Csize * LminSpan:
                    indminmulti += 1
                    diff = Line[indminmulti, 0] - Line[pg, 0]

                newTmax = Tabis[p, 10 + col]
                Dsupdep = 0

                for c in range(col + 2, 1, -15):
                    Dsupdep += Tabis[p, c]

                slope_prev = Tabis[p, 3 + col]

                for posi in range(indmax - 1, indminmulti - 1, -1):
                    test1, D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, F = test_Span(Line, pg, posi, Hg, Htower, Hline_min, Hline_max, slope_min, slope_max, Alts, Fo, newTmax, q1, q2, q3, EAo, rastLosup, rastTh, rastTv, Csize, angle_intsup, Dsupdep, slope_prev)

                    if test1:
                        Tdown = sqrt(Th * Th + (Tv - q1 * 9.81 * Lo) * (Tv - q1 * 9.81 * Lo))
                        Tab[lineTab, 0:(intsup - 1) * 15] = Tabis[lineTabis, 0:(intsup - 1) * 15]
                        Tab[lineTab, (intsup - 1) * 15:((intsup - 1) * 15 + 15)] = D, H, diag, slope, fact, Xup, Zup, Lo, Th, Tv, Tcalc, sqrt(Th * Th + (Tv - F - Lo * 9.81 * q1) ** 2), Hg, posi, Htower
                        lineTab += 1

            if lineTab == 0:
                intsup -= 2
                lineTab = 0
                Tab[lineTab] = Tabis[0]
            else:
                Tab = get_Tabis2(Tab, lineTab, 1, intsup, indmax)
                lineTab = 0
                intsup = sup_max

        for i in range(0, intsup + 1):
            col = i * 15
            Span[i, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15]] = Tab[lineTab, col:col + 14]

    return Span


def OptPyl_Down(Line, Alts, Span, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig=5):
    indmax = Line.shape[0] - 1
    i = -1
    j = sup_max
    Dmax = Line[indmax, 0]
    test = 0
    Spanbis = np.zeros_like(Span)

    while not test:
        indmax = Line.shape[0] - 1
        if indmax == 1:
            test = 0
            break

        Span = OptPyl_Up2(Line, Alts, Span * 0, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig)

        if np.max(Span[:, 15]) == indmax:
            test = 1
            break
        else:
            Line = Line[1:]

    if test:
        for j in range(sup_max, -1, -1):
            if Span[j, 0] > 0:
                break

        i = -1

        while j > -1:
            i += 1
            Spanbis[i] = Span[j]
            Spanbis[i, 5] = Dmax - Span[j, 5]
            Spanbis[i, 15] = indmax - Span[j - 1, 15]
            j -= 1

        Spanbis[i, 15] = indmax
        Spanbis[:, 4] *= -1

    return Spanbis


def OptPyl_Down_NoH(Line, Alts, Span, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig=5):
    indmax = Line.shape[0] - 1
    i = -1
    j = sup_max
    Dmax = Line[indmax, 0]
    test = 0
    Spanbis = np.zeros_like(Span)

    while not test:
        indmax = Line.shape[0] - 1
        if indmax == 1:
            test = 0
            break

        Span = OptPyl_Up2_NoH(Line, Alts, Span * 0, Htower, Hintsup, Hend, q1, q2, q3, Fo, Hline_min, Hline_max, Csize, angle_intsup, EAo, E, d, sup_max, rastLosup, rastTh, rastTv, Tmax, LminSpan, slope_min, slope_max, Lmax, test_hfor, nbconfig)

        if np.max(Span[:, 15]) == indmax:
            test = 1
            break
        else:
            Line = Line[1:]

    if test:
        for j in range(sup_max, -1, -1):
            if Span[j, 0] > 0:
                break

        i = -1

        while j > -1:
            i += 1
            Spanbis[i] = Span[j]
            Spanbis[i, 5] = Dmax - Span[j, 5]
            Spanbis[i, 15] = indmax - Span[j - 1, 15]
            j -= 1

        Spanbis[i, 15] = indmax
        Spanbis[:, 4] *= -1

    return Spanbis


def mask_3(matrice, nbpixel_bis):
    nline = matrice.shape[0]
    ncol = matrice.shape[1]
    top = nline
    bottom = 0
    left = ncol
    right = 0

    for y in range(nline):
        for x in range(ncol):
            if matrice[y, x] == 1:
                if y < top:
                    top = y
                if y > bottom:
                    bottom = y
                if x < left:
                    left = x
                if x > right:
                    right = x

    top = max(0, top - nbpixel_bis)
    bottom = min(nline, bottom + 1 + nbpixel_bis)
    left = max(0, left - nbpixel_bis)
    right = min(ncol, right + 1 + nbpixel_bis)

    return top, bottom, left, right


def Line_emprise(zone, direction, Buffer_cote, Ligne_perpendic):
    zone_ok = zone.copy()
    h3 = direction * (1 + 2 * Buffer_cote)
    b3 = h3 + (1 + 2 * Buffer_cote)
    Mask = Ligne_perpendic[h3:b3] * 1
    nline, ncol = zone.shape

    for L in range(nline):
        for C in range(ncol):
            if zone[L, C] == 1:
                h = max(0, L - Buffer_cote)
                buf_h = 0

                if h == 0:
                    buf_h = Buffer_cote - L

                b = min(nline, L + 1 + Buffer_cote)
                l = max(0, C - Buffer_cote)
                buf_l = 0

                if l == 0:
                    buf_l = Buffer_cote - C

                r = min(ncol, C + 1 + Buffer_cote)
                y = h
                x = l
                y1 = buf_h

                for y in range(h, b):
                    x1 = buf_l

                    for x in range(l, r):
                        zone_ok[y, x] = min((zone_ok[y, x] + Mask[y1, x1]), 1)
                        x1 += 1

                    y1 += 1

    return zone_ok


def concatenate_int(zone, h, b, l, r, Mask):
    y1 = 0

    for y in range(h, b):
        x1 = 0

        for x in range(l, r):
            zone[y, x] = zone[y, x] + Mask[y1, x1]
            x1 += 1

        y1 += 1

    return zone


def concatenate_float(zone, h, b, l, r, Mask):
    y1 = 0

    for y in range(h, b):
        x1 = 0

        for x in range(l, r):
            zone[y, x] = zone[y, x] + Mask[y1, x1]
            x1 += 1

        y1 += 1

    return zone


def skid_debusq_RF(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                   coeff, orig, Pmax_up, Pmax_down, damont, daval,
                   nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_des = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)
                coef_l = (Alt_pixel - Alt_RF) / Hdist

                if Out_distance[Y, X] > dist:
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_des[Y, X] = pixel
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_des[coordY, coordX] = pixel

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_des[Y, X] = -9999

    return Out_distance, L_des


def skid_debusq_Piste(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                      coeff, orig, Pmax_up, Pmax_down, damont, daval,
                      nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_des = np.zeros((nrows, ncols), dtype=np.int32)
    Dpis = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0
        dpist = Lien_RF[pixel, 2]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)
                coef_l = (Alt_pixel - Alt_RF) / Hdist

                if Out_distance[Y, X] > dist:
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_des[Y, X] = pixel
                    Dpis[Y, X] = int(dpist + 0.5)
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_des[coordY, coordX] = pixel
            Dpis[coordY, coordX] = int(dpist + 0.5)

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_des[Y, X] = -9999
                Dpis[Y, X] = -9999

    return Out_distance, L_des, Dpis


def skid_debusq_contour(Lien_RF, MNT, Row_line, Col_line, D_line, Nbpix_line,
                        coeff, orig, Pmax_up, Pmax_down, damont, daval,
                        nrows, ncols, Zone_ok):
    Max_distance = 100000
    dmin = min(damont, daval)
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_RF = np.zeros((nrows, ncols), dtype=np.int32)
    L_Piste = np.zeros((nrows, ncols), dtype=np.int32)
    Dpis = np.zeros((nrows, ncols), dtype=np.int32)
    Dfor = np.zeros((nrows, ncols), dtype=np.int32)

    for pixel in range(1, Lien_RF.shape[0]):
        coordY, coordX = Lien_RF[pixel, 0], Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX] 
        testRF = 0
        lienRF, lienPiste = Lien_RF[pixel, 2], Lien_RF[pixel, 3]
        dpist, dfor = Lien_RF[pixel, 5], Lien_RF[pixel, 4]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y, X = coordY + Row_line[az, i], coordX + Col_line[az, i]

                if not (0 <= Y < nrows) or not (0 <= X < ncols) or not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                coef_l = (Alt_pixel - Alt_RF) / Hdist
                dist = sqrt(Hdist**2 + (Alt_pixel - Alt_RF)**2)

                if (Out_distance[Y, X] + Dpis[Y, X] + Dfor[Y, X]) > (dist + dpist + dfor):
                    j = 1
                    test = 1

                    for j in range(1, i):
                        Hline = (Alt_RF + coef_l * D_line[az, j] + 10.) - MNT[coordY + Row_line[az, j], coordX + Col_line[az, j]]

                        if Hline < 0 or Hline > 30.:
                            test = 0
                            break

                    if not test:
                        break

                    if dist > dmin:
                        if coef_l <= Pmax_down:
                            dmax = daval
                        elif coef_l > Pmax_up:
                            dmax = damont
                        else:
                            dmax = orig / (1 - coeff * coef_l / sqrt(1 + coef_l**2))

                        if dist > dmax:
                            break

                    Out_distance[Y, X] = int(dist + 0.5)
                    L_RF[Y, X] = lienRF 
                    L_Piste[Y, X] = lienPiste
                    Dpis[Y, X] = int(dpist + 0.5)
                    Dfor[Y, X] = int(dfor + 0.5)
                    testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            L_RF[coordY, coordX] = lienRF 
            L_Piste[coordY, coordX] = lienPiste
            Dpis[coordY, coordX] = int(dpist + 0.5)
            Dfor[coordY, coordX] = int(dfor + 0.5)

    for Y in range(nrows):
        for X in range(ncols):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_RF[Y, X] = -9999
                L_Piste[Y, X] = -9999
                Dpis[Y, X] = -9999
                Dfor[Y, X] = -9999

    return Out_distance, L_RF, L_Piste, Dpis, Dfor


def seek_ind(Tab, x, y):
    nline = Tab.shape[0]
    y1 = 1
    ind = 1

    while y1 < nline:
        if Tab[y1, 0] == y:
            if Tab[y1, 1] == x:
                ind = y1
                break
        y1 += 1

    return ind


def seek_ind_i(Tab, x, y):
    nline = Tab.shape[0]
    y1 = 1
    ind = 1

    while y1 < nline:
        if Tab[y1, 0] == y:
            if Tab[y1, 1] == x:
                ind = y1
                break
        y1 += 1

    return ind


def Link_RF_res_pub(Tab_res_pub, cost_rast, RF, Res_pub, Link_RF, Csize, Max_distance=100000):
    nline, ncol = cost_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    dist_ac = Csize
    nb_pixel_res_pub = Tab_res_pub.shape[0]
    nb_pixel_RF = Link_RF.shape[0]
    pixel = 1

    while pixel < nb_pixel_res_pub:
        y1 = Tab_res_pub[pixel, 0]
        x1 = Tab_res_pub[pixel, 1]
        if RF[y1, x1] == 1:
            ind = seek_ind(Link_RF, x1, y1)
            Link_RF[ind, 2] = 0
            Link_RF[ind, 3] = pixel
            Link_RF[ind, 4] = 1
        pixel += 1

    while dist_ac <= Max_distance:
        test = 0
        pixel = 1
        while pixel < nb_pixel_RF:
            if Link_RF[pixel, 4] == 1:
                test = 1
                y1 = int(Link_RF[pixel, 0])
                x1 = int(Link_RF[pixel, 1])
                Link_RF[pixel, 4] = 2
                dist_ac = Link_RF[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if RF[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_RF, x, y)
                            if Link_RF[ind, 2] > Dist:
                                Link_RF[ind, 2] = Dist
                                Link_RF[ind, 3] = Link_RF[pixel, 3]
                                Link_RF[ind, 4] = 1
            pixel += 1

        if test == 0:
            break

    test = 0
    pixel = 1

    while pixel < nb_pixel_RF:
        if Link_RF[pixel, 2] == 100001:
            y1 = int(Link_RF[pixel, 0])
            x1 = int(Link_RF[pixel, 1])
            for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                    if Res_pub[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        ind = seek_ind_i(Tab_res_pub, x, y)
                        Link_RF[pixel, 2] = Dist
                        Link_RF[pixel, 3] = ind
                        Link_RF[pixel, 4] = 1
                        test = 1
        pixel += 1

    while test:
        test = 0
        pixel = 1
        while pixel < nb_pixel_RF:
            if Link_RF[pixel, 4] == 1:
                test = 1
                y1 = int(Link_RF[pixel, 0])
                x1 = int(Link_RF[pixel, 1])
                Link_RF[pixel, 4] = 2
                dist_ac = Link_RF[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if RF[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_RF, x, y)
                            if Link_RF[ind, 2] > Dist:
                                Link_RF[ind, 2] = Dist
                                Link_RF[ind, 3] = Link_RF[pixel, 3]
                                Link_RF[ind, 4] = 1
            pixel += 1

    return Link_RF[:, 0:-1]


def Link_tracks_res_pub(Tab_res_pub, Link_RF, cost_rast, Piste, RF, Res_Pub, Link_Piste, Csize, Max_distance=100000):
    nline, ncol = cost_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    dist_ac = Csize
    nb_pixel_res_pub = Tab_res_pub.shape[0]
    nb_pixel_RF = Link_RF.shape[0]
    nb_pixel_Piste = Link_Piste.shape[0]
    pixel = 1

    # Initialisation du raster depuis reseau public
    while pixel < nb_pixel_res_pub:
        y1 = Tab_res_pub[pixel, 0]
        x1 = Tab_res_pub[pixel, 1]
        if Piste[y1, x1] == 1:
            ind = seek_ind(Link_Piste, x1, y1)
            Link_Piste[ind, 2] = 0
            Link_Piste[ind, 3] = 0
            Link_Piste[ind, 4] = -9999
            Link_Piste[ind, 5] = pixel
            Link_Piste[ind, 6] = 1
        pixel += 1

    pixel = 1
    # Initialisation du raster depuis route_for
    while pixel < nb_pixel_RF:
        y1 = Link_RF[pixel, 0]
        x1 = Link_RF[pixel, 1]
        if Piste[y1, x1] == 1:
            ind = seek_ind(Link_Piste, x1, y1)
            Link_Piste[ind, 2] = 0
            Link_Piste[ind, 3] = Link_RF[pixel, 2]
            Link_Piste[ind, 4] = pixel
            Link_Piste[ind, 5] = Link_RF[pixel, 3]
            Link_Piste[ind, 6] = 1
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance:
        test = 0
        pixel = 1
        while pixel < nb_pixel_Piste:
            if Link_Piste[pixel, 6] == 1:
                test = 1
                y1 = int(Link_Piste[pixel, 0])
                x1 = int(Link_Piste[pixel, 1])
                Link_Piste[pixel, 6] = 2
                dist_ac = Link_Piste[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if Piste[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_Piste, x, y)
                            if Link_Piste[ind, 2] > Dist:
                                Link_Piste[ind, 2] = Dist
                                Link_Piste[ind, 3] = Link_Piste[pixel, 3]
                                Link_Piste[ind, 4] = Link_Piste[pixel, 4]
                                Link_Piste[ind, 5] = Link_Piste[pixel, 5]
                                Link_Piste[ind, 6] = 1
            pixel += 1

        if test == 0:
            break

    # Verifie si certaines pistes ne sont pas connectee
    test = 0
    pixel = 1

    # Initialisation du raster
    while pixel < nb_pixel_Piste:
        if Link_Piste[pixel, 2] == 100001:
            y1 = int(Link_Piste[pixel, 0])
            x1 = int(Link_Piste[pixel, 1])
            for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                    if Res_Pub[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        if Link_Piste[pixel, 2] > Dist:
                            ind = seek_ind_i(Tab_res_pub, x, y)
                            Link_Piste[pixel, 2] = Dist
                            Link_Piste[pixel, 3] = 0
                            Link_Piste[pixel, 4] = -9999
                            Link_Piste[pixel, 5] = ind
                            Link_Piste[pixel, 6] = 1
                            test = 1
                    if RF[y, x] == 1:
                        if y != y1 and x != x1:
                            Dist = cost_rast[y, x] * diag
                        else:
                            Dist = cost_rast[y, x] * direct
                        if Link_Piste[pixel, 2] > Dist:
                            ind = seek_ind_i(Link_RF, x, y)
                            Link_Piste[pixel, 2] = Dist
                            Link_Piste[pixel, 3] = Link_RF[ind, 2]
                            Link_Piste[pixel, 4] = ind
                            Link_Piste[pixel, 5] = Link_RF[ind, 3]
                            Link_Piste[pixel, 6] = 1
                            test = 1
        pixel += 1

    # Traitement complet
    while test:
        test = 0
        pixel = 1
        while pixel < nb_pixel_Piste:
            if Link_Piste[pixel, 6] == 1:
                test = 1
                y1 = int(Link_Piste[pixel, 0])
                x1 = int(Link_Piste[pixel, 1])
                Link_Piste[pixel, 6] = 2
                dist_ac = Link_Piste[pixel, 2]

                for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                    for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                        if Piste[y, x] == 1:
                            if y != y1 and x != x1:
                                Dist = cost_rast[y, x] * diag + dist_ac
                            else:
                                Dist = cost_rast[y, x] * direct + dist_ac
                            ind = seek_ind(Link_Piste, x, y)
                            if Link_Piste[ind, 2] > Dist:
                                Link_Piste[ind, 2] = Dist
                                Link_Piste[ind, 3] = Link_Piste[pixel, 3]
                                Link_Piste[ind, 4] = Link_Piste[pixel, 4]
                                Link_Piste[ind, 5] = Link_Piste[pixel, 5]
                                Link_Piste[ind, 6] = 1
            pixel += 1

    return Link_Piste[:, 0:-1]


def Dfwd_flat_forest_road(Link_RF, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = zone_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    nb_pixel_RF = Link_RF.shape[0]

    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (Max_distance + 1)
    L_forRF = np.ones_like(zone_rast, dtype=np.int32) * -9999

    x, y, x1, y1 = 0, 0, 0, 0
    test = 0
    count_sans_match = 0
    Dist = 0
    dist_ac = Csize

    # Initialisation du raster
    pixel = 1
    while pixel < nb_pixel_RF:
        y1 = Link_RF[pixel, 0]
        x1 = Link_RF[pixel, 1]
        Out_distance[y1, x1] = 0
        L_forRF[y1, x1] = pixel
        for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct
                    if Out_distance[y, x] > Dist:
                        Out_distance[y, x] = int(Dist + 0.5)
                        L_forRF[y, x] = pixel
                        x1, y1 = x, y
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        y1, x1 = h, l
        test = 0
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] > Dist:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    L_forRF[y, x] = L_forRF[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline):
        for x in range(0, ncol):
            if Out_distance[y, x] > Max_distance:
                Out_distance[y, x] = -9999
                L_forRF[y, x] = -9999

    return Out_distance, L_forRF


def Dfwd_flat_forest_tracks(Link_Piste, cost_rast, zone_rast, Csize, Max_distance=100000):
    nline, ncol = zone_rast.shape
    diag = 1.414214 * Csize
    direct = Csize
    nb_pixel_Piste = Link_Piste.shape[0]


    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (Max_distance + 1)
    L_forPiste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dpiste = np.ones_like(zone_rast, dtype=np.int32) * -9999

    x, y, x1, y1 = 0, 0, 0, 0
    test = 0
    count_sans_match = 0
    Dist = 0
    dist_ac = Csize

    # Initialisation du raster
    pixel = 1
    while pixel < nb_pixel_Piste:
        y1 = Link_Piste[pixel, 0]
        x1 = Link_Piste[pixel, 1]
        Out_distance[y1, x1] = 0
        L_forPiste[y1, x1] = pixel
        Dpiste[y1, x1] = Link_Piste[pixel, 2]
        for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct
                    if Out_distance[y, x] >= Dist and Dpiste[y, x] + 2 * Out_distance[y, x] > 2 * Dist + Link_Piste[
                        pixel, 2]:
                        Out_distance[y, x] = int(Dist + 0.5)
                        L_forPiste[y, x] = pixel
                        Dpiste[y, x] = Link_Piste[pixel, 2]
                        if y < h: h = y
                        if x < l: l = x
                        if y > b: b = y
                        if x > r: r = x
        pixel += 1

    # Traitement complet
    while dist_ac <= Max_distance and count_sans_match < 15 * Csize:
        y1, x1 = h, l
        test = 0
        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2)):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2)):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac
                                if Out_distance[y, x] >= Dist and Dpiste[y, x] + 2 * Out_distance[y, x] > 2 * Dist + Dpiste[
                                    y1, x1]:
                                    Out_distance[y, x] = int(Dist + 0.5)
                                    L_forPiste[y, x] = L_forPiste[y1, x1]
                                    Dpiste[y, x] = Dpiste[y1, x1]
        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1
        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline):
        for x in range(0, ncol):
            if Out_distance[y, x] > Max_distance:
                Out_distance[y, x] = -9999
                L_forPiste[y, x] = -9999
                Dpiste[y, x] = -9999

    return Out_distance, L_forPiste, Dpiste


def fwd_azimuts_contour(Lien_RF, MNT, Aspect, Pente, Row_line, Col_line, D_line, Nbpix_line,
                        Fwd_max_up, Fwd_max_down, Fwd_max_inc, Forw_Lmax, nrows, ncols, Zone_ok):
    Max_distance = 100000
    Out_distance = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    Dfor = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    Dpis = np.ones((nrows, ncols), dtype=np.int32) * (Max_distance + 1)
    L_pis = np.zeros((nrows, ncols), dtype=np.int32) - 9999
    L_RF = np.zeros((nrows, ncols), dtype=np.int32) - 9999

    for pixel in range(1, Lien_RF.shape[0]):
        coordY = Lien_RF[pixel, 0]
        coordX = Lien_RF[pixel, 1]
        Alt_RF = MNT[coordY, coordX]
        testRF = 0
        lienRF = Lien_RF[pixel, 4]
        lienPiste = Lien_RF[pixel, 5]
        dpist = Lien_RF[pixel, 2]
        dfor = Lien_RF[pixel, 3]

        for az in range(360):
            nbpix = Nbpix_line[az]

            for i in range(1, nbpix):
                Y = coordY + Row_line[az, i]
                if Y < 0:
                    break
                if Y >= nrows:
                    break
                X = coordX + Col_line[az, i]
                if X < 0:
                    break
                if X >= ncols:
                    break
                if not Zone_ok[Y, X]:
                    break

                Hdist = D_line[az, i]
                Alt_pixel = MNT[Y, X]
                dist = sqrt(Hdist * Hdist + (Alt_pixel - Alt_RF) * (Alt_pixel - Alt_RF))

                if dist > Forw_Lmax:
                    break

                if MNT[Y, X] > Alt_RF:
                    if Pente[Y, X] > Fwd_max_down:
                        break
                else:
                    if Pente[Y, X] > Fwd_max_up:
                        break

                dif_angle = (az - Aspect[Y, X]) % 180.
                max_slope = fabs(Fwd_max_inc / cos((90. - dif_angle) / 180 * pi))

                if Pente[Y, X] > max_slope:
                    break

                if Dpis[Y, X] == (Max_distance + 1):
                    Out_distance[Y, X] = int(dist + 0.5)
                    Dpis[Y, X] = int(dpist + 0.5)
                    Dfor[Y, X] = int(dfor + 0.5)
                    L_RF[Y, X] = lienRF
                    L_pis[Y, X] = lienPiste
                    testRF = 1
                else:
                    if (Out_distance[Y, X] + Dpis[Y, X] * 0.1 + Dfor[Y, X]) > (dist + dfor + 0.1 * dpist):
                        Out_distance[Y, X] = int(dist + 0.5)
                        Dpis[Y, X] = int(dpist + 0.5)
                        Dfor[Y, X] = int(dfor + 0.5)
                        L_RF[Y, X] = lienRF
                        L_pis[Y, X] = lienPiste
                        testRF = 1

        if testRF:
            Out_distance[coordY, coordX] = 0
            Dpis[coordY, coordX] = int(dpist + 0.5)
            Dfor[coordY, coordX] = int(dfor + 0.5)
            L_RF[coordY, coordX] = lienRF
            L_pis[coordY, coordX] = lienPiste

    for Y in range(0, nrows, 1):
        for X in range(0, ncols, 1):
            if Out_distance[Y, X] > Max_distance:
                Out_distance[Y, X] = -9999
                L_RF[Y, X] = -9999
                L_pis[Y, X] = -9999
                Dpis[Y, X] = -9999
                Dfor[Y, X] = -9999

    return Out_distance, L_RF, L_pis, Dpis, Dfor


def Fwd_add_contour(Lien_contour, cost_rast, zone_rast, Forw_portee, Csize):
    nline, ncol = zone_rast.shape[0], zone_rast.shape[1]
    diag = 1.414214 * Csize
    direct = Csize
    Dist, dist_ac = Csize, Csize
    Max_distance = int(Forw_portee + 0.5)
    nb_pixel_contour = Lien_contour.shape[0]
    h, b, l, r = nline, 0, ncol, 0

    # Creation des rasters de sorties
    Out_distance = np.ones_like(zone_rast, dtype=np.int32) * (100 + 1)
    Lien_RF = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Lien_piste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dpiste = np.ones_like(zone_rast, dtype=np.int32) * -9999
    Dforet = np.ones_like(zone_rast, dtype=np.int32) * -9999

    y1, x1, test, count_sans_match, pixel = 0, 0, 0, 0, 1

    # Initialisation du raster
    while pixel < nb_pixel_contour:
        y1, x1 = Lien_contour[pixel, 0], Lien_contour[pixel, 1]
        Out_distance[y1, x1] = 0
        Lien_RF[y1, x1] = Lien_contour[pixel, 3]
        Lien_piste[y1, x1] = Lien_contour[pixel, 5]
        Dpiste[y1, x1] = Lien_contour[pixel, 4]
        Dforet[y1, x1] = Lien_contour[pixel, 2]

        for y in range(max(0, y1 - 1), min(nline, y1 + 2), 1):
            for x in range(max(0, x1 - 1), min(ncol, x1 + 2), 1):
                if zone_rast[y, x] == 1:
                    if y != y1 and x != x1:
                        Dist = cost_rast[y, x] * diag
                    else:
                        Dist = cost_rast[y, x] * direct

                    if Dist <= Max_distance:
                        if Out_distance[y, x] == 101:
                            Out_distance[y, x] = int(Dist + 0.5)
                            Lien_RF[y, x] = Lien_RF[y1, x1]
                            Lien_piste[y, x] = Lien_piste[y1, x1]
                            Dpiste[y, x] = Dpiste[y1, x1]
                            Dforet[y, x] = Dforet[y1, x1]

                            if y < h:
                                h = y
                            if x < l:
                                l = x
                            if y > b:
                                b = y
                            if x > r:
                                r = x
                        else:
                            if Out_distance[y, x] + 0.1 * Dpiste[y, x] + Dforet[y, x] > Dist + 0.1 * Dpiste[y1, x1] + Dforet[y1, x1]:
                                Out_distance[y, x] = int(Dist + 0.5)
                                Lien_RF[y, x] = Lien_RF[y1, x1]
                                Lien_piste[y, x] = Lien_piste[y1, x1]
                                Dpiste[y, x] = Dpiste[y1, x1]
                                Dforet[y, x] = Dforet[y1, x1]

                                if y < h:
                                    h = y
                                if x < l:
                                    l = x
                                if y > b:
                                    b = y
                                if x > r:
                                    r = x

        pixel += 1

    # Traitement complet
    while dist_ac <= 100 and count_sans_match < 15 * Csize:
        test = 0
        y1, x1 = h, l

        for y1 in range(h, b):
            for x1 in range(l, r):
                if Out_distance[y1, x1] == dist_ac:
                    test = 1
                    for y in range(max(0, y1 - 1), min(nline, y1 + 2), 1):
                        for x in range(max(0, x1 - 1), min(ncol, x1 + 2), 1):
                            if zone_rast[y, x] == 1:
                                if y != y1 and x != x1:
                                    Dist = cost_rast[y, x] * diag + dist_ac
                                else:
                                    Dist = cost_rast[y, x] * direct + dist_ac

                                if Dist <= Max_distance:
                                    if Out_distance[y, x] == 101:
                                        Out_distance[y, x] = int(Dist + 0.5)
                                        Lien_RF[y, x] = Lien_RF[y1, x1]
                                        Lien_piste[y, x] = Lien_piste[y1, x1]
                                        Dpiste[y, x] = Dpiste[y1, x1]
                                        Dforet[y, x] = Dforet[y1, x1]
                                    else:
                                        if Out_distance[y, x] + 0.1 * Dpiste[y, x] + Dforet[y, x] > Dist + 0.1 * Dpiste[y1, x1] + Dforet[y1, x1]:
                                            Out_distance[y, x] = int(Dist + 0.5)
                                            Lien_RF[y, x] = Lien_RF[y1, x1]
                                            Lien_piste[y, x] = Lien_piste[y1, x1]
                                            Dpiste[y, x] = Dpiste[y1, x1]
                                            Dforet[y, x] = Dforet[y1, x1]

        if test == 1:
            count_sans_match = 0
        else:
            count_sans_match += 1

        dist_ac += 1
        h = max(0, h - 1)
        b = min(nline, b + 1)
        l = max(0, l - 1)
        r = min(ncol, r + 1)

    for y in range(0, nline, 1):
        for x in range(0, ncol, 1):
            if Out_distance[y, x] > 100:
                Out_distance[y, x] = -9999
                Lien_RF[y, x] = -9999
                Lien_piste[y, x] = -9999
                Dpiste[y, x] = -9999
                Dforet[y, x] = -9999

    return Out_distance, Lien_RF, Lien_piste, Dpiste, Dforet


def fill_Link(Lien_foret_piste, Lien_piste, Lien_RF, Lien_foret_RF, nrows, ncols):
    Lien_foret_res_pub = np.ones((nrows, ncols), dtype=np.int32) * -9999
    Keep = np.zeros((nrows, ncols), dtype=np.int8)

    for y in range(nrows):
        for x in range(ncols):
            pixel = Lien_foret_piste[y, x]

            if pixel > 0:
                Keep[Lien_piste[pixel, 0], Lien_piste[pixel, 1]] = 1
                Lien_foret_res_pub[y, x] = Lien_piste[pixel, 5]
                Lien_foret_RF[y, x] = Lien_piste[pixel, 4]
            else:
                pixel2 = Lien_foret_RF[y, x]

                if pixel2 > 0:
                    Keep[Lien_RF[pixel2, 0], Lien_RF[pixel2, 1]] = 1
                    Lien_foret_res_pub[y, x] = Lien_RF[pixel2, 3]

    return Lien_foret_res_pub, Lien_foret_RF, Keep

